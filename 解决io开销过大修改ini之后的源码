package com.boco.wangyou.ltemr.basetable.domainmodel;

import java.io.IOException;

public abstract class LteMrXmlBaseParse {
	public abstract void read() throws IOException;
}
package com.boco.wangyou.ltemr.basetable.domainmodel.mre;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.boco.wangyou.algorithm.counter.FreqParse;
import com.boco.wangyou.ltemr.basetable.domainmodel.LteMrXmlBaseParse;
import com.boco.wangyou.ltemr.basetable.domainmodel.XmlParseBaseStream;
import com.boco.wangyou.ltemr.basetable.entity.TdlMrBaseNc;
import com.boco.wangyou.ltemr.basetable.entity.mre.TdlMreBase;
import com.boco.wangyou.ltemr.parse.domainmodel.MrParseDomain;
import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.MrKeyInfo;
import com.boco.wangyou.ltemr.parse.entity.SmrValue;
import com.boco.wangyou.ltemr.parse.entity.XmlCommonInfo;
import com.boco.wangyou.utility.cfg.ConfigConstants;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.write.WriteData;

public class LteMreXmlBaseParse extends LteMrXmlBaseParse {
	private XmlParseBaseStream _stream = null;
	private CommonInfo _commonInfo = null;
	private WriteData _writeData = null;
	private IniParseDomain _iniParse = null;
	private List<Integer> _baseHours = null;
	private ConfigConstants _cfgInfo = null;
	private SmrValue _smr = new SmrValue();
	private FreqParse _freqParse = new FreqParse();
	private String _splitStr = "";
	private int _rsrpWeak = 0;
	private StringBuffer _line = new StringBuffer(1000);
	
	public LteMreXmlBaseParse(XmlParseBaseStream stream, CommonInfo commonInfo, WriteData writeData, String iniDir, ConfigConstants cfgInfo, int type) {
		_stream = stream;
		_commonInfo = commonInfo;
		_writeData = writeData;
		_cfgInfo = cfgInfo;
		
		_baseHours = cfgInfo.getInts("MRE_BASEDATA_HOURS");
		_splitStr = cfgInfo.getValue("SPLIT_STRING", "|");
		_rsrpWeak = Integer.parseInt(_cfgInfo.getValue("RSRP_WEAK", "-110")) + 140;
		String encode = cfgInfo.getValue("CHARACTER_SET", "UTF-8");
		_iniParse = new IniParseDomain(iniDir, type, _splitStr, encode);
	}
	
	public void read() throws IOException {
		Map<String, TdlMreBase> baseMap = new HashMap<String, TdlMreBase>(10000);
		
		MrIdxInfo idxInfo = new MrIdxInfo();
		MrKeyInfo keyInfo = new MrKeyInfo(_splitStr);
		XmlCommonInfo xmlCommonInfo = new XmlCommonInfo(_splitStr);
		
		MrParseDomain mreParse = new MrParseDomain();
		
		BufferedReader br = _stream.getStream();
		String line = null;
		String enodebBackup = null;
		String timeStampBackup = null;
		while ((line = br.readLine()) != null) {
			line = line.toLowerCase();
			if (line.contains("<fileheader")) {
				mreParse.parseFileHeader(line, xmlCommonInfo);
				if (!_baseHours.contains(xmlCommonInfo.getStartTimeHour())) {
					mreParse.seekFileToEnd(br);
					continue;
				}
				continue;
			}
			
			if (line.contains("<enb")) {
				mreParse.parseEnb(line, xmlCommonInfo);
				String enodeb = xmlCommonInfo.getEnodeb();
				
				if (enodebBackup == null) {
					_iniParse.parseKey(enodeb);
					enodebBackup = enodeb;
				} if (!enodeb.equals(enodebBackup)) {					
					_iniParse.clear();
					_iniParse.parseKey(enodeb);
					enodebBackup = enodeb;
				}
				continue;
			}
			
			if (line.contains("<smr>")) {
				mreParse.parseSmr(line, idxInfo);
				mreParse.parseSmrFlag(idxInfo);
				
				int flag = idxInfo.getDataFlag();
				if (flag != 1) {
					mreParse.seekFile(br);
				}
				continue;
			}
			
			if (line.contains("<object")) {
				mreParse.parseObject(line, keyInfo, enodebBackup);
				String timeStamp = keyInfo.getTimeStamp();
				if (timeStampBackup != null && !timeStampBackup.equals(timeStamp)) {
					writeBaseData(baseMap, xmlCommonInfo, timeStampBackup);
					timeStampBackup = timeStamp;
				} else if (timeStampBackup == null) {
					timeStampBackup = timeStamp;
				}
				continue;
			}
			
			if (line.contains("<v>")) {
				int flag = idxInfo.getDataFlag();
				if (flag == 1) {
					String[] valueItems = line.toLowerCase().replaceAll("\\<\\/?v\\>", "").trim().split("\\s");
					makeBaseData(valueItems, baseMap, keyInfo, idxInfo);
				}
				continue;
			}
			
			if (line.contains("</bulkpmmrdatafile>")) {
				writeBaseData(baseMap, xmlCommonInfo, timeStampBackup);
			}
		}
	}
	
	private void makeBaseData(String[] valueItems, Map<String, TdlMreBase> baseMap, MrKeyInfo keyInfo, MrIdxInfo idxInfo) {
		String mreKey = keyInfo.getMreKey();
		String cellKey = keyInfo.getCell();
		TdlMreBase base = null;
		int len = valueItems.length;
		if (baseMap.containsKey(mreKey)) {
			base = baseMap.get(mreKey);
			base.setNcValue(valueItems, idxInfo, len, _iniParse, cellKey);
		} else {
			base = new TdlMreBase(_smr, _freqParse, _splitStr, _rsrpWeak);
			base.setValue(valueItems, idxInfo, len, _iniParse, cellKey);
		}
		baseMap.put(mreKey, base);
	}
	
	private void writeBaseData(Map<String, TdlMreBase> baseMap, XmlCommonInfo xmlCommonInfo, String timeStamp) {
		String commonLine = _commonInfo.getIdLine() + _splitStr + xmlCommonInfo.getLine();
		String startTime = _commonInfo.getStartTimeStr();
		
		for (Map.Entry<String, TdlMreBase> entry : baseMap.entrySet()) {
			String mreKey = entry.getKey();
			TdlMreBase base = entry.getValue();
			
			String mLine = base.getLine(_line);
			int diff6Num = base.getDiff6Num();
			List<TdlMrBaseNc> tdlMroBaseNcList = base.getTdlMroBaseNcList();
			int len = tdlMroBaseNcList.size();
			for (int i = 0; i < len; i++) {
				String nLine = tdlMroBaseNcList.get(i).getLine(_line, diff6Num);
				_writeData.writeBaseLine(commonLine + _splitStr + mreKey + _splitStr + timeStamp + _splitStr + mLine + _splitStr + nLine, "tdl_mre_basetable", startTime);
			}
		}
		baseMap.clear();
	}
}
package com.boco.wangyou.ltemr.basetable.domainmodel.mro;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.boco.wangyou.algorithm.counter.FreqParse;
import com.boco.wangyou.ltemr.basetable.domainmodel.LteMrXmlBaseParse;
import com.boco.wangyou.ltemr.basetable.domainmodel.XmlParseBaseStream;
import com.boco.wangyou.ltemr.basetable.entity.TdlMrBaseNc;
import com.boco.wangyou.ltemr.basetable.entity.mro.TdlMroBase;
import com.boco.wangyou.ltemr.basetable.entity.mro.TdlMroQci;
import com.boco.wangyou.ltemr.parse.domainmodel.MrParseDomain;
import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.MrKeyInfo;
import com.boco.wangyou.ltemr.parse.entity.SmrValue;
import com.boco.wangyou.ltemr.parse.entity.XmlCommonInfo;
import com.boco.wangyou.utility.cfg.ConfigConstants;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;
import com.boco.wangyou.utility.write.WriteData;

public class LteMroXmlBaseParse extends LteMrXmlBaseParse {
	private XmlParseBaseStream _stream = null;
	private CommonInfo _commonInfo = null;
	private WriteData _writeData = null;
	private IniParseDomain _iniParse = null;
	private List<Integer> _baseHours = null;
	private SmrValue _smr = new SmrValue();
	private FreqParse _freqParse = new FreqParse();
	private String _splitStr = "";
	private int _rsrpWeak = 0;
	private StringBuffer _line = new StringBuffer(1000);
	
	public LteMroXmlBaseParse(XmlParseBaseStream stream, CommonInfo commonInfo, WriteData writeData, String iniDir, ConfigConstants cfgInfo, int type) {
		_stream = stream;
		_commonInfo = commonInfo;
		_writeData = writeData;
		
		_baseHours = cfgInfo.getInts("MRO_BASEDATA_HOURS");
		_splitStr = cfgInfo.getValue("SPLIT_STRING", "|");
		_rsrpWeak = Integer.parseInt(cfgInfo.getValue("RSRP_WEAK", "-110")) + 140;
		String encode = cfgInfo.getValue("CHARACTER_SET", "UTF-8");
		double maxDis = Double.parseDouble(cfgInfo.getValue("MAX_DISTANCE", "10000"));
		_iniParse = new IniParseDomain(iniDir, type, _splitStr, encode, maxDis);
	}
	
	public void read() throws IOException {
		Map<String, TdlMroBase> baseMap = new HashMap<String, TdlMroBase>(10000);
		Map<String, TdlMroQci> qciMap = new HashMap<String, TdlMroQci>(10000);
		
		MrIdxInfo idxInfo = new MrIdxInfo();
		MrKeyInfo keyInfo = new MrKeyInfo(_splitStr);
		XmlCommonInfo xmlCommonInfo = new XmlCommonInfo(_splitStr);
		
		_iniParse.parseKey();
		Map<String, LteNcIniInfo> iniInfoMap = new HashMap<String, LteNcIniInfo>(10000);
		
		MrParseDomain mroParse = new MrParseDomain();
		MroQciParseDomain qciParse = new MroQciParseDomain(_stream.getQciStream(), _splitStr);
		
		BufferedReader br = _stream.getStream();
		String line = null;
		String enodebBackup = null;
		String timeStampBackup = null;
		while ((line = br.readLine()) != null) {
			line = line.toLowerCase();
			if (line.contains("<fileheader")) {
				mroParse.parseFileHeader(line, xmlCommonInfo);
				if (!_baseHours.contains(xmlCommonInfo.getStartTimeHour())) {
					mroParse.seekFileToEnd(br);
					continue;
				}
				qciParse.seekToQci(mroParse);
				continue;
			}
			
			if (line.contains("<enb")) {
				mroParse.parseEnb(line, xmlCommonInfo);
				String enodeb = xmlCommonInfo.getEnodeb();
				
				if (enodebBackup == null) {
					enodebBackup = enodeb;
				} else if (!enodeb.equals(enodebBackup)) {
					enodebBackup = enodeb;
					iniInfoMap.clear();
				}
				continue;
			}
			
			if (line.contains("<smr>")) {
				mroParse.parseSmr(line, idxInfo);
				mroParse.parseSmrFlag(idxInfo);
				
				int flag = idxInfo.getDataFlag();
				if (flag != 1) {
					mroParse.seekFile(br);
				}
				continue;
			}
			
			if (line.contains("<object")) {
				mroParse.parseObject(line, keyInfo, enodebBackup);
				String timeStamp = keyInfo.getTimeStamp();
				if (timeStampBackup == null) {
					qciParse.parse(qciMap, mroParse, timeStamp, enodebBackup);
					timeStampBackup = timeStamp;
				} else if (!timeStampBackup.equals(timeStamp)) {
					writeBaseData(baseMap, xmlCommonInfo, timeStampBackup);
					qciParse.parse(qciMap, mroParse, timeStamp, enodebBackup);
					timeStampBackup = timeStamp;
				}
				continue;
			}
			
			if (line.contains("<v>")) {
				int flag = idxInfo.getDataFlag();
				if (flag == 1) {
					String[] valueItems = line.toLowerCase().replaceAll("\\<\\/?v\\>", "").trim().split("\\s");
					makeBaseData(valueItems, baseMap, keyInfo, idxInfo, qciMap, iniInfoMap);
				}
				continue;
			}
			
			if (line.contains("</bulkpmmrdatafile>")) {
				writeBaseData(baseMap, xmlCommonInfo, timeStampBackup);
			}
		}
	}
	
	private void makeBaseData(String[] valueItems, Map<String, TdlMroBase> baseMap, MrKeyInfo keyInfo, MrIdxInfo idxInfo, Map<String, TdlMroQci> qciMap, Map<String, LteNcIniInfo> iniInfoMap) {
		String mroKey = keyInfo.getMroKey();
		String cellKey = keyInfo.getCell();
		TdlMroBase base = null;
		int len = valueItems.length;
		if (baseMap.containsKey(mroKey)) {
			base = baseMap.get(mroKey);
			base.setNcValue(valueItems, idxInfo, len, _iniParse, cellKey, iniInfoMap);
		} else {
			base = new TdlMroBase(_smr, _freqParse, _splitStr, _rsrpWeak);
			base.setValue(valueItems, idxInfo, len, _iniParse, cellKey, iniInfoMap);
		}
		if (qciMap.containsKey(mroKey)) {
			base.setQciValue(qciMap.get(mroKey));
		}
		baseMap.put(mroKey, base);
	}
	
	private void writeBaseData(Map<String, TdlMroBase> baseMap, XmlCommonInfo xmlCommonInfo, String timeStamp) {
		String commonLine1 = _commonInfo.getIdLine();
		String commonLine2 = xmlCommonInfo.getLine();
		String commonLine3 = xmlCommonInfo.getUserLabel();
//		String startTime = _commonInfo.getStartTimeStr();
		String startTime = xmlCommonInfo.getStartTimeStr();
		
		for (Map.Entry<String, TdlMroBase> entry : baseMap.entrySet()) {
			String mroKey = entry.getKey();
			TdlMroBase base = entry.getValue();
			String[] keys = mroKey.split("\\" + _splitStr, -1);
			if (keys.length != 5) {
				continue;
			}
			String userKey = keys[0] + _splitStr + keys[1] + _splitStr + keys[2];
			String cellKey = keys[3] + _splitStr + keys[4];
			
			String mLine = base.getLine(_line);
			String mIntId = base.getIntId();
			int scRsrp = base.getLteScRsrp();
			String scRsrq = base.getLteScRsrq();
			String scEarfcnPci = base.getEarfcnPci();
			int scFreq = base.getScFreq();
			
			int diff6Num = base.getDiff6Num();
			List<TdlMrBaseNc> tdlMroBaseNcList = base.getTdlMroBaseNcList();
			int len = tdlMroBaseNcList.size();
			for (int i = 0; i < len; i++) {
				TdlMrBaseNc tdlMrBaseNc = tdlMroBaseNcList.get(i);
				String nIntId = tdlMrBaseNc.getIntId();
				String nCellKey = tdlMrBaseNc.getCellKey();
				String nLine1 = tdlMrBaseNc.getLine1(_line);
				String nLine2 = tdlMrBaseNc.getLine2(_line, diff6Num);
				String out = commonLine1 + _splitStr + "460-00-" + cellKey.replace(_splitStr, "-") + _splitStr + mIntId + _splitStr + "460-00-" + nCellKey.replace(_splitStr, "-")
						+ _splitStr + nIntId + _splitStr + commonLine2 + _splitStr + cellKey + _splitStr + commonLine3 + _splitStr + scRsrp + _splitStr + tdlMrBaseNc.getLteNcRsrp()
						+ _splitStr + scRsrq + _splitStr + tdlMrBaseNc.getLteNcRsrq() + _splitStr + scEarfcnPci + _splitStr + tdlMrBaseNc.getEarfcnPci() + _splitStr + mLine
						+ _splitStr + nLine1 + _splitStr + userKey + _splitStr + timeStamp + _splitStr + cellKey.replace(_splitStr, "-") + _splitStr + nLine2 + _splitStr + scFreq
						+ _splitStr + tdlMrBaseNc.getNcFreq();
				_writeData.writeBaseLine(out, "tdl_mro_basetable", startTime);
			}
		}
		baseMap.clear();
	}
}
package com.boco.wangyou.ltemr.basetable.domainmodel.mro;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.Map;

import com.boco.wangyou.ltemr.basetable.entity.mro.TdlMroQci;
import com.boco.wangyou.ltemr.parse.domainmodel.MrParseDomain;
import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.MrKeyInfo;

public class MroQciParseDomain {
	private BufferedReader _brQci = null;
	private MrIdxInfo idxInfo = new MrIdxInfo();
	private MrKeyInfo keyInfo = null;
	private int endFlag = 0;
	private String timeStampQciBackup = null;
	
	public MroQciParseDomain(BufferedReader brQci, String splitStr) {
		_brQci = brQci;
		keyInfo = new MrKeyInfo(splitStr);
	}
	
	public void seekToQci(MrParseDomain mroParse) throws IOException {
		String line = null;
		while ((line = _brQci.readLine()) != null) {
			line = line.toLowerCase();
			if (line.contains("<smr>") && line.contains("qci") && !line.contains("rsrp")) {
				mroParse.parseSmr(line, idxInfo);
				endFlag = 0;
				break;
			}
			
			if (line.contains("</bulkpmmrdatafile>")) {
				endFlag = 1;
				break;
			}
		}
	}
	
	public void parse(Map<String, TdlMroQci> qciMap, MrParseDomain mroParse, String timeStamp, String enodeb) throws IOException {
		qciMap.clear();
		
		if (endFlag == 1) {
			return;
		}
		
		int flag = 0;
		if (timeStampQciBackup != null && timeStampQciBackup.equals(timeStamp)) {
			flag = 1;
		}
		
		String line = null;
		while ((line = _brQci.readLine()) != null) {
			line = line.toLowerCase();
			if (line.contains("</measurement>")) {
				seekToEnd();
				break;
			}
			
			if (line.contains("<object")) {
				mroParse.parseObject(line, keyInfo, enodeb);
				String timeStampQci = keyInfo.getTimeStamp();
				if (timeStampQci.compareTo(timeStamp) > 0) {
					timeStampQciBackup = timeStampQci;
					break;
				} else if (timeStampQci.equals(timeStamp)) {
					flag = 1;
				}
				continue;
			}
			
			if (line.contains("<v>")) {
				if (flag != 1) {
					continue;
				}
				
				String key = keyInfo.getMroKey();
				TdlMroQci qci = null;
				if (qciMap.containsKey(key)) {
					qci = qciMap.get(key);
				} else {
					qci = new TdlMroQci();
				}
				String[] valueItems = line.toLowerCase().replaceAll("\\<\\/?v\\>", "").trim().split("\\s");
				qci.setValue(valueItems, idxInfo);
				qciMap.put(key, qci);
			}
		}
	}
	
	private void seekToEnd() throws IOException {
		String line = null;
		while ((line = _brQci.readLine()) != null) {
			line = line.toLowerCase();
			if (line.contains("</bulkpmmrdatafile>")) {
				break;
			}
		}
	}
}
package com.boco.wangyou.ltemr.basetable.domainmodel;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.zip.GZIPInputStream;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;

import com.boco.wangyou.utility.LogUtil;

public class XmlParseBaseStream {
	private String _fileName = null;
	private BufferedReader br = null;
	private BufferedReader brQci = null;
	
	public void makeStream(File inputFile, int flag) {
		_fileName = inputFile.getName();
		try {
			br = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(inputFile))));
			if (flag == 1) {
				brQci = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(inputFile))));
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public void makeStream(Path inputFile, int flag) {
		_fileName = inputFile.getName();
		try {
//			FileSystem fs = FileSystem.get(new Configuration());
			FileSystem fs = FileSystem.get(LogUtil.getConfig());
			br = new BufferedReader(new InputStreamReader(new GZIPInputStream(fs.open(inputFile))));
			if (flag == 1) {
				brQci = new BufferedReader(new InputStreamReader(new GZIPInputStream(fs.open(inputFile))));
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public String getFileName() {
		return _fileName;
	}
	
	public BufferedReader getStream() {
		return br;
	}
	
	public BufferedReader getQciStream() {
		return brQci;
	}
	
	public void close() {
		try {
			if (br != null) {
				br.close();
			}
			if (brQci != null) {
				brQci.close();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
package com.boco.wangyou.ltemr.basetable.entity.mre;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.boco.wangyou.algorithm.counter.FreqParse;
import com.boco.wangyou.ltemr.basetable.entity.TdlMrBaseNc;
import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.SmrValue;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.LteIniInfo;

public class TdlMreBase {
	private int lteScRsrp = -1;
	private String lteScRsrq = "-1";
	private String lteScEarfcn = "-1";
	private String lteScPci = "-1";
	private List<TdlMrBaseNc> tdlMreBaseNcList = new ArrayList<TdlMrBaseNc>();
	private int scFreqType = -1;
	private String intId = "";
	private Set<String> earfcnPciList = new HashSet<String>(10);
	private int diff6Num = 0;
	private boolean effectiveFlag = true;
	private SmrValue _smr = null;
	private FreqParse _freqParse = null;
	private String _splitStr = "";
	private int _weakRsrp = 0;
	
	public TdlMreBase(SmrValue smr, FreqParse freqParse, String splitStr, int weakRsrp) {
		_smr = smr;
		_freqParse = freqParse;
		_splitStr = splitStr;
		_weakRsrp = weakRsrp;
	}
	
	public void setValue(String[] valueItems, MrIdxInfo idxInfo, int len, IniParseDomain iniParse, String cellKey) {
		if (len != idxInfo.getLen()) {
			return;
		}
		
		setScValue(valueItems, idxInfo, len, iniParse, cellKey);
		setNcValue(valueItems, idxInfo, len, iniParse, cellKey);
	}
	
	public void setNcValue(String[] valueItems, MrIdxInfo idxInfo, int len, IniParseDomain iniParse, String cellKey) {
		if (len != idxInfo.getLen()) {
			return;
		}
		
		TdlMrBaseNc tdlMreBaseNc = new TdlMrBaseNc(_splitStr, _weakRsrp);
		tdlMreBaseNc.setValue(valueItems, idxInfo, len, _smr, _freqParse);
		tdlMreBaseNc.setIntId(iniParse, cellKey);
		tdlMreBaseNc.setEffective(effectiveFlag, earfcnPciList);
		if (tdlMreBaseNc.setOverlapCondi(lteScRsrp)) {
			diff6Num++;
		}
		tdlMreBaseNcList.add(tdlMreBaseNc);
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		line.append(intId).append(_splitStr).append(lteScRsrp).append(_splitStr).append(lteScRsrq).append(_splitStr).append(lteScEarfcn).append(_splitStr).append(lteScPci).append(_splitStr).append(scFreqType);
		return line.toString();
	}
	
	public List<TdlMrBaseNc> getTdlMroBaseNcList() {
		return tdlMreBaseNcList;
	}
	
	public int getDiff6Num() {
		return diff6Num;
	}
	
	private void setScValue(String[] valueItems, MrIdxInfo idxInfo, int len, IniParseDomain iniParse, String cellKey) {
		LteIniInfo iniInfo = iniParse.getLteIniInfo(cellKey);
		lteScRsrp = Integer.parseInt(_smr.getValue("ltescrsrp", valueItems, idxInfo, len));
		lteScRsrq = _smr.getValue("ltescrsrq", valueItems, idxInfo, len);
		lteScEarfcn = _smr.getValue("ltescearfcn", valueItems, idxInfo, len);
		lteScPci = _smr.getValue("ltescpci", valueItems, idxInfo, len);
		if (("-1".equals(lteScEarfcn) || "-1".equals(lteScPci)) && !"".equals(iniInfo.getEarfcn()) && !"".equals(iniInfo.getPci())) {
			lteScEarfcn = iniInfo.getEarfcn();
			lteScPci = iniInfo.getPci();
		}
		scFreqType = _freqParse.getFreqType(Integer.parseInt(lteScEarfcn));
		intId = iniInfo.getIntId();
		if (!"-1".equals(lteScEarfcn) && !"-1".equals(lteScPci)) {
			earfcnPciList.add(lteScEarfcn + _splitStr + lteScPci);
		}
		if (lteScRsrp == -1 || "-1".equals(lteScEarfcn) || "-1".equals(lteScPci)) {
			effectiveFlag = false;
		}
	}
}
package com.boco.wangyou.ltemr.basetable.entity.mro;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.boco.wangyou.algorithm.counter.FreqParse;
import com.boco.wangyou.ltemr.basetable.entity.TdlMrBaseNc;
import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.SmrValue;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.LteIniInfo;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;

public class TdlMroBase {
	private int lteScRsrp = -1;
	private String lteScRsrq = "-1";
	private String lteScEarfcn = "-1";
	private String lteScPci = "-1";
	private String lteScRttd = "-1";
	private String lteScTadv = "-1";
	private String lteScPhr = "-1";
	private String lteScRip = "-1";
	private String lteScAoa = "-1";
	private String[] lteScPlrULQci = new String[9];
	private String[] lteScPlrDLQci = new String[9];
	private String lteScSinrUL = "-1";
	private String lteScPdschprbNum = "-1";
	private String lteScRi1 = "-1";
	private String lteScRi2 = "-1";
	private String lteScRi4 = "-1";
	private String lteScRi8 = "-1";
	private String lteScPuschprbNum = "-1";
	private String lteScBsr = "-1";
	private String lteScEnbRxTxTimeDiff = "-1";
	private List<TdlMrBaseNc> tdlMroBaseNcList = new ArrayList<TdlMrBaseNc>();
	private int scFreqType = -1;
	private String intId = "";
	private Set<String> earfcnPciList = new HashSet<String>(10);
	private int diff6Num = 0;
	private boolean effectiveFlag = true;
	private SmrValue _smr = null;
	private FreqParse _freqParse = null;
	private String _splitStr = "";
	private int _weakRsrp = 0;
	
	public TdlMroBase(SmrValue smr, FreqParse freqParse, String splitStr, int weakRsrp) {
		_smr = smr;
		_freqParse = freqParse;
		_splitStr = splitStr;
		_weakRsrp = weakRsrp;
		
		for (int i = 0; i < 9; i++) {
			lteScPlrULQci[i] = "-1";
			lteScPlrDLQci[i] = "-1";
		}
	}
	
	public void setValue(String[] valueItems, MrIdxInfo idxInfo, int len, IniParseDomain iniParse, String cellKey, Map<String, LteNcIniInfo> iniInfoMap) {
		if (len != idxInfo.getLen()) {
			return;
		}
		
		setScValue(valueItems, idxInfo, len, iniParse, cellKey);
		setNcValue(valueItems, idxInfo, len, iniParse, cellKey, iniInfoMap);
	}
	
	public void setNcValue(String[] valueItems, MrIdxInfo idxInfo, int len, IniParseDomain iniParse, String cellKey, Map<String, LteNcIniInfo> iniInfoMap) {
		if (len != idxInfo.getLen()) {
			return;
		}
		
		TdlMrBaseNc tdlMrBaseNc = new TdlMrBaseNc(_splitStr, _weakRsrp);
		tdlMrBaseNc.setValue(valueItems, idxInfo, len, _smr, _freqParse);
		tdlMrBaseNc.setIntId(iniParse, cellKey, iniInfoMap);
		tdlMrBaseNc.setEffective(effectiveFlag, earfcnPciList);
		if (tdlMrBaseNc.setOverlapCondi(lteScRsrp)) {
			diff6Num++;
		}
		tdlMroBaseNcList.add(tdlMrBaseNc);
	}
	
	public void setQciValue(TdlMroQci qci) {
		lteScPlrULQci = qci.getUlQci();
		lteScPlrDLQci = qci.getDlQci();
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		line.append(lteScRttd).append(_splitStr).append(lteScTadv).append(_splitStr).append(lteScPhr).append(_splitStr).append(lteScRip).append(_splitStr).append(lteScAoa).append(_splitStr);
		for (int i = 0; i < 9; i++) {
			line.append(lteScPlrULQci[i]).append(_splitStr);
		}
		for (int i = 0; i < 9; i++) {
			line.append(lteScPlrDLQci[i]).append(_splitStr);
		}
		line.append(lteScSinrUL).append(_splitStr).append(lteScRi1).append(_splitStr).append(lteScRi2).append(_splitStr).append(lteScRi4).append(_splitStr).append(lteScRi8).append(_splitStr)
			.append(lteScPuschprbNum).append(_splitStr).append(lteScPdschprbNum).append(_splitStr).append(lteScBsr).append(_splitStr).append(lteScEnbRxTxTimeDiff);
		return line.toString();
	}
	
	public List<TdlMrBaseNc> getTdlMroBaseNcList() {
		return tdlMroBaseNcList;
	}
	
	public int getDiff6Num() {
		return diff6Num;
	}
	
	public String getIntId() {
		return intId;
	}
	
	public int getLteScRsrp() {
		return lteScRsrp;
	}
	
	public String getLteScRsrq() {
		return lteScRsrq;
	}
	
	public String getEarfcnPci() {
		return lteScEarfcn + _splitStr + lteScPci;
	}
	
	public int getScFreq() {
		return scFreqType;
	}
	
	private void setScValue(String[] valueItems, MrIdxInfo idxInfo, int len, IniParseDomain iniParse, String cellKey) {
		LteIniInfo iniInfo = iniParse.getLteIniInfo(cellKey);
		lteScRsrp = Integer.parseInt(_smr.getValue("ltescrsrp", valueItems, idxInfo, len));
		lteScRsrq = _smr.getValue("ltescrsrq", valueItems, idxInfo, len);
		lteScEarfcn = _smr.getValue("ltescearfcn", valueItems, idxInfo, len);
		lteScPci = _smr.getValue("ltescpci", valueItems, idxInfo, len);
		if (("-1".equals(lteScEarfcn) || "-1".equals(lteScPci)) && !"".equals(iniInfo.getEarfcn()) && !"".equals(iniInfo.getPci())) {
			lteScEarfcn = iniInfo.getEarfcn();
			lteScPci = iniInfo.getPci();
		}
		lteScRttd = _smr.getValue("ltescrttd", valueItems, idxInfo, len);
		lteScTadv = _smr.getValue("ltesctadv", valueItems, idxInfo, len);
		lteScPhr = _smr.getValue("ltescphr", valueItems, idxInfo, len);
		lteScRip = _smr.getValue("ltescrip", valueItems, idxInfo, len);
		lteScAoa = _smr.getValue("ltescaoa", valueItems, idxInfo, len);
		for (int i = 1; i <= 9; i++) {
			lteScPlrULQci[i - 1] = _smr.getValue("ltescplrulqci" + i, valueItems, idxInfo, len);
			lteScPlrDLQci[i - 1] = _smr.getValue("ltescplrdlqci" + i, valueItems, idxInfo, len);
		}
		lteScSinrUL = _smr.getValue("ltescsinrul", valueItems, idxInfo, len);
		lteScPdschprbNum = _smr.getValue("ltescpdschprbnum", valueItems, idxInfo, len);
		lteScRi1 = _smr.getValue("ltescri1", valueItems, idxInfo, len);
		lteScRi2 = _smr.getValue("ltescri2", valueItems, idxInfo, len);
		lteScRi4 = _smr.getValue("ltescri4", valueItems, idxInfo, len);
		lteScRi8 = _smr.getValue("ltescri8", valueItems, idxInfo, len);
		lteScPuschprbNum = _smr.getValue("ltescpuschprbnum", valueItems, idxInfo, len);
		lteScBsr = _smr.getValue("ltescbsr", valueItems, idxInfo, len);
		lteScEnbRxTxTimeDiff = _smr.getValue("ltescenbrxtxtimediff", valueItems, idxInfo, len);
		scFreqType = _freqParse.getFreqType(Integer.parseInt(lteScEarfcn));
		intId = iniInfo.getIntId();
		if (!"-1".equals(lteScEarfcn) && !"-1".equals(lteScPci)) {
			earfcnPciList.add(lteScEarfcn + _splitStr + lteScPci);
		}
		if (lteScRsrp == -1 || "-1".equals(lteScEarfcn) || "-1".equals(lteScPci)) {
			effectiveFlag = false;
		}
	}
}
package com.boco.wangyou.ltemr.basetable.entity.mro;

import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;

public class TdlMroQci {
	private String[] lteScPlrUlQci = new String[9];
	private String[] lteScPlrDlQci = new String[9];
	
	public TdlMroQci() {
		for (int i = 0; i < 9; i++) {
			lteScPlrUlQci[i] = "-1";
			lteScPlrDlQci[i] = "-1";
		}
	}
	
	public void setValue(String[] valueItems, MrIdxInfo idxInfo) {
		if (valueItems.length != idxInfo.getLen()) {
			return;
		}
		
		int len = valueItems.length;
		for (int i = 0; i < 9; i++) {
			int idxUl = idxInfo.getIdx("ltescplrulqci" + String.valueOf(i + 1));
			if (idxUl != -1 && idxUl < len) {
				lteScPlrUlQci[i] = ("nil".equals(valueItems[idxUl])) ? "-1" : valueItems[idxUl];
			}
			
			int idxDl = idxInfo.getIdx("ltescplrdlqci" + String.valueOf(i + 1));
			if (idxDl != -1 && idxDl < len) {
				lteScPlrDlQci[i] = ("nil".equals(valueItems[idxDl])) ? "-1" : valueItems[idxDl];
			}
		}
	}
	
	public String[] getUlQci() {
		return lteScPlrUlQci;
	}
	
	public String[] getDlQci() {
		return lteScPlrDlQci;
	}
}
package com.boco.wangyou.ltemr.basetable.entity;

import java.util.Map;
import java.util.Set;

import com.boco.wangyou.algorithm.counter.FreqParse;
import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.SmrValue;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;

public class TdlMrBaseNc {
	private int lteNcRsrp = -1;
	private String lteNcRsrq = "-1";
	private String lteNcEarfcn = "-1";
	private String lteNcPci = "-1";
	private String gsmNcellBcch = "-1";
	private String gsmNcellCarrierRssi = "-1";
	private String gsmNcellNcc = "-1";
	private String gsmNcellBcc = "-1";
	private String tdsPccpchRscp = "-1";
	private String tdsNcellUarfcn = "-1";
	private String tdsCellParameterId = "-1";
	private int ncFreqType = -1;
	private int isNRsrpThreshold = 0;
	private int isEffective = 1;
	private boolean overlapCondiFlag = false;
	private String ncCellKey = "";
	private String intId = "";
	private String _splitStr = "";
	private int _weakRsrp = 0;
	
	public TdlMrBaseNc(String splitStr, int weakRsrp) {
		_splitStr = splitStr;
		_weakRsrp = weakRsrp;
	}
	
	public void setValue(String[] valueItems, MrIdxInfo idxInfo, int len, SmrValue smr, FreqParse freqParse) {
		lteNcRsrp = Integer.parseInt(smr.getValue("ltencrsrp", valueItems, idxInfo, len));
		lteNcRsrq = smr.getValue("ltencrsrq", valueItems, idxInfo, len);
		lteNcEarfcn = smr.getValue("ltencearfcn", valueItems, idxInfo, len);
		lteNcPci = smr.getValue("ltencpci", valueItems, idxInfo, len);
		gsmNcellBcch = smr.getValue("gsmncellbcch", valueItems, idxInfo, len);
		gsmNcellCarrierRssi = smr.getValue("gsmncellcarrierrssi", valueItems, idxInfo, len);
		gsmNcellNcc = smr.getValue("gsmncellncc", valueItems, idxInfo, len);
		gsmNcellBcc = smr.getValue("gsmncellbcc", valueItems, idxInfo, len);
		tdsPccpchRscp = smr.getValue("tdspccpchrscp", valueItems, idxInfo, len);
		tdsNcellUarfcn = smr.getValue("tdsncelluarfcn", valueItems, idxInfo, len);
		tdsCellParameterId = smr.getValue("tdscellparameterid", valueItems, idxInfo, len);
		ncFreqType = freqParse.getFreqType(Integer.parseInt(lteNcEarfcn));
		if(lteNcRsrp <= _weakRsrp){
			isNRsrpThreshold = 1;
		}
	}
	
	public void setIntId(IniParseDomain iniParse, String cellKey, Map<String, LteNcIniInfo> iniInfoMap) {
		ncCellKey = iniParse.getAdjNcell(cellKey, lteNcEarfcn + _splitStr + lteNcPci, iniInfoMap).getCellId();
		intId = iniParse.getLteIniInfo(ncCellKey).getIntId();
	}
	
	public void setEffective(boolean effectiveFlag, Set<String> earfcnPciList) {
		if (!effectiveFlag || lteNcRsrp == -1 || "-1".equals(lteNcEarfcn) || "-1".equals(lteNcPci)) {
			isEffective = 0;
			return;
		}
		
		String earfcnPci = lteNcEarfcn + _splitStr + lteNcPci;
		if (earfcnPciList.contains(earfcnPci)) {
			isEffective = 0;
			return;
		}
		earfcnPciList.add(earfcnPci);
	}
	
	public boolean setOverlapCondi(int lteScRsrp) {
		if (Math.abs(lteScRsrp - lteNcRsrp) < 6) {
			overlapCondiFlag = true;
			return true;
		}
		return false;
	}
	
	public String getLine(StringBuffer line, int diff6Num) {
		line.setLength(0);
		line.append(intId).append(_splitStr).append(ncCellKey).append(_splitStr).append(lteNcRsrp).append(_splitStr).append(lteNcRsrq).append(_splitStr).append(lteNcEarfcn).append(_splitStr).append(lteNcPci)
			.append(_splitStr).append(gsmNcellBcch).append(_splitStr).append(gsmNcellCarrierRssi).append(_splitStr).append(gsmNcellNcc).append(_splitStr).append(gsmNcellBcc)
			.append(_splitStr).append(tdsPccpchRscp).append(_splitStr).append(tdsNcellUarfcn).append(_splitStr).append(tdsCellParameterId).append(_splitStr);
		if (diff6Num >= 3) {
			if (!overlapCondiFlag) {
				line.append("0").append(_splitStr).append("0").append(_splitStr);
			} else {
				if (diff6Num >= 4) {
					line.append("1").append(_splitStr).append("1").append(_splitStr);
				} else {
					line.append("1").append(_splitStr).append("0").append(_splitStr);
				}
			}
		} else {
			line.append("-1").append(_splitStr).append("-1").append(_splitStr);
		}
		line.append(isNRsrpThreshold).append(_splitStr).append(isEffective).append(_splitStr).append(ncFreqType);
		return line.toString();
	}
	
	public String getLine1(StringBuffer line) {
		line.setLength(0);
		line.append(gsmNcellBcch).append(_splitStr).append(gsmNcellCarrierRssi).append(_splitStr).append(gsmNcellNcc).append(_splitStr).append(gsmNcellBcc)
			.append(_splitStr).append(tdsPccpchRscp).append(_splitStr).append(tdsNcellUarfcn).append(_splitStr).append(tdsCellParameterId);
		return line.toString();
	}
	
	public String getLine2(StringBuffer line, int diff6Num) {
		line.setLength(0);
		if (diff6Num >= 3) {
			if (!overlapCondiFlag) {
				line.append("0").append(_splitStr).append("0").append(_splitStr);
			} else {
				if (diff6Num >= 4) {
					line.append("1").append(_splitStr).append("1").append(_splitStr);
				} else {
					line.append("1").append(_splitStr).append("0").append(_splitStr);
				}
			}
		} else {
			line.append("-1").append(_splitStr).append("-1").append(_splitStr);
		}
		line.append(isNRsrpThreshold).append(_splitStr).append(isEffective);
		return line.toString();
	}
	
	public String getIntId() {
		return intId;
	}
	
	public String getCellKey() {
		return ncCellKey;
	}
	
	public int getLteNcRsrp() {
		return lteNcRsrp;
	}
	
	public String getLteNcRsrq() {
		return lteNcRsrq;
	}
	
	public String getEarfcnPci() {
		return lteNcEarfcn + _splitStr + lteNcPci;
	}
	
	public int getNcFreq() {
		return ncFreqType;
	}
}
package com.boco.wangyou.ltemr.basetable.invoker.hadoop;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

import com.boco.wangyou.utility.LogUtil;
import com.boco.wangyou.utility.cfg.DriverConfigUtils;
import com.boco.wangyou.utility.stream.NullInputFormat;

public class LteMrBaseParseDriver extends Configured implements Tool {
	public static void main(String[] args) throws Exception {
//		String[] args = {"cache/wy/ltemro/1501146327674","wangyou/ltemro/xml/temp_base","oozie_wy/ini","oozie_wy/config/lte","2017-06-15","oozie_wy/xmlout_temp"};
		
		if (args.length < 6) {
			System.out.println("Arguments list:\n$source_dir $dest_dir $ini_dir $cfg_dir $date_time");
			System.exit(0);
		}
		
		int ret = ToolRunner.run(new LteMrBaseParseDriver(), args);
		System.exit(ret);
	}
	
	@Override
	public int run(String[] args) throws Exception {
//		Configuration conf = new Configuration();
		Configuration basicConf = LogUtil.getConfig();
		
		DriverConfigUtils dConfigs = new DriverConfigUtils(); 
		String driverCfg = args[3]+"/parse_driver.properties";
		Configuration conf = dConfigs.initConfig(basicConf,driverCfg);
		
		conf.set("DEST_PATH", args[1]);
		conf.set("INIT_PATH", args[2]);
		conf.set("CONFIG_PATH", args[3]);
		conf.set("START_TIME", args[4]);
		
		FileSystem fs =FileSystem.get(conf);
		Path outPath = new Path(args[5]);
		if (fs.exists(outPath)) {
			fs.delete(outPath, true);
		}
			
		Job job = Job.getInstance(conf);
		job.setJarByClass(LteMrBaseParseDriver.class);
		job.setJobName(getClass().getName());
		FileInputFormat.setInputPaths(job, new Path(args[0]));
		FileOutputFormat.setOutputPath(job, outPath);
		job.setInputFormatClass(NullInputFormat.class);
		job.setMapperClass(LteMrBaseParseMapper.class);
		job.setNumReduceTasks(0);
		job.setMapOutputKeyClass(Text.class);
		job.setMapOutputValueClass(Text.class);
		
		boolean success = job.waitForCompletion(true);
		return success ? 0 : 1;
	}
}
package com.boco.wangyou.ltemr.basetable.invoker.hadoop;

import java.io.IOException;

import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.lib.input.FileSplit;

import com.boco.wangyou.ltemr.basetable.domainmodel.LteMrXmlBaseParse;
import com.boco.wangyou.ltemr.basetable.domainmodel.XmlParseBaseStream;
//import com.boco.wangyou.ltemr.basetable.domainmodel.mre.LteMreXmlBaseParse;
import com.boco.wangyou.ltemr.basetable.domainmodel.mro.LteMroXmlBaseParse;
import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.utility.cfg.ConfigConstants;
import com.boco.wangyou.utility.stream.NullInputFormat;
import com.boco.wangyou.utility.write.WriteData;
import com.boco.wangyou.utility.write.WriteDataHdfs;

public class LteMrBaseParseMapper extends Mapper<Object, NullInputFormat, Text, Text> {
	private XmlParseBaseStream _stream = null;
	private CommonInfo _commonInfo = null;
	private WriteData _writeData = null;
	private ConfigConstants _cfgInfo = null;
	private Path _file = null;
	private String _fileName = "";
	
	@Override
	public void setup(Context context) throws IOException, InterruptedException {
		FileSplit fileSplit = (FileSplit)context.getInputSplit();
		_file = fileSplit.getPath();
		_fileName = _file.getName();
		
		String cfgDir = context.getConfiguration().get("CONFIG_PATH");
		_cfgInfo = new ConfigConstants(cfgDir + "/ltemr_data.properties", 1);
		
		String startTime = context.getConfiguration().get("START_TIME");
		_commonInfo = new CommonInfo(_cfgInfo.getValue("SPLIT_STRING", "|"));
		_commonInfo.setTime(startTime);
		_commonInfo.setId(_fileName);
		
		String destDir = context.getConfiguration().get("DEST_PATH");
		String threadId = _fileName.substring(_fileName.lastIndexOf("_") + 1, _fileName.indexOf("."));
		String encode = _cfgInfo.getValue("CHARACTER_SET", "UTF-8");
		_writeData = new WriteDataHdfs(destDir, _commonInfo.getOmcId(), threadId, encode);
		
		_stream = new XmlParseBaseStream();
	}
	
	@Override
	public void map(Object key, NullInputFormat value, Context context) throws IOException, InterruptedException {
		String iniDir = context.getConfiguration().get("INIT_PATH");
		
		_stream.makeStream(_file, 1);
		LteMrXmlBaseParse parse = new LteMroXmlBaseParse(_stream, _commonInfo, _writeData, iniDir, _cfgInfo, 1);
		/*if (_fileName.contains("MRO")) {
			_stream.makeStream(_file, 1);
			parse = new LteMroXmlBaseParse(_stream, _commonInfo, _writeData, iniDir, _cfgInfo, 1);
		} else if (_fileName.contains("MRE")) {
			_stream.makeStream(_file, 0);
			parse = new LteMreXmlBaseParse(_stream, _commonInfo, _writeData, iniDir, _cfgInfo, 1);
		} else {
			return;
		}*/
		try {
			parse.read();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	@Override
	public void cleanup(Context context) throws IOException, InterruptedException {
		_stream.close();
		_writeData.close();
	}
}
package com.boco.wangyou.ltemr.basetable.invoker.local;

import java.io.File;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import com.boco.wangyou.utility.cfg.ConfigConstants;

public class Invoker {
	public static void main(String[] args) {
		if (args.length < 5) {
			System.out.println("Arguments list:\n$source_dir $dest_dir $ini_dir $cfg_dir $date_time");
			System.exit(0);
		}
		
		String sourceDir = args[0];
		String destDir = args[1];
		String iniDir = args[2];
		String cfgDir = args[3];
		String startTime = args[4];
		
		ConfigConstants cfgInfo = new ConfigConstants(cfgDir + "/ltemr_data.properties", 0);
		int threadNum = Integer.parseInt(cfgInfo.getValue("PARSE_THREAD_NUM", "4"));
		
		File dir = new File(sourceDir);
		File[] files = dir.listFiles();
		if (files == null) {
			return;
		}
		ExecutorService executor = Executors.newFixedThreadPool(threadNum);
		for (File file : files) {
			LteMrBaseParse parse = new LteMrBaseParse(file, destDir, iniDir, cfgInfo, startTime);
			executor.execute(parse);
		}
		executor.shutdown();
		try {
			if (!executor.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS)) {
				executor.shutdownNow();
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
package com.boco.wangyou.ltemr.basetable.invoker.local;

import java.io.File;
import java.io.IOException;

import com.boco.wangyou.ltemr.basetable.domainmodel.LteMrXmlBaseParse;
import com.boco.wangyou.ltemr.basetable.domainmodel.XmlParseBaseStream;
//import com.boco.wangyou.ltemr.basetable.domainmodel.mre.LteMreXmlBaseParse;
import com.boco.wangyou.ltemr.basetable.domainmodel.mro.LteMroXmlBaseParse;
import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.utility.cfg.ConfigConstants;
import com.boco.wangyou.utility.write.WriteData;
import com.boco.wangyou.utility.write.WriteDataLocal;

public class LteMrBaseParse implements Runnable {
	private File _sourceFile = null;
	private String _destDir = null;
	private String _iniDir = null;
	private ConfigConstants _cfgInfo = null;
	private CommonInfo _commonInfo = null;
	
	public LteMrBaseParse(File sourceFile, String destDir, String iniDir, ConfigConstants cfgInfo, String startTime) {
		_sourceFile = sourceFile;
		_destDir = destDir;
		_iniDir = iniDir;
		_cfgInfo = cfgInfo;
		_commonInfo = new CommonInfo(_cfgInfo.getValue("SPLIT_STRING", "|"));
		_commonInfo.setTime(startTime);
		_commonInfo.setId(_sourceFile.getName());
	}
	
	public void run() {
		String fileName = _sourceFile.getName();
		String threadId = fileName.substring(fileName.lastIndexOf("_") + 1, fileName.indexOf("."));
		String encode = _cfgInfo.getValue("CHARACTER_SET", "UTF-8");
		WriteData writeData = new WriteDataLocal(_destDir, _commonInfo.getOmcId(), threadId, encode);
		
		XmlParseBaseStream stream = new XmlParseBaseStream();
		
		stream.makeStream(_sourceFile, 1);
		LteMrXmlBaseParse parse = new LteMroXmlBaseParse(stream, _commonInfo, writeData, _iniDir, _cfgInfo, 0);
		/*if (fileName.contains("MRO")) {
			stream.makeStream(_sourceFile, 1);
			parse = new LteMroXmlBaseParse(stream, _commonInfo, writeData, _iniDir, _cfgInfo, 0);
		} else if (fileName.contains("MRE")) {
			stream.makeStream(_sourceFile, 0);
			parse = new LteMreXmlBaseParse(stream, _commonInfo, writeData, _iniDir, _cfgInfo, 0);
		} else {
			stream.close();
			writeData.close();
			return;
		}*/
		try {
			parse.read();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		stream.close();
		writeData.close();
	}
}
package com.boco.wangyou.utility.ini.domainmodel;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;

import com.boco.wangyou.utility.coverage.CalculateDistance;
import com.boco.wangyou.utility.ini.entity.GsmIniInfo;
import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;
import com.boco.wangyou.utility.ini.entity.LteIniInfo;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;

public class IniParseDomain {
	private Map<String, LteIniInfo> iniMap = new HashMap<String, LteIniInfo>(10000);
	private Map<String, List<String>> iniAdjMap = new HashMap<String, List<String>>(1000);
	private Map<String, List<GsmIniInfo>> gsmIniAdjMap = new HashMap<String, List<GsmIniInfo>>(1000);
	private String _iniDir = null;
	private int _type = 0;
	private String _splitStr = "";
	private String _encode = "";
	private double _maxDis = 0;
	private CalculateDistance cal = new CalculateDistance();
	
	public IniParseDomain(String iniDir, int type, String splitStr, String encode, double maxDis) {
		_iniDir = iniDir;
		_type = type;
		_splitStr = splitStr;
		_encode = encode;
		_maxDis = maxDis;
	}
	
	public void parseAll() throws IOException {
		if (_type == 0) {
			parseIniLocal(0);
		} else {
			parseIniHdfs(0);
		}
	}
	
	public void parseKey() throws IOException {
		if (_type == 0) {
			parseIniLocal(1);
		} else {
			parseIniHdfs(1);
		}
	}
	
	public Map<String, LteIniInfo> getIniMap() {
		return iniMap;
	}
	
	public LteIniInfo getLteIniInfo(String cell) {
		if (iniMap.containsKey(cell)) {
			return iniMap.get(cell);
		}
		return new LteIniInfo(_splitStr);
	}
	
	public LteNcIniInfo getAdjNcell(String mCell, String earfcnPci, Map<String, LteNcIniInfo> iniInfoMap) {
		String key = mCell + _splitStr + earfcnPci;
		if (iniInfoMap.containsKey(key)) {
			return iniInfoMap.get(key);
		}
		
		if (!iniMap.containsKey(mCell) || !iniAdjMap.containsKey(earfcnPci) || Math.abs(iniMap.get(mCell).getLongitude()) < 0.00001 || Math.abs(iniMap.get(mCell).getLatitude()) < 0.00001) {
			return new LteNcIniInfo(_splitStr);
		}
		
		LteIniInfo iniInfo = iniMap.get(mCell);
		double mLatitude = iniInfo.getLatitude();
		double mLongitude = iniInfo.getLongitude();
		List<String> nCellList = iniAdjMap.get(earfcnPci);
		
		double minDis = 0;
		String minCell = null;
		for (String nCell : nCellList) {
			if (!iniMap.containsKey(nCell)) {
				continue;
			}
			
			LteIniInfo ncIniInfo = iniMap.get(nCell);
			double nLatitude = ncIniInfo.getLatitude();
			double nLongitude = ncIniInfo.getLongitude();
			if (Math.abs(nLongitude) < 0.00001 || Math.abs(nLatitude) < 0.00001 || Math.abs(mLongitude - nLongitude) > 0.1 || Math.abs(mLatitude - nLatitude) > 0.1) {
				continue;
			}
			
			double dis = cal.getDis(mLongitude, mLatitude, nLongitude, nLatitude);
			if (dis > _maxDis) {
				continue;
			}
			if (minCell == null || minDis > dis) {
				minCell = nCell;
				minDis = dis;
			}
		}
		
		if (minCell == null) {
			return new LteNcIniInfo(_splitStr);
		}
		LteNcIniInfo ncInfo = new LteNcIniInfo(_splitStr);
		ncInfo.setValue(minCell, minDis);
		iniInfoMap.put(key, ncInfo);
		return ncInfo;
	}
	
	public GsmNcIniInfo getGsmAdjNcell(String mCell, String bsicBcch, Map<String, GsmNcIniInfo> gsmIniInfoMap) {
		String key = mCell + _splitStr + bsicBcch;
		if (gsmIniInfoMap.containsKey(key)) {
			return gsmIniInfoMap.get(key);
		}
		
		if (!iniMap.containsKey(mCell) || !gsmIniAdjMap.containsKey(bsicBcch) || Math.abs(iniMap.get(mCell).getLongitude()) < 0.00001 || Math.abs(iniMap.get(mCell).getLatitude()) < 0.00001) {
			return new GsmNcIniInfo(_splitStr);
		}
		
		LteIniInfo iniInfo = iniMap.get(mCell);
		double mLatitude = iniInfo.getLatitude();
		double mLongitude = iniInfo.getLongitude();
		List<GsmIniInfo> nCellList = gsmIniAdjMap.get(bsicBcch);
		
		double minDis = 0;
		GsmIniInfo minCell = null;
		for (GsmIniInfo nGsmInfo : nCellList) {
			double nLatitude = nGsmInfo.getLatitude();
			double nLongitude = nGsmInfo.getLongitude();
			if (Math.abs(nLongitude) < 0.00001 || Math.abs(nLatitude) < 0.00001 || Math.abs(mLongitude - nLongitude) > 0.1 || Math.abs(mLatitude - nLatitude) > 0.1) {
				continue;
			}
			
			double dis = cal.getDis(mLongitude, mLatitude, nLongitude, nLatitude);
			if (dis > _maxDis) {
				continue;
			}
			if (minCell == null || minDis > dis) {
				minCell = nGsmInfo;
				minDis = dis;
			}
		}
		
		if (minCell == null) {
			return new GsmNcIniInfo(_splitStr);
		}
		GsmNcIniInfo ncInfo = new GsmNcIniInfo(_splitStr);
		ncInfo.setValue(minCell, bsicBcch, minDis);
		gsmIniInfoMap.put(key, ncInfo);
		return ncInfo;
	}
	
	public void clear() {
		iniMap.clear();
		iniAdjMap.clear();
		gsmIniAdjMap.clear();
	}
	
	private void parseIniLocal(int type) throws IOException {
		File fileLte = new File(_iniDir + "/lte_mr.ini");
		if (fileLte.exists()) {
			BufferedReader brLte = new BufferedReader(new InputStreamReader(new FileInputStream(fileLte), _encode));
			parseIniFile(brLte, type);
		}
		
		File fileGsm = new File(_iniDir + "/gsm_mr.ini");
		if (fileGsm.exists()) {
			BufferedReader brGsm = new BufferedReader(new InputStreamReader(new FileInputStream(fileGsm), _encode));
			parseGsmIniFile(brGsm);
		}
	}
	
	private void parseIniHdfs(int type) throws IOException {
		Configuration conf = new Configuration();
		conf.setBoolean("fs.hdfs.impl.disable.cache", true);
		FileSystem fs = FileSystem.get(conf);
		
		Path pathLte = new Path(_iniDir + "/lte_mr.ini");
		if (fs.exists(pathLte)) {
			BufferedReader brLte = new BufferedReader(new InputStreamReader(fs.open(pathLte), _encode));
			parseIniFile(brLte, type);
		}
		
		Path pathGsm = new Path(_iniDir + "/gsm_mr.ini");
		if (fs.exists(pathGsm)) {
			BufferedReader brGsm = new BufferedReader(new InputStreamReader(fs.open(pathGsm), _encode));
			parseGsmIniFile(brGsm);
		}
	}
	
	private void parseIniFile(BufferedReader br, int type) throws IOException {
		String line = null;
		while ((line = br.readLine()) != null) {
			String[] valueItems = line.split("\\" + _splitStr, -1);
			if (valueItems.length < 17) {
				continue;
			}
			
			String cell = valueItems[1] + _splitStr + valueItems[2];
			LteIniInfo iniInfo = new LteIniInfo(_splitStr);
			iniInfo.setValue(valueItems, type);
			iniMap.put(cell, iniInfo);
			
			String earfcnPci = iniInfo.getEarfcn() + "|" + iniInfo.getPci();
			List<String> ncList = null;
			if (iniAdjMap.containsKey(earfcnPci)) {
				ncList = iniAdjMap.get(earfcnPci);
			} else {
				ncList = new ArrayList<String>(1000);
			}
			ncList.add(cell);
			iniAdjMap.put(earfcnPci, ncList);
		}
		br.close();
	}
	
	private void parseGsmIniFile(BufferedReader br) throws IOException {
		String line = null;
		while ((line = br.readLine()) != null) {
			String[] valueItems = line.split("\\" + _splitStr, -1);
			if (valueItems.length < 9) {
				continue;
			}
			
			String bsicBcch = valueItems[4] + "|" + valueItems[5] + "|" + valueItems[3];
			GsmIniInfo iniInfo = new GsmIniInfo(_splitStr);
			iniInfo.setValue(valueItems);
			List<GsmIniInfo> ncList = null;
			if (gsmIniAdjMap.containsKey(bsicBcch)) {
				ncList = gsmIniAdjMap.get(bsicBcch);
			} else {
				ncList = new ArrayList<GsmIniInfo>(1000);
			}
			ncList.add(iniInfo);
			gsmIniAdjMap.put(bsicBcch, ncList);
		}
		br.close();
	}
}
package com.boco.wangyou.utility.ini.domainmodel;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;

import com.boco.wangyou.utility.ini.entity.LteIniKeyInfo;

public class IniParseKeyDomain {
	private Map<String, LteIniKeyInfo> iniMap = new HashMap<String, LteIniKeyInfo>(10000);
	private String _iniDir = null;
	private int _type = 0;
	private String _splitStr = "";
	private String _encode = "";
	
	public IniParseKeyDomain(String iniDir, int type, String splitStr, String encode) {
		_iniDir = iniDir;
		_type = type;
		_splitStr = splitStr;
		_encode = encode;
	}
	
	public void parse() throws IOException {
		if (_type == 0) {
			parseIniLocal();
		} else {
			parseIniHdfs();
		}
	}
	
	public LteIniKeyInfo getLteIniInfo(String cell) {
		if (iniMap.containsKey(cell)) {
			return iniMap.get(cell);
		}
		return null;
	}
	
	private void parseIniLocal() throws IOException {
		File fileLte = new File(_iniDir + "/lte_mr.ini");
		if (fileLte.exists()) {
			BufferedReader brLte = new BufferedReader(new InputStreamReader(new FileInputStream(fileLte), _encode));
			parseIniFile(brLte);
		}
	}
	
	private void parseIniHdfs() throws IOException {
		FileSystem fs = FileSystem.get(new Configuration());
		Path pathLte = new Path(_iniDir + "/lte_mr.ini");
		if (fs.exists(pathLte)) {
			BufferedReader brLte = new BufferedReader(new InputStreamReader(fs.open(pathLte), _encode));
			parseIniFile(brLte);
		}
	}
	
	private void parseIniFile(BufferedReader br) throws IOException {
		String line = null;
		while ((line = br.readLine()) != null) {
			String[] valueItems = line.split("\\" + _splitStr, -1);
			if (valueItems.length < 17) {
				continue;
			}
			
			String cell = valueItems[1] + _splitStr + valueItems[2];
			LteIniKeyInfo iniInfo = new LteIniKeyInfo(_splitStr);
			iniInfo.setValue(valueItems);
			iniMap.put(cell, iniInfo);
		}
		br.close();
	}
}
package com.boco.wangyou.utility.ini.entity;

public class GsmIniInfo {
	private String lac = "-99999";
	private String ci = "-99999";
	private String intId = "-99999";
	private double longitude = 0;
	private double latitude = 0;
	private String name = "";
	private String _splitStr = "";
	
	public GsmIniInfo(String splitStr) {
		_splitStr = splitStr;
	}
	
	public void setValue(String[] valueItems) {
		lac = valueItems[1];
		ci = valueItems[2];
		intId = valueItems[0];
		longitude = Double.parseDouble(valueItems[6]);
		latitude = Double.parseDouble(valueItems[7]);
		name = valueItems[8];
	}
	
	public String getIntId() {
		return intId;
	}
	
	public String getCellId() {
		return lac + _splitStr + ci;
	}
	
	public double getLongitude() {
		return longitude;
	}
	
	public double getLatitude() {
		return latitude;
	}
	
	public String getName() {
		return name;
	}
}
package com.boco.wangyou.utility.ini.entity;

public class GsmNcIniInfo {
	private String _cellId = "";
	private String _intId = "-99999";
	private String _name = "";
	private String _bsicBcch = "";
	private double _distance = 0;
	
	public GsmNcIniInfo(String splitStr) {
		_cellId = splitStr;
		_bsicBcch = "-99999" + splitStr + "-99999" + splitStr + "-99999";
	}
	
	public void setValue(GsmIniInfo gsmIniInfo, String bsicBcch, double distance) {
		_cellId = gsmIniInfo.getCellId();
		_intId = gsmIniInfo.getIntId();
		_name = gsmIniInfo.getName();
		_bsicBcch = bsicBcch;
		_distance = distance;
	}
	
	public String getCellId() {
		return _cellId;
	}
	
	public String getIntId() {
		return _intId;
	}
	
	public String getName() {
		return _name;
	}
	
	public String getBsicBcch() {
		return _bsicBcch;
	}
	
	public double getDistance() {
		return _distance;
	}
}
package com.boco.wangyou.utility.ini.entity;

public class LteIniInfo {
	private String earfcn = "-99999";
	private String pci = "-99999";
	private String intId = "-99999";
	private double longitude = 0;
	private double latitude = 0;
	private String coverType = "";
	private int bearing = 0;
	private double maxPower = 0;
	private double minStaSpacing = 0;
	private String cityId = "-99999";
	private String regionId = "-99999";
	private String relatedEnodeb = "-99999";
	private String name = "";
	private String enodebName = "";
	private String _splitStr = "";
	
	public LteIniInfo(String splitStr) {
		_splitStr = splitStr;
	}
	
	public void setValue(String[] valueItems, int type) {
		if (type == 0) {
			earfcn = valueItems[3];
			pci = valueItems[4];
			intId = valueItems[0];
			longitude = nvl(valueItems[5], (double) 0);
			latitude = nvl(valueItems[6], (double) 0);
			coverType = valueItems[7];
			bearing = nvl(valueItems[8], 0);
			maxPower = nvl(valueItems[9], (double) 0);
			minStaSpacing = nvl(valueItems[10], (double) 0);
			cityId = valueItems[11];
			regionId = valueItems[12];
			relatedEnodeb = valueItems[13];
			name = valueItems[15];
			enodebName = valueItems[16];
		} else {
			earfcn = valueItems[3];
			pci = valueItems[4];
			intId = valueItems[0];
			relatedEnodeb = valueItems[13];
			name = valueItems[15];
			enodebName = valueItems[16];
		}
	}
	
	public String getEarfcn() {
		return earfcn;
	}
	
	public String getPci() {
		return pci;
	}
	
	public double getLongitude() {
		return longitude;
	}
	
	public double getLatitude() {
		return latitude;
	}
	
	public String getCoverType() {
		return coverType;
	}
	
	public int getBearing() {
		return bearing;
	}
	
	public double getMaxPower() {
		return maxPower;
	}
	
	public double getMinStaSpacing() {
		return minStaSpacing;
	}
	
	public String getIntId() {
		return intId;
	}
	
	public String getKeyLine() {
		return intId + _splitStr + relatedEnodeb + _splitStr + enodebName;
	}
	
	public String getAdjKeyLine() {
		return intId + _splitStr + relatedEnodeb + _splitStr + enodebName + _splitStr + name;
	}
	
	public String getHighKeyLine() {
		return intId + _splitStr + cityId + _splitStr + regionId;
	}
	
	public String getMcKeyLine() {
		return intId + _splitStr + relatedEnodeb + _splitStr + enodebName + _splitStr + name;
	}
	
	public String getMcHighKeyLine() {
		return intId + _splitStr + cityId + _splitStr + regionId + _splitStr + earfcn + _splitStr + pci + _splitStr + relatedEnodeb + _splitStr + enodebName + _splitStr + name;
	}
	
	public String getNcKeyLine() {
		return intId + _splitStr + name;
	}
	
	public String getNcHighKeyLine() {
		return intId + _splitStr + earfcn + _splitStr + pci + _splitStr + name;
	}
	
	public String getGridKeyLine() {
		return intId + _splitStr + cityId + _splitStr + regionId + _splitStr + earfcn + _splitStr + pci + _splitStr + relatedEnodeb + _splitStr + enodebName;
	}
	
	public String getGridNcKeyLine() {
		return intId + _splitStr + earfcn + _splitStr + pci + _splitStr + relatedEnodeb + _splitStr + enodebName + _splitStr + name;
	}
	
	private int nvl(String value, int defaultValue) {
		if ("".equals(value)) {
			return defaultValue;
		}
		return Integer.parseInt(value);
	}
	
	private double nvl(String value, double defaultValue) {
		if ("".equals(value)) {
			return defaultValue;
		}
		return Double.parseDouble(value);
	}
}
package com.boco.wangyou.utility.ini.entity;

public class LteIniKeyInfo {
	private String intId = "";
	private String cityId = "";
	private String regionId = "";
	private String enodebId = "";
	private String districtId = "";
	private String coverType = "";
	private String enodebName = "";
	private String _splitStr = "";
	
	public LteIniKeyInfo(String splitStr) {
		_splitStr = splitStr;
	}
	
	public void setValue(String[] valueItems) {
		intId = valueItems[0];
		cityId = valueItems[11];
		regionId = valueItems[12];
		enodebId = valueItems[13];
		districtId = valueItems[14];
		enodebName = valueItems[16];
		coverType = ("0".equals(valueItems[7])) ? "101" : "102";
	}
	
	public String getEutrKey() {
		return intId + _splitStr + enodebId + _splitStr + enodebName;
	}
	
	public String getEnodebKey() {
		return enodebId;
	}
	
	public String getEnodebValue() {
		return cityId + _splitStr + regionId + _splitStr + districtId + _splitStr + enodebName;
	}
	
	public String getCoverType() {
		return coverType;
	}
}
package com.boco.wangyou.utility.ini.entity;

public class LteNcIniInfo {
	private String _cellId = "";
	private double _distance = 0;
	
	public LteNcIniInfo(String splitStr) {
		_cellId = splitStr;
	}
	
	public void setValue(String cellId, double distance) {
		_cellId = cellId;
		_distance = distance;
	}
	
	public String getCellId() {
		return _cellId;
	}
	
	public double getDistance() {
		return _distance;
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel;

import java.io.IOException;

public abstract class LteMrXmlParse {
	public abstract void read() throws IOException;
}
package com.boco.wangyou.ltemr.parse.domainmodel.mre;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.boco.wangyou.ltemr.parse.domainmodel.LteMrXmlParse;
import com.boco.wangyou.ltemr.parse.domainmodel.MrParseDomain;
import com.boco.wangyou.ltemr.parse.domainmodel.XmlParseStream;
import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.MrKeyInfo;
import com.boco.wangyou.ltemr.parse.entity.SmrValue;
import com.boco.wangyou.ltemr.parse.entity.XmlCommonInfo;
import com.boco.wangyou.ltemr.parse.entity.mre.TdlMreBaseData;
import com.boco.wangyou.ltemr.parse.entity.mre.TdlMreData;
import com.boco.wangyou.utility.cfg.ConfigConstants;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;
import com.boco.wangyou.utility.ini.entity.LteIniInfo;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;
import com.boco.wangyou.utility.write.WriteData;

public class LteMreXmlParse extends LteMrXmlParse {
	private XmlParseStream _stream = null;
	private CommonInfo _commonInfo = null;
	private WriteData _writeData = null;
	private IniParseDomain _iniParse = null;
	private List<String> _variableTabs = null;
	private SmrValue _smr = new SmrValue();
	private String _splitStr = "";
	private StringBuffer _line = new StringBuffer(1000);
	
	public LteMreXmlParse(XmlParseStream stream, CommonInfo commonInfo, WriteData writeData, String iniDir, ConfigConstants cfgInfo, int type) {
		_stream = stream;
		_commonInfo = commonInfo;
		_writeData = writeData;
		
		_variableTabs = cfgInfo.getTabs("VARIABLE_MRE_TABLE_NAME");
		_writeData.setVariableTabs(_variableTabs);
		_splitStr = cfgInfo.getValue("SPLIT_STRING", "|");
		String encode = cfgInfo.getValue("CHARACTER_SET", "UTF-8");
		_iniParse = new IniParseDomain(iniDir, type, _splitStr, encode);
	}
	
	public void read() throws IOException {
		Map<String, Map<String, Map<String, TdlMreBaseData>>> baseMap = new HashMap<String, Map<String, Map<String, TdlMreBaseData>>>(10);
		
		MrIdxInfo idxInfo = new MrIdxInfo();
		MrKeyInfo keyInfo = new MrKeyInfo(_splitStr);
		XmlCommonInfo xmlCommonInfo = new XmlCommonInfo(_splitStr);
		
		MrParseDomain mreParse = new MrParseDomain();
		MreSumParseDomain sumParse = new MreSumParseDomain(_variableTabs, _writeData, _commonInfo, _iniParse, _splitStr);
		
		BufferedReader br = _stream.getStream();
		String line = null;
		String enodebBackup = null;
		String timeStampBackup = null;
		while ((line = br.readLine()) != null) {
			line = line.toLowerCase();
			if (line.contains("<fileheader")) {
				mreParse.parseFileHeader(line, xmlCommonInfo);
				continue;
			}
			
			if (line.contains("<enb")) {
				mreParse.parseEnb(line, xmlCommonInfo);
				String enodeb = xmlCommonInfo.getEnodeb();
				if (enodebBackup == null) {
					_iniParse.parseKey(enodeb);
					enodebBackup = enodeb;
				} else if (!enodeb.equals(enodebBackup)) {
					sumParse.write(_line);
					
					_iniParse.clear();
					_iniParse.parseKey(enodeb);
					enodebBackup = enodeb;
				}
				continue;
			}
			
			if (line.contains("<smr>")) {
				mreParse.parseSmr(line, idxInfo);
				mreParse.parseSmrFlag(idxInfo);
				
				int flag = idxInfo.getDataFlag();
				if (flag != 1) {
					mreParse.seekFile(br);
				}
				continue;
			}
			
			if (line.contains("<object")) {
				mreParse.parseObject(line, keyInfo, enodebBackup);
				String timeStamp = keyInfo.getTimeStamp();
				if (timeStampBackup == null) {
					timeStampBackup = timeStamp;
				} else if (!timeStampBackup.equals(timeStamp)) {
					makeSumData(baseMap, sumParse, timeStampBackup);
					timeStampBackup = timeStamp;
				}
				continue;
			}
			
			if (line.contains("<v>")) {
				int flag = idxInfo.getDataFlag();
				if (flag == 1) {
					String[] valueItems = line.toLowerCase().replaceAll("\\<\\/?v\\>", "").trim().split("\\s", -1);
					makeBaseData(valueItems, baseMap, keyInfo, idxInfo);
				}
				continue;
			}
			
			if (line.contains("</bulkpmmrdatafile>")) {
				makeSumData(baseMap, sumParse, timeStampBackup);
			}
		}
		sumParse.write(_line);
	}
	
	private void makeBaseData(String[] valueItems, Map<String, Map<String, Map<String, TdlMreBaseData>>> baseMap, MrKeyInfo keyInfo, MrIdxInfo idxInfo) {
		String cellKey = keyInfo.getCell();
		String userKey = keyInfo.getUserKey();
		String eventType = keyInfo.getEventType();
		LteIniInfo iniInfo = _iniParse.getLteIniInfo(cellKey);
		
		int len = valueItems.length;
		Map<String, Map<String, TdlMreBaseData>> userBase = null;
		Map<String, TdlMreBaseData> eventBase = null;
		TdlMreBaseData base = null;
		if (baseMap.containsKey(cellKey)) {
			userBase = baseMap.get(cellKey);
			if (userBase.containsKey(userKey)) {
				eventBase = userBase.get(userKey);
				if (eventBase.containsKey(eventType)) {
					base = eventBase.get(eventType);
					base.setNcValue(valueItems, idxInfo, len);
				} else {
					base = new TdlMreBaseData(_smr, _splitStr);
					base.setValue(valueItems, idxInfo, len, iniInfo);
				}
			} else {
				eventBase = new HashMap<String, TdlMreBaseData>(10);
				base = new TdlMreBaseData(_smr, _splitStr);
				base.setValue(valueItems, idxInfo, len, iniInfo);
			}
		} else {
			eventBase = new HashMap<String, TdlMreBaseData>(10);
			userBase = new HashMap<String, Map<String, TdlMreBaseData>>(100);
			base = new TdlMreBaseData(_smr, _splitStr);
			base.setValue(valueItems, idxInfo, len, iniInfo);
		}
		eventBase.put(eventType, base);
		userBase.put(userKey, eventBase);
		baseMap.put(cellKey, userBase);
	}
	
	private void makeSumData(Map<String, Map<String, Map<String, TdlMreBaseData>>> baseMap, MreSumParseDomain sumParse, String timeStamp) {
		for (Map.Entry<String, Map<String, Map<String, TdlMreBaseData>>> entry : baseMap.entrySet()) {
			String cellKey = entry.getKey();
			TdlMreData tdlData = sumParse.getData(cellKey);
			
			for (Map.Entry<String, Map<String, TdlMreBaseData>> entryUser : entry.getValue().entrySet()) {
				String userKey = entryUser.getKey();
				
				for (Map.Entry<String, TdlMreBaseData> entryEvent : entryUser.getValue().entrySet()) {
					String eventType = entryEvent.getKey();
					TdlMreBaseData base = entryEvent.getValue();
					List<LteNcIniInfo> ncCellList = base.getNcCells(cellKey, _iniParse);
					List<GsmNcIniInfo> ncGsmCellList = base.getNcGsmCells(cellKey, _iniParse);
					sumParse.sum(base, ncCellList, ncGsmCellList, userKey, eventType, timeStamp, tdlData);
				}
			}
			sumParse.addData(cellKey, tdlData);
		}
		baseMap.clear();
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel.mre;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.ltemr.parse.entity.mre.TdlMreBaseData;
import com.boco.wangyou.ltemr.parse.entity.mre.TdlMreData;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;
import com.boco.wangyou.utility.write.WriteData;

public class MreSumParseDomain {
	private List<String> _variableTabs = null;
	private WriteData _writeData = null;
	private CommonInfo _commonInfo = null;
	private IniParseDomain _iniParse = null;
	private String _splitStr = "";
	private Map<String, TdlMreData> mapTdlData = new HashMap<String, TdlMreData>(20);
	
	public MreSumParseDomain(List<String> variableTabs, WriteData writeData, CommonInfo commonInfo, IniParseDomain iniParse, String splitStr) {
		_variableTabs = variableTabs;
		_writeData = writeData;
		_commonInfo = commonInfo;
		_iniParse = iniParse;
		_splitStr = splitStr;
	}
	
	public TdlMreData getData(String cellKey) {
		if (mapTdlData.containsKey(cellKey)) {
			return mapTdlData.get(cellKey);
		}
		return new TdlMreData(_variableTabs, _splitStr);
	}
	
	public void sum(TdlMreBaseData base, List<LteNcIniInfo> ncCellList, List<GsmNcIniInfo> ncGsmCellList, String userKey, String eventType, String timeStamp, TdlMreData tdlData) {
		makeEutrInfo(ncCellList.size(), ncGsmCellList.size(), userKey, eventType, timeStamp, tdlData);
		
		int idx = 0;
		for (LteNcIniInfo ncKey : ncCellList) {
			makeAdjInfo(ncKey, base, eventType, idx, tdlData);
			makeAdjUserInfo(ncKey, userKey, eventType, tdlData);
			idx++;
		}
		
		idx = 0;
		for (GsmNcIniInfo ncGsmKey : ncGsmCellList) {
			makeGsmAdjInfo(ncGsmKey, base, eventType, idx, tdlData);
			makeGsmAdjUserInfo(ncGsmKey, userKey, eventType, tdlData);
			idx++;
		}
	}
	
	public void addData(String cellKey, TdlMreData tdlData) {
		mapTdlData.put(cellKey, tdlData);
	}
	
	public void write(StringBuffer line) {
		WriteTdlMreSumDomain write = new WriteTdlMreSumDomain(_variableTabs, _writeData, _commonInfo, _iniParse, _splitStr, line);
		write.writeData(mapTdlData);
	}
	
	
	private void makeEutrInfo(int ncNum, int gsmNcNum, String userKey, String eventType, String timeStamp, TdlMreData tdlData) {
		tdlData.makeEutrInfo(ncNum, gsmNcNum, userKey, eventType, timeStamp);
	}
	
	private void makeAdjInfo(LteNcIniInfo ncKey, TdlMreBaseData base, String eventType, int idx, TdlMreData tdlData) {
		if (!_variableTabs.contains("tdl_mre_diff") && !_variableTabs.contains("tdl_mre_adjtdl")) {
			return;
		}
		tdlData.makeAdjInfo(ncKey, base, eventType, idx);
	}
	
	private void makeAdjUserInfo(LteNcIniInfo ncKey, String userKey, String eventType, TdlMreData tdlData) {
		if (!_variableTabs.contains("tdl_mre_usernum")) {
			return;
		}
		tdlData.makeAdjUserInfo(ncKey, userKey, eventType);
	}
	
	private void makeGsmAdjInfo(GsmNcIniInfo ncGsmKey, TdlMreBaseData base, String eventType, int idx, TdlMreData tdlData) {
		if (!_variableTabs.contains("tdl_mre_rsrprssi") && !_variableTabs.contains("tdl_mre_adjtdl_gsm")) {
			return;
		}
		tdlData.makeGsmAdjInfo(ncGsmKey, base, eventType, idx);
	}
	
	private void makeGsmAdjUserInfo(GsmNcIniInfo ncGsmKey, String userKey, String eventType, TdlMreData tdlData) {
		if (!_variableTabs.contains("tdl_mre_gsm_usernum")) {
			return;
		}
		tdlData.makeGsmAdjUserInfo(ncGsmKey, userKey, eventType);
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel.mre;

import java.util.List;
import java.util.Map;

import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.ltemr.parse.entity.mre.TdlMreData;
import com.boco.wangyou.ltemr.parse.entity.mre.sum.TdlMreAdj;
import com.boco.wangyou.ltemr.parse.entity.mre.sum.TdlMreAdjUser;
import com.boco.wangyou.ltemr.parse.entity.mre.sum.TdlMreEutr;
import com.boco.wangyou.ltemr.parse.entity.mre.sum.TdlMreGsmAdj;
import com.boco.wangyou.ltemr.parse.entity.mre.sum.TdlMreGsmAdjUser;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.write.WriteData;

public class WriteTdlMreSumDomain {
	private List<String> _variableTabs = null;
	private WriteData _writeData = null;
	private CommonInfo _commonInfo = null;
	private IniParseDomain _iniParse = null;
	private String _startTime = "";
	private String _splitStr = "";
	private StringBuffer _line = null;
	
	public WriteTdlMreSumDomain(List<String> variableTabs, WriteData writeData, CommonInfo commonInfo, IniParseDomain iniParse, String splitStr, StringBuffer line) {
		_variableTabs = variableTabs;
		_writeData = writeData;
		_commonInfo = commonInfo;
		_iniParse = iniParse;
		_splitStr = splitStr;
		_line = line;
		_startTime = _commonInfo.getStartTime();
	}
	
	public void writeData(Map<String, TdlMreData> mapTdlData) {
		for (Map.Entry<String, TdlMreData> entry : mapTdlData.entrySet()) {
			String cellKey = entry.getKey();
			TdlMreData tdlData = entry.getValue();
			
			TdlMreEutr tdlMreEutr = tdlData.getEutr();
			writeEutr(cellKey, tdlMreEutr);
			writeAdj(cellKey, tdlData.getAdj(), tdlMreEutr);
			writeGsmAdj(cellKey, tdlData.getGsmAdj());
			writeAdjUser(cellKey, tdlData.getAdjUser(), tdlMreEutr);
			writeGsmAdjUser(cellKey, tdlData.getGsmAdjUser(), tdlMreEutr);
		}
		mapTdlData.clear();
	}
	
	private void writeEutr(String cellKey, TdlMreEutr tdlMreEutr) {
		String commonLine = _commonInfo.getLine() + _splitStr + _iniParse.getLteIniInfo(cellKey).getMcKeyLine() + _splitStr + cellKey;
		_writeData.writeLine(commonLine + _splitStr + tdlMreEutr.getLine(_line), "tdl_mre_repeated_measure", _startTime);
	}
	
	private void writeAdj(String cellKey, Map<String, Map<String, TdlMreAdj>> mapAdj, TdlMreEutr tdlMreEutr) {
		String mcLine = _iniParse.getLteIniInfo(cellKey).getMcKeyLine() + _splitStr + cellKey;
		for (Map.Entry<String, Map<String, TdlMreAdj>> entry : mapAdj.entrySet()) {
			String ncCellKey = entry.getKey();
			if ("".equals(ncCellKey)) {
				ncCellKey = _splitStr;
			}
			String ncLine = _iniParse.getLteIniInfo(ncCellKey).getNcKeyLine() + _splitStr + ncCellKey;
			
			for (Map.Entry<String, TdlMreAdj> entryEvent : entry.getValue().entrySet()) {
				String eventType = entryEvent.getKey();
				TdlMreAdj tdlMreAdj = entryEvent.getValue();
				String commonLine = _commonInfo.getLine() + _splitStr + mcLine + _splitStr + ncLine + _splitStr + eventType;
				
				int totalNum = (tdlMreEutr == null) ? 0 : tdlMreEutr.getTotalNum();
				int ncScOverF6 = tdlMreAdj.getNcScOverF6();
				_writeData.writeLine(commonLine + _splitStr + tdlMreAdj.getDiffLine(_line), "tdl_mre_diff", _startTime);
				_writeData.writeLine(commonLine + _splitStr + tdlMreAdj.getAdjTdlLine(_line) + _splitStr + totalNum + div(ncScOverF6, totalNum), "tdl_mre_adjtdl", _startTime);
			}
		}
		mapAdj.clear();
	}
	
	private void writeGsmAdj(String cellKey, Map<String, Map<String, TdlMreGsmAdj>> mapGsmAdj) {
		String mcLine = _iniParse.getLteIniInfo(cellKey).getMcKeyLine() + _splitStr + cellKey;
		for (Map.Entry<String, Map<String, TdlMreGsmAdj>> entry : mapGsmAdj.entrySet()) {
			String ncCellKey = entry.getKey();
			if ("".equals(ncCellKey)) {
				ncCellKey = _splitStr;
			}
			String ncLine = _iniParse.getGsmIniInfo(ncCellKey).getKeyLine() + _splitStr + ncCellKey;
			
			for (Map.Entry<String, TdlMreGsmAdj> entryEvent : entry.getValue().entrySet()) {
				String eventType = entryEvent.getKey();
				TdlMreGsmAdj tdlGsmMreAdj = entryEvent.getValue();
				String commonLine = _commonInfo.getLine() + _splitStr + mcLine + _splitStr + ncLine + _splitStr + eventType;
				
				_writeData.writeLine(commonLine + _splitStr + tdlGsmMreAdj.getRsrpRssiLine(_line), "tdl_mre_rsrprssi", _startTime);
				_writeData.writeLine(commonLine + _splitStr + tdlGsmMreAdj.getAdjtdlGsmLine(_line), "tdl_mre_adjtdl_gsm", _startTime);
			}
		}
		mapGsmAdj.clear();
	}
	
	private void writeAdjUser(String cellKey, Map<String, TdlMreAdjUser> mapAdjUser, TdlMreEutr tdlMreEutr) {
		if (!_variableTabs.contains("tdl_mre_usernum")) {
			mapAdjUser.clear();
			return;
		}
		
		String mcLine = _iniParse.getLteIniInfo(cellKey).getMcKeyLine() + _splitStr + cellKey;
		for (Map.Entry<String, TdlMreAdjUser> entry : mapAdjUser.entrySet()) {
			String ncCellKey = entry.getKey();
			TdlMreAdjUser tdlMreAdjUser = entry.getValue();
			if ("".equals(ncCellKey)) {
				ncCellKey = _splitStr;
			}
			String ncLine = _iniParse.getLteIniInfo(ncCellKey).getNcKeyLine() + _splitStr + ncCellKey;
			String commonLine = _commonInfo.getLine() + _splitStr + mcLine + _splitStr + ncLine;
			
			int totalNum = (tdlMreEutr == null) ? 0 : tdlMreEutr.getTotalNum();
			_writeData.writeLine(commonLine + _splitStr + tdlMreAdjUser.getLine(_line) + _splitStr + totalNum, "tdl_mre_usernum", _startTime);
		}
		mapAdjUser.clear();
	}
	
	private void writeGsmAdjUser(String cellKey, Map<String, TdlMreGsmAdjUser> mapGsmAdjUser, TdlMreEutr tdlMreEutr) {
		if (!_variableTabs.contains("tdl_mre_gsm_usernum")) {
			mapGsmAdjUser.clear();
			return;
		}
		
		String mcLine = _iniParse.getLteIniInfo(cellKey).getMcKeyLine() + _splitStr + cellKey;
		for (Map.Entry<String, TdlMreGsmAdjUser> entry : mapGsmAdjUser.entrySet()) {
			String ncCellKey = entry.getKey();
			TdlMreGsmAdjUser tdlMreGsmAdjUser = entry.getValue();
			if ("".equals(ncCellKey)) {
				ncCellKey = _splitStr;
			}
			String ncLine = _iniParse.getGsmIniInfo(ncCellKey).getKeyLine() + _splitStr + ncCellKey;
			String commonLine = _commonInfo.getLine() + _splitStr + mcLine + _splitStr + ncLine;
			
			int totalNum = (tdlMreEutr == null) ? 0 : tdlMreEutr.getTotalNum();
			_writeData.writeLine(commonLine + _splitStr + tdlMreGsmAdjUser.getLine(_line) + _splitStr + totalNum, "tdl_mre_gsm_usernum", _startTime);
		}
		mapGsmAdjUser.clear();
	}
	
	private double div(int numerator, int denominator) {
		if (denominator == 0) {
			return 0;
		}
		return (double) numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel.mro;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.boco.wangyou.algorithm.counter.FreqParse;
import com.boco.wangyou.algorithm.depthcoverage.fingerprint.FingerPrintParse;
import com.boco.wangyou.ltemr.parse.domainmodel.LteMrXmlParse;
import com.boco.wangyou.ltemr.parse.domainmodel.MrParseDomain;
import com.boco.wangyou.ltemr.parse.domainmodel.XmlParseStream;
import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.MrKeyInfo;
import com.boco.wangyou.ltemr.parse.entity.SmrValue;
import com.boco.wangyou.ltemr.parse.entity.XmlCommonInfo;
import com.boco.wangyou.ltemr.parse.entity.mro.MroGridInfo;
import com.boco.wangyou.ltemr.parse.entity.mro.TdlMroData;
import com.boco.wangyou.ltemr.parse.entity.mro.TdlMroGridUe;
import com.boco.wangyou.utility.cfg.ConfigConstants;
import com.boco.wangyou.utility.grid.GridInfo;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;
import com.boco.wangyou.utility.ini.entity.LteIniInfo;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;
import com.boco.wangyou.utility.write.WriteData;

public class LteMroXmlParse extends LteMrXmlParse {
	private XmlParseStream _stream = null;
	private CommonInfo _commonInfo = null;
	private WriteData _writeData = null;
	private IniParseDomain _iniParse = null;
	private List<Integer> _gridUeHours = null;
	private List<String> _variableTabs = null;
	private List<Integer> _gridSums = null;
	private ConfigConstants _cfgInfo = null;
	private SmrValue _smr = new SmrValue();
	private FreqParse _freqParse = new FreqParse();
	private String _splitStr = "";
	private StringBuffer _line = new StringBuffer(1000);
	private String _fingerPrintPath = "";
	private FingerPrintParse _fingerPrintParse = null;
	
	public LteMroXmlParse(XmlParseStream stream, CommonInfo commonInfo, WriteData writeData, String iniDir, ConfigConstants cfgInfo, int type) {
		_stream = stream;
		_commonInfo = commonInfo;
		_writeData = writeData;
		_cfgInfo = cfgInfo;
		
		_gridUeHours = cfgInfo.getInts("GRIDUE_HOURS");
		_variableTabs = cfgInfo.getTabs("VARIABLE_MRO_TABLE_NAME");
		_gridSums = cfgInfo.getInts("GRID_LENGTH_SUM_LIST");
		_writeData.setVariableTabs(_variableTabs);
		_splitStr = cfgInfo.getValue("SPLIT_STRING", "|");
		String encode = cfgInfo.getValue("CHARACTER_SET", "UTF-8");
		double maxDis = Double.parseDouble(cfgInfo.getValue("MAX_DISTANCE", "10000"));
		_iniParse = new IniParseDomain(iniDir, type, _splitStr, encode, maxDis);
		_fingerPrintPath = cfgInfo.getValue("FRINGER_PRINT_PATH", "");
		if (!"".equals(_fingerPrintPath)) {
			_fingerPrintParse = new FingerPrintParse(_splitStr);
		}
	}
	
	public void read() throws IOException {
		Map<String, Map<String, TdlMroGridUe>> gridUeMap = new HashMap<String, Map<String, TdlMroGridUe>>(20);
		Map<String, Integer> userTypeMap = new HashMap<String, Integer>(10000);
		Map<String, GridInfo> gridInfoMap = new HashMap<String, GridInfo>(10000);
		
		MrIdxInfo idxInfo = new MrIdxInfo();
		MrKeyInfo keyInfo = new MrKeyInfo(_splitStr);
		XmlCommonInfo xmlCommonInfo = new XmlCommonInfo(_splitStr);
		
		_iniParse.parseAll();
		Map<String, LteNcIniInfo> iniInfoMap = new HashMap<String, LteNcIniInfo>(10000);
		Map<String, GsmNcIniInfo> gsmIniInfoMap = new HashMap<String, GsmNcIniInfo>(10000);
		
		int rsrpWeak = Integer.parseInt(_cfgInfo.getValue("RSRP_WEAK", "-110")) + 140;
		MrParseDomain mroParse = new MrParseDomain();
		MroUserParseDomain userParse = new MroUserParseDomain(_stream.getUserStream());
		MroSumParseDomain sumParse = new MroSumParseDomain(_variableTabs, _writeData, _commonInfo, _iniParse, _splitStr, rsrpWeak);
		
		BufferedReader br = _stream.getStream();
		String line = null;
		String enodebBackup = null;
		String timeStampBackup = null;
		while ((line = br.readLine()) != null) {
			line = line.toLowerCase();
			if (line.contains("<fileheader")) {
				mroParse.parseFileHeader(line, xmlCommonInfo);
				continue;
			}
			
			if (line.contains("<enb")) {
				mroParse.parseEnb(line, xmlCommonInfo);
				String enodeb = xmlCommonInfo.getEnodeb();
				if (enodebBackup == null) {
					enodebBackup = enodeb;
					
					if (_fingerPrintParse != null) {
						_fingerPrintParse.readGridFile(_fingerPrintPath, enodeb);
					}
				} else if (!enodeb.equals(enodebBackup)) {
					sumParse.write(_line, gridInfoMap);
					enodebBackup = enodeb;
					
					if (_fingerPrintParse != null) {
						_fingerPrintParse.readGridFile(_fingerPrintPath, enodeb);
					}
					
					gridInfoMap.clear();
					iniInfoMap.clear();
					gsmIniInfoMap.clear();
				}
				
				userParse.parse(userTypeMap, mroParse, enodeb, _iniParse, _splitStr);
				continue;
			}
			
			if (line.contains("<smr>")) {
				mroParse.parseSmr(line, idxInfo);
				mroParse.parseSmrFlag(idxInfo);
				
				int flag = idxInfo.getDataFlag();
				if (flag == 2) {
					mroParse.seekFile(br);
				}
				continue;
			}
			
			if (line.contains("<object")) {
				mroParse.parseObject(line, keyInfo, enodebBackup);
				String timeStamp = keyInfo.getTimeStamp();
				if (timeStampBackup == null) {
					timeStampBackup = timeStamp;
				} else if (!timeStampBackup.equals(timeStamp)) {
					writeGridUeData(gridUeMap, userTypeMap, sumParse, xmlCommonInfo, timeStampBackup, gridInfoMap, iniInfoMap, gsmIniInfoMap);
					timeStampBackup = timeStamp;
				}
				continue;
			}
			
			if (line.contains("<v>")) {
				int flag = idxInfo.getDataFlag();
				if (flag == 1) {
					String[] valueItems = line.toLowerCase().replaceAll("\\<\\/?v\\>", "").trim().split("\\s", -1);
					makeGridUeData(valueItems, gridUeMap, keyInfo, idxInfo);
				} else if (flag == 3) {
					String cellKey = keyInfo.getCell();
					String[] valueItems = line.toLowerCase().replaceAll("\\<\\/?v\\>", "").trim().split("\\s");
					TdlMroData tdlData = sumParse.getData(cellKey);
					sumParse.sumRip(valueItems, idxInfo, tdlData);
					sumParse.addData(cellKey, tdlData);
				}
				continue;
			}
			
			if (line.contains("</bulkpmmrdatafile>")) {
				writeGridUeData(gridUeMap, userTypeMap, sumParse, xmlCommonInfo, timeStampBackup, gridInfoMap, iniInfoMap, gsmIniInfoMap);
			}
		}
		sumParse.write(_line, gridInfoMap);
	}
	
	private void makeGridUeData(String[] valueItems, Map<String, Map<String, TdlMroGridUe>> gridUeMap, MrKeyInfo keyInfo, MrIdxInfo idxInfo) {
		String cellKey = keyInfo.getCell();
		String userKey = keyInfo.getUserKey();
		LteIniInfo iniInfo = _iniParse.getLteIniInfo(cellKey);
		
		int len = valueItems.length;
		Map<String, TdlMroGridUe> userGridUe = null;
		TdlMroGridUe gridUe = null;
		if (gridUeMap.containsKey(cellKey)) {
			userGridUe = gridUeMap.get(cellKey);
			if (userGridUe.containsKey(userKey)) {
				gridUe = userGridUe.get(userKey);
				gridUe.setNcValue(valueItems, idxInfo, len);
			} else {
				gridUe = new TdlMroGridUe(_smr, _freqParse, _splitStr);
				gridUe.setValue(valueItems, idxInfo, len, iniInfo);
			}
		} else {
			userGridUe = new HashMap<String, TdlMroGridUe>(100);
			gridUe = new TdlMroGridUe(_smr, _freqParse, _splitStr);
			gridUe.setValue(valueItems, idxInfo, len, iniInfo);
		}
		userGridUe.put(userKey, gridUe);
		gridUeMap.put(cellKey, userGridUe);
	}
	
	private void writeGridUeData(Map<String, Map<String, TdlMroGridUe>> gridUeMap, Map<String, Integer> userTypeMap, MroSumParseDomain sumParse, XmlCommonInfo xmlCommonInfo, String timeStamp, Map<String, GridInfo> gridInfoMap, Map<String, LteNcIniInfo> iniInfoMap, Map<String, GsmNcIniInfo> gsmIniInfoMap) {
		String commonLine = _commonInfo.getIdLine() + _splitStr + xmlCommonInfo.getAllLine();
		String startTime = xmlCommonInfo.getStartTimeStr();
		
		for (Map.Entry<String, Map<String, TdlMroGridUe>> entry : gridUeMap.entrySet()) {
			String cellKey = entry.getKey();
			Map<String, TdlMroGridUe> userGridUe = entry.getValue();
			String intId = _iniParse.getLteIniInfo(cellKey).getIntId();
			TdlMroData tdlData = sumParse.getData(cellKey);
			
			for (Map.Entry<String, TdlMroGridUe> entryUser : userGridUe.entrySet()) {
				String userKey = entryUser.getKey();
				TdlMroGridUe gridUe = entryUser.getValue();
				
				MroGridInfo gridInfo = new MroGridInfo(_cfgInfo, _commonInfo.getVendorId(), _splitStr);
				if (userTypeMap.containsKey(userKey)) {
					gridInfo.setUserType(userTypeMap.get(userKey));
				} else {
					gridInfo.setUserType(3);
				}
				gridInfo.makeGrid(gridUe, cellKey, _iniParse, _fingerPrintParse, gridInfoMap, iniInfoMap, gsmIniInfoMap);
				if (_gridUeHours.contains(xmlCommonInfo.getStartTimeHour()) && !"".equals(gridInfo.getGridId())) {
					String line = UUID.randomUUID().toString() + _splitStr + gridInfo.getGridLine(_line) + _splitStr + commonLine + _splitStr
							+ userKey + _splitStr + timeStamp + _splitStr + cellKey + _splitStr + intId + _splitStr + gridUe.getLine1(_line) + _splitStr
							+ "-9999" + _splitStr + "-9999" + _splitStr + "-9999" + _splitStr + "-9999" + _splitStr + "-9999" + _splitStr
							+ gridInfo.getLatLon() + _splitStr + "-9999" + _splitStr + "-9999" + _splitStr + "-9999" + _splitStr + "-9999" + _splitStr + "-9999" + _splitStr
							+ gridUe.getLine2(_line) + _splitStr + gridInfo.getUserInfo() + _splitStr + gridUe.getLine3(_line);
					_writeData.writeBaseLine(line, "tdl_mro_grid_ue", startTime);
				}
				sumParse.sum(gridUe, gridInfo, tdlData, _gridSums);
			}
			sumParse.addData(cellKey, tdlData);
		}
		gridUeMap.clear();
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel.mro;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.mro.MroGridInfo;
import com.boco.wangyou.ltemr.parse.entity.mro.TdlMroData;
import com.boco.wangyou.ltemr.parse.entity.mro.TdlMroGridUe;
import com.boco.wangyou.utility.grid.GridInfo;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;
import com.boco.wangyou.utility.write.WriteData;

public class MroSumParseDomain {
	private List<String> _variableTabs = null;
	private WriteData _writeData = null;
	private CommonInfo _commonInfo = null;
	private IniParseDomain _iniParse = null;
	private String _splitStr = "";
	private int _rsrpWeak = 0;
	private Map<String, TdlMroData> mapTdlData = new HashMap<String, TdlMroData>(20);
	
	public MroSumParseDomain(List<String> variableTabs, WriteData writeData, CommonInfo commonInfo, IniParseDomain iniParse, String splitStr, int rsrpWeak) {
		_variableTabs = variableTabs;
		_writeData = writeData;
		_commonInfo = commonInfo;
		_iniParse = iniParse;
		_splitStr = splitStr;
		_rsrpWeak = rsrpWeak;
	}
	
	public TdlMroData getData(String cellKey) {
		if (mapTdlData.containsKey(cellKey)) {
			return mapTdlData.get(cellKey);
		}
		return new TdlMroData(_variableTabs, _splitStr);
	}
	
	public void sum(TdlMroGridUe gridUe, MroGridInfo gridInfo, TdlMroData tdlData, List<Integer> gridSums) {
		makeEutrInfo(gridUe, tdlData);
		makeGridInfo(gridUe, gridInfo, tdlData);
		makeGridUserInfo(gridUe, gridInfo, tdlData, 50);
		for (int size : gridSums) {
			if (size == 50) {
				continue;
			}
			makeGridUserInfo(gridUe, gridInfo, tdlData, size);
		}
		
		List<LteNcIniInfo> ncCellList = gridInfo.getNcCells();
		int idx = 0;
		for (LteNcIniInfo ncIniInfo : ncCellList) {
			makeAdjInfo(ncIniInfo, gridUe, gridInfo, idx, tdlData);
			makeGridAdjInfo(ncIniInfo.getCellId(), gridUe, gridInfo, idx, tdlData, 50);
			for (int size : gridSums) {
				if (size == 50) {
					continue;
				}
				makeGridAdjInfo(ncIniInfo.getCellId(), gridUe, gridInfo, idx, tdlData, size);
			}
			idx++;
		}
		
		List<GsmNcIniInfo> ncGsmList = gridInfo.getGsmList();
		idx = 0;
		for (GsmNcIniInfo ncGsmKey : ncGsmList) {
			makeGsmAdjInfo(ncGsmKey, gridUe, idx, tdlData);
			idx++;
		}
	}
	
	public void sumRip(String[] valueItems, MrIdxInfo idxInfo, TdlMroData tdlData) {
		if (!_variableTabs.contains("tdl_mro_rip")) {
			return;
		}
		
		if (valueItems.length != idxInfo.getLen()) {
			return;
		}
		
		int idx = idxInfo.getIdx("ltescrip");
		if (idx == -1 || idx >= valueItems.length || "nil".equals(valueItems[idx])) {
			return;
		}
		
		int rip = Integer.parseInt(valueItems[idx]);
		tdlData.makeRipInfo(rip);
	}
	
	public void addData(String cellKey, TdlMroData tdlData) {
		mapTdlData.put(cellKey, tdlData);
	}
	
	public void write(StringBuffer line, Map<String, GridInfo> gridInfoMap) {
		WriteTdlMroSumDomain write = new WriteTdlMroSumDomain(_variableTabs, _writeData, _commonInfo, _iniParse, _splitStr, line);
		write.writeData(mapTdlData, gridInfoMap);
	}
	
	private void makeEutrInfo(TdlMroGridUe gridUe, TdlMroData tdlData) {
		if (!judgeEutrTabs()) {
			return;
		}
		tdlData.makeEutrInfo(gridUe);
	}
	
	private void makeGridInfo(TdlMroGridUe gridUe, MroGridInfo gridInfo, TdlMroData tdlData) {
		if (!_variableTabs.contains("tdl_mro_mgrs_numofadj_eutr") || "".equals(gridInfo.getGridId())) {
			return;
		}
		tdlData.makeGridInfo(gridUe, gridInfo);
	}
	
	private void makeGridUserInfo(TdlMroGridUe gridUe, MroGridInfo gridInfo, TdlMroData tdlData, int size) {
		if (!judgeGridUserTabs() || "".equals(gridInfo.getGridId())) {
			return;
		}
		tdlData.makeGridUserInfo(gridUe, gridInfo, _rsrpWeak, size);
	}
	
	private void makeAdjInfo(LteNcIniInfo ncIniInfo, TdlMroGridUe gridUe, MroGridInfo gridInfo, int idx, TdlMroData tdlData) {
		if (!judgeAdjTabs()) {
			return;
		}
		tdlData.makeAdjInfo(ncIniInfo, gridUe, gridInfo, idx, _rsrpWeak);
	}
	
	private void makeGridAdjInfo(String ncCellKey, TdlMroGridUe gridUe, MroGridInfo gridInfo, int idx, TdlMroData tdlData, int size) {
		if (!_variableTabs.contains("tdl_mro_mgrs_user_maxrsrp") || "".equals(gridInfo.getGridId())) {
			return;
		}
		tdlData.makeGridAdjInfo(ncCellKey, gridUe, gridInfo, idx, _rsrpWeak, size);
	}
	
	private void makeGsmAdjInfo(GsmNcIniInfo ncGsmKey, TdlMroGridUe gridUe, int idx, TdlMroData tdlData) {
		if (!judgeGsmAdjTabs()) {
			return;
		}
		tdlData.makeGsmAdjInfo(ncGsmKey, gridUe, idx);
	}
	
	private boolean judgeEutrTabs() {
		if (_variableTabs.contains("tdl_mro_maxrsrp_eutr") || _variableTabs.contains("tdl_mro_rsrpdiff_eutr") || _variableTabs.contains("tdl_mro_overlap")
				|| _variableTabs.contains("tdl_mro_numofadj_eutr") || _variableTabs.contains("tdl_mro_numofadj_freq") || _variableTabs.contains("tdl_mro_numofadj_freqband")
				|| _variableTabs.contains("tdl_mro_rsrp") || _variableTabs.contains("tdl_mro_sinrul") || _variableTabs.contains("tdl_mro_aoa")) {
			return true;
		}
		return false;
	}
	
	private boolean judgeGridUserTabs() {
		if (_variableTabs.contains("tdl_mro_mgrs_user_rsrp") || _variableTabs.contains("tdl_mro_mgrs_user_rsrq") || _variableTabs.contains("tdl_mro_mgrs_user_sinrul")
				|| _variableTabs.contains("tdl_mro_mgrs_user_phr") || _variableTabs.contains("tdl_mro_mgrs_user_sinrdl")) {
			return true;
		}
		return false;
	}
	
	private boolean judgeAdjTabs() {
		if (_variableTabs.contains("tdl_mro_diff") || _variableTabs.contains("tdl_mro_diff_freq") || _variableTabs.contains("tdl_mro_diff_freqband")
				|| _variableTabs.contains("tdl_mro_adjtdl") || _variableTabs.contains("tdl_mro_adjtdl_freq") || _variableTabs.contains("tdl_mro_adjtdl_freqband")
				|| _variableTabs.contains("tdl_mro_pol_adj")) {
			return true;
		}
		return false;
	}
	
	private boolean judgeGsmAdjTabs() {
		if (_variableTabs.contains("tdl_mro_rsrprssi") || _variableTabs.contains("tdl_mro_adjtdl_gsm")) {
			return true;
		}
		return false;
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel.mro;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import com.boco.wangyou.ltemr.parse.domainmodel.MrParseDomain;
import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.MrKeyInfo;
import com.boco.wangyou.ltemr.parse.entity.mro.user.MroUserInfo;
import com.boco.wangyou.ltemr.parse.entity.mro.user.MroUserTypeInfo;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.LteIniInfo;

public class MroUserParseDomain {
	private BufferedReader _brUser = null;
	
	public MroUserParseDomain(BufferedReader brUser) {
		_brUser = brUser;
	}
	
	public void parse(Map<String, Integer> userTypeMap, MrParseDomain mroParse, String enodeb, IniParseDomain iniParse, String splitStr) throws IOException {
		userTypeMap.clear();
		
		Map<String, MroUserTypeInfo> mapUser = new HashMap<String, MroUserTypeInfo>();
		MrIdxInfo idxInfo = new MrIdxInfo();
		MrKeyInfo keyInfo = new MrKeyInfo(splitStr);
		
		int dataFlag = 0;
		MroUserInfo userData = new MroUserInfo();
		String line = null;
		String timeStampBack = "";
		while ((line = _brUser.readLine()) != null) {
			line = line.toLowerCase();
			if (line.contains("<smr>")) {
				mroParse.parseSmr(line, idxInfo);
				continue;
			}
			
			if (line.contains("<object")) {
				String userKey = keyInfo.getUserKey();
				String cellKey = keyInfo.getCell();
				String timeStamp = keyInfo.getTimeStamp();
				if (!"".equals(timeStampBack)) {
					makeUser(mapUser, userKey, cellKey, userData, iniParse);
				}
				
				mroParse.parseObject(line, keyInfo, enodeb);
				timeStampBack = timeStamp;
				
				userData.clear();
				dataFlag = 0;
				continue;
			}
			
			if (line.contains("<v>")) {
				String[] valueItems = line.toLowerCase().replaceAll("\\<\\/?v\\>", "").trim().split("\\s", -1);
				if (dataFlag == 0) {
					userData.setValue(valueItems, idxInfo, timeStampBack);
				} else {
					userData.setNcValue(valueItems, idxInfo);
				}
				
				dataFlag = 1;
				continue;
			}
			
			if (line.contains("</measurement>")) {
				String userKey = keyInfo.getUserKey();
				String cellKey = keyInfo.getCell();
				makeUser(mapUser, userKey, cellKey, userData, iniParse);
				
				makeUserType(userTypeMap, mapUser);
				mroParse.seekFileToEnd(_brUser);
				break;
			}
		}
	}
	
	private void makeUser(Map<String, MroUserTypeInfo> mapUser, String userKey, String cellKey, MroUserInfo userData, IniParseDomain iniParse) {
		MroUserTypeInfo userType = null;
		if (mapUser.containsKey(userKey)) {
			userType = mapUser.get(userKey);
		} else {
			userType = new MroUserTypeInfo();
		}
		LteIniInfo iniInfo = iniParse.getLteIniInfo(cellKey);
		String coverType = iniInfo.getCoverType();
		userType.setValue(userData, coverType);
		mapUser.put(userKey, userType);
	}
	
	private void makeUserType(Map<String, Integer> userTypeMap, Map<String, MroUserTypeInfo> mapUser) {
		for (Map.Entry<String, MroUserTypeInfo> entry : mapUser.entrySet()) {
			String userKey = entry.getKey();
			MroUserTypeInfo userType = entry.getValue();
			
			long diffTime = userType.getTimeDiff();
			if (diffTime < 15) {
				userTypeMap.put(userKey, 3);
				continue;
			}
			
			int value = 0;
			int adjNum = (int) userType.getAdjNum();
			int ta = (int) userType.getTa();
			int taDiff = (int) userType.getTaDiff();
			int rsrp = (int) userType.getRsrp();
			int rsrpDiff = (int) userType.getRsrpDiff();
			int phr = (int) userType.getPhr();
			int rsrpMax = (int) userType.getMaxRsrp();
			int changeNum = userType.getChangeNum();
			if ("1".equals(userType.getCoverType())) {
				if (adjNum <= 2) {
					value -= 2;
				}
				if (ta != -1 && ta < 2) {
					value -= 2;
				}
				if (taDiff != -1 && taDiff < 1) {
					value -= 2;
				}
				if (rsrp != -1 && rsrp - 141 > -75) {
					value -= 2;
				}
				if (rsrpDiff != -1 && rsrpDiff < 6) {
					value -= 1;
				}
				if (phr != -1 && phr -23 > 6) {
					value -= 1;
				}
				if (rsrp != -1 && rsrpMax != -1 && rsrp - rsrpMax > 12) {
					value -= 1;
				}
				if (changeNum == 0) {
					value -= 1;
				}
			} else {
				if (adjNum >= 5) {
					value += 2;
				} else if (adjNum >= 3) {
					value += 1;
				}
				if (ta != -1 && ta > 4) {
					value += 1;
				}
				if (taDiff != -1) {
					if (taDiff > 1) {
						value += 1;
					} else if (taDiff > 3) {
						value += 2;
					}
				}
				if (rsrp != -1 && rsrp - 141 > -85) {
					value += 1;
				}
				if (rsrpDiff != -1 && rsrpDiff > 6) {
					value += 1;
				}
				if (phr != -1 && phr - 23 < 6) {
					value += 1;
				}
				if (rsrp != -1 && rsrpMax != -1 && rsrp - rsrpMax < 6) {
					value += 1;
				}
				if (changeNum > 2) {
					value += 1;
				}
			}
			
			if (value > 3) {
				userTypeMap.put(userKey, 0);
			} else if (value < -3) {
				userTypeMap.put(userKey, 1);
			} else {
				userTypeMap.put(userKey, 3);
			}
		}
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel.mro;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.ltemr.parse.entity.mro.TdlMroData;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroAdj;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroEutr;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroGrid;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroGridUser;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroGridUserAdj;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroGsmAdj;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroMgrsEutr;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroMgrsGridEutr;
import com.boco.wangyou.utility.grid.GridInfo;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.LteIniInfo;
import com.boco.wangyou.utility.write.WriteData;

public class WriteTdlMroSumDomain {
	private List<String> _variableTabs = null;
	private WriteData _writeData = null;
	private CommonInfo _commonInfo = null;
	private IniParseDomain _iniParse = null;
	private String _startTime = "";
	private String _splitStr = "";
	private StringBuffer _line = null;
	
	public WriteTdlMroSumDomain(List<String> variableTabs, WriteData writeData, CommonInfo commonInfo, IniParseDomain iniParse, String splitStr, StringBuffer line) {
		_variableTabs = variableTabs;
		_writeData = writeData;
		_commonInfo = commonInfo;
		_iniParse = iniParse;
		_splitStr = splitStr;
		_line = line;
		_startTime = _commonInfo.getStartTimeStr();
	}
	
	public void writeData(Map<String, TdlMroData> mapTdlData, Map<String, GridInfo> gridInfoMap) {
		for (Map.Entry<String, TdlMroData> entry : mapTdlData.entrySet()) {
			String cellKey = entry.getKey();
			TdlMroData tdlData = entry.getValue();
			
			TdlMroEutr tdlMroEutr = tdlData.getEutr();
			writeEutr(cellKey, tdlMroEutr);
			
			writeAdj(cellKey, tdlData.getAdj(), tdlMroEutr);
			writeGsmAdj(cellKey, tdlData.getGsmAdj(), tdlMroEutr);
			
			writeGrid(cellKey, tdlData.getGrid(), gridInfoMap);
			writeGridUserAdj(cellKey, tdlData.getGridUserAdj(), gridInfoMap);
			
			Map<String, TdlMroMgrsGridEutr> mapMgrsGridEutr = new HashMap<String, TdlMroMgrsGridEutr>(2000);
			TdlMroMgrsEutr tdlMroMgrsEutr = new TdlMroMgrsEutr(_splitStr);
			writeGridUser(cellKey, tdlData.getGridUser(), mapMgrsGridEutr, tdlMroMgrsEutr, gridInfoMap);
			writeMgrsGridEutr(cellKey, mapMgrsGridEutr, gridInfoMap);
			writeMgrsEutr(cellKey, tdlMroMgrsEutr);
		}
		mapTdlData.clear();
	}
	
	private void writeEutr(String cellKey, TdlMroEutr tdlMroEutr) {
		LteIniInfo iniInfo = _iniParse.getLteIniInfo(cellKey);
		String commonLine = _commonInfo.getLine() + _splitStr + iniInfo.getKeyLine() + _splitStr + cellKey;
		String commonAdjLine = _commonInfo.getLine() + _splitStr + iniInfo.getAdjKeyLine() + _splitStr + cellKey;
		_writeData.writeLine(commonLine + _splitStr + tdlMroEutr.getMaxRsrpLine(_line), "tdl_mro_maxrsrp_eutr", _startTime);
		_writeData.writeLine(commonLine + _splitStr + tdlMroEutr.getRsrpDiffLine(_line), "tdl_mro_rsrpdiff_eutr", _startTime);
		_writeData.writeLine(commonLine + _splitStr + tdlMroEutr.getOverlapLine(_line), "tdl_mro_overlap", _startTime);
		_writeData.writeLine(commonAdjLine + _splitStr + tdlMroEutr.getNumOfAdjLine(_line), "tdl_mro_numofadj_eutr", _startTime);
		if (tdlMroEutr.getFreq() != -1) {
			_writeData.writeLine(commonAdjLine + _splitStr + tdlMroEutr.getNumOfAdjFreqLine(_line), "tdl_mro_numofadj_freq", _startTime);
		}
		if (tdlMroEutr.getFreqBand() != -1) {
			_writeData.writeLine(commonAdjLine + _splitStr + tdlMroEutr.getNumOfAdjFreqBandLine(_line), "tdl_mro_numofadj_freqband", _startTime);
		}
		_writeData.writeLine(commonLine + _splitStr + tdlMroEutr.getRsrpLine(_line), "tdl_mro_rsrp", _startTime);
		_writeData.writeLine(commonLine + _splitStr + tdlMroEutr.getSinrUlLine(_line), "tdl_mro_sinrul", _startTime);
		_writeData.writeLine(commonLine + _splitStr + tdlMroEutr.getAoaLine(_line), "tdl_mro_aoa", _startTime);
		if (tdlMroEutr.getRipCnt() != 0) {
			_writeData.writeLine(commonLine + _splitStr + tdlMroEutr.getRipLine(_line), "tdl_mro_rip", _startTime);
		}
	}
	
	private void writeAdj(String cellKey, Map<String, TdlMroAdj> mapAdj, TdlMroEutr tdlMroEutr) {
		LteIniInfo mcIniInfo = _iniParse.getLteIniInfo(cellKey);
		String mcLine = mcIniInfo.getMcKeyLine() + _splitStr + cellKey;
		String mcHighLine = mcIniInfo.getMcHighKeyLine() + _splitStr + cellKey;
		
		for (Map.Entry<String, TdlMroAdj> entry : mapAdj.entrySet()) {
			String ncCellKey = entry.getKey();
			LteIniInfo ncIniInfo = _iniParse.getLteIniInfo(ncCellKey);
			if ("".equals(ncCellKey)) {
				ncCellKey = _splitStr;
			}
			TdlMroAdj tdlMroAdj = entry.getValue();
			
			String ncLine = ncIniInfo.getNcKeyLine() + _splitStr + ncCellKey;
			String ncHighLine = ncIniInfo.getNcHighKeyLine() + _splitStr + ncCellKey;
			String commonLine = _commonInfo.getLine() + _splitStr + mcLine + _splitStr + ncLine;
			String commonHighLine = _commonInfo.getLine() + _splitStr + mcHighLine + _splitStr + ncHighLine;
			
			int totalNum = (tdlMroEutr == null) ? 0 : tdlMroEutr.getTotalNum();
			if (tdlMroAdj.getTotalNum() != 0) {
				_writeData.writeLine(commonLine + _splitStr + tdlMroAdj.getDiffLine(_line) + _splitStr + totalNum, "tdl_mro_diff", _startTime);
				
				int ncScOverF6 = tdlMroAdj.getNcScOverF6(0);
				String line = commonLine + _splitStr + tdlMroAdj.getAdjTdlLine(_line) + _splitStr + totalNum + _splitStr + div(ncScOverF6, totalNum);
				_writeData.writeLine(line, "tdl_mro_adjtdl", _startTime);
			}
			
			if (tdlMroAdj.getFreq() != -1) {
				_writeData.writeLine(commonLine + _splitStr + tdlMroAdj.getDiffFreqLine(_line) + _splitStr + totalNum, "tdl_mro_diff_freq", _startTime);
				
				int ncScOverF6 = tdlMroAdj.getNcScOverF6(1);
				String line = commonLine + _splitStr + tdlMroAdj.getAdjTdlFreqLine(_line) + _splitStr + totalNum + _splitStr + div(ncScOverF6, totalNum);
				_writeData.writeLine(line, "tdl_mro_adjtdl_freq", _startTime);
			}
			
			if (tdlMroAdj.getFreqBand() != -1) {
				_writeData.writeLine(commonLine + _splitStr + tdlMroAdj.getDiffFreqBandLine(_line) + _splitStr + totalNum, "tdl_mro_diff_freqband", _startTime);
				
				int ncScOverF6 = tdlMroAdj.getNcScOverF6(2);
				String line = commonLine + _splitStr + tdlMroAdj.getAdjTdlFreqBandLine(_line) + _splitStr + totalNum + _splitStr + div(ncScOverF6, totalNum);
				_writeData.writeLine(line, "tdl_mro_adjtdl_freqband", _startTime);
			}
			
			int totalNumPol = (tdlMroEutr == null) ? 0 : tdlMroEutr.getTotalNumPol();
			String line = commonHighLine + _splitStr + tdlMroAdj.getPolAdjLine(_line) + _splitStr + totalNumPol;
			_writeData.writeLine(line, "tdl_mro_pol_adj", _startTime);
		}
		mapAdj.clear();
	}
	
	private void writeGsmAdj(String cellKey, Map<String, TdlMroGsmAdj> mapGsmAdj, TdlMroEutr tdlMroEutr) {
		String mcLine = _iniParse.getLteIniInfo(cellKey).getMcKeyLine() + _splitStr + cellKey;
		for (Map.Entry<String, TdlMroGsmAdj> entry : mapGsmAdj.entrySet()) {
			String ncCellKey = entry.getKey();
			if ("".equals(ncCellKey)) {
				ncCellKey = _splitStr;
			}
			TdlMroGsmAdj tdlMroGsmAdj = entry.getValue();
			
			String ncLine = tdlMroGsmAdj.getKeyLine() + _splitStr + ncCellKey;
			String commonLine = _commonInfo.getLine() + _splitStr + mcLine + _splitStr + ncLine;
			int totalNum = (tdlMroEutr == null) ? 0 : tdlMroEutr.getGsmTotalNum();
			double aveRsrp = (tdlMroEutr == null) ? 0 : tdlMroEutr.getGsmAveRsrp();
			_writeData.writeLine(commonLine + _splitStr + tdlMroGsmAdj.getRsrpRssiLine(_line) + _splitStr + totalNum, "tdl_mro_rsrprssi", _startTime);
			_writeData.writeLine(commonLine + _splitStr + tdlMroGsmAdj.getAdjtdlGsmLine(_line) + _splitStr + totalNum + _splitStr + aveRsrp, "tdl_mro_adjtdl_gsm", _startTime);
		}
		mapGsmAdj.clear();
	}
	
	private void writeGrid(String cellKey, Map<String, TdlMroGrid> mapGrid, Map<String, GridInfo> gridInfoMap) {
		String cellLine = _iniParse.getLteIniInfo(cellKey).getGridKeyLine() + _splitStr + cellKey;
		for (Map.Entry<String, TdlMroGrid> entry : mapGrid.entrySet()) {
			String gridKey = entry.getKey();
			if (!gridInfoMap.containsKey(gridKey)) {
				continue;
			}
			String gridInfo = gridInfoMap.get(gridKey).getGridLatLonLDRU();
			
			TdlMroGrid tdlMroGrid = entry.getValue();
			String commonLine = _commonInfo.getLine() + _splitStr + cellLine + _splitStr + gridKey + _splitStr + gridInfo;
			_writeData.writeLine(commonLine + _splitStr + tdlMroGrid.getLine(_line), "tdl_mro_mgrs_numofadj_eutr", _startTime);
		}
		mapGrid.clear();
	}
	
	private void writeGridUserAdj(String cellKey, Map<String, Map<String, Map<Integer, TdlMroGridUserAdj>>> mapGridUserAdj, Map<String, GridInfo> gridInfoMap) {
		String mcLine = _iniParse.getLteIniInfo(cellKey).getMcHighKeyLine() + _splitStr + cellKey;
		for (Map.Entry<String, Map<String, Map<Integer, TdlMroGridUserAdj>>> entry : mapGridUserAdj.entrySet()) {
			String gridKey = entry.getKey();
			if (!gridInfoMap.containsKey(gridKey)) {
				continue;
			}
			String gridInfo = gridInfoMap.get(gridKey).getValue();
			
			for (Map.Entry<String, Map<Integer, TdlMroGridUserAdj>> entryAdj : entry.getValue().entrySet()) {
				String ncCellKey = entryAdj.getKey();
				if ("".equals(ncCellKey)) {
					ncCellKey = _splitStr;
				}
				String ncLine = _iniParse.getLteIniInfo(ncCellKey).getGridNcKeyLine() + _splitStr + ncCellKey;
				for (Map.Entry<Integer, TdlMroGridUserAdj> entryUser : entryAdj.getValue().entrySet()) {
					int userType = entryUser.getKey();
					TdlMroGridUserAdj tdlMroGridUserAdj = entryUser.getValue();
					String commonLine = _commonInfo.getLine() + _splitStr + gridKey + _splitStr + gridInfo + _splitStr + userType + _splitStr + mcLine + _splitStr + ncLine;
					_writeData.writeLine(commonLine + _splitStr + tdlMroGridUserAdj.getRsrpLine(_line), "tdl_mro_mgrs_user_maxrsrp", _startTime);
				}
			}
		}
		mapGridUserAdj.clear();
	}
	
	private void writeGridUser(String cellKey, Map<String, Map<Integer, TdlMroGridUser>> mapGridUser, Map<String, TdlMroMgrsGridEutr> mapMgrsGridEutr, TdlMroMgrsEutr tdlMroMgrsEutr, Map<String, GridInfo> gridInfoMap) {
		String cellLine = _iniParse.getLteIniInfo(cellKey).getGridKeyLine() + _splitStr + cellKey;
		for (Map.Entry<String, Map<Integer, TdlMroGridUser>> entry : mapGridUser.entrySet()) {
			String gridKey = entry.getKey();
			if (!gridInfoMap.containsKey(gridKey)) {
				continue;
			}
			String gridInfo = gridInfoMap.get(gridKey).getValue();
			int gisLevel = gridInfoMap.get(gridKey).getGisLevel();
			
			TdlMroMgrsGridEutr tdlMroMgrsGridEutr = null;
			if (mapMgrsGridEutr.containsKey(gridKey)) {
				tdlMroMgrsGridEutr = mapMgrsGridEutr.get(gridKey);
			} else {
				tdlMroMgrsGridEutr = new TdlMroMgrsGridEutr(_variableTabs, _splitStr);
			}
			
			for (Map.Entry<Integer, TdlMroGridUser> entryUser : entry.getValue().entrySet()) {
				int userType = entryUser.getKey();
				TdlMroGridUser tdlMroGridUser = entryUser.getValue();
				
				String commonLine = _commonInfo.getLine() + _splitStr + cellLine + _splitStr + gridKey + _splitStr + gridInfo + _splitStr + userType;
				_writeData.writeLine(commonLine + _splitStr + tdlMroGridUser.getMgrsRsrpLine(_line), "tdl_mro_mgrs_user_rsrp", _startTime);
				_writeData.writeLine(commonLine + _splitStr + tdlMroGridUser.getMgrsRsrqLine(_line), "tdl_mro_mgrs_user_rsrq", _startTime);
				_writeData.writeLine(commonLine + _splitStr + tdlMroGridUser.getMgrsSinrUlLine(_line), "tdl_mro_mgrs_user_sinrul", _startTime);
				_writeData.writeLine(commonLine + _splitStr + tdlMroGridUser.getMgrsPhrLine(_line), "tdl_mro_mgrs_user_phr", _startTime);
				_writeData.writeLine(commonLine + _splitStr + tdlMroGridUser.getMgrsSinrDlLine(_line), "tdl_mro_mgrs_user_sinrdl", _startTime);
				
				if (_variableTabs.contains("tdl_mro_mgrs_rsrp_eutr_u") || _variableTabs.contains("tdl_mro_mgrs_rsrq_eutr_u") || _variableTabs.contains("tdl_mro_mgrs_sinru_eutr_u")
						 || _variableTabs.contains("tdl_mro_mgrs_phr_eutr_u")  || _variableTabs.contains("tdl_mro_mgrs_sinrd_eutr_u")) {
					makeMgrsGridEutr(tdlMroMgrsGridEutr, tdlMroGridUser, userType);
				}
				if (_variableTabs.contains("tdl_mro_mgrs_rsrp_eutr") && gisLevel == 50) {
					makeMgrsEutr(tdlMroMgrsEutr, tdlMroGridUser, gridKey);
				}
			}
			mapMgrsGridEutr.put(gridKey, tdlMroMgrsGridEutr);
		}
		mapGridUser.clear();
	}
	
	public void writeMgrsGridEutr(String cellKey, Map<String, TdlMroMgrsGridEutr> mapMgrsGridEutr, Map<String, GridInfo> gridInfoMap) {
		String cellLine = _iniParse.getLteIniInfo(cellKey).getGridKeyLine() + _splitStr + cellKey;
		for (Map.Entry<String, TdlMroMgrsGridEutr> entry : mapMgrsGridEutr.entrySet()) {
			String gridKey = entry.getKey();
			if (!gridInfoMap.containsKey(gridKey)) {
				continue;
			}
			String gridInfo = gridInfoMap.get(gridKey).getValue();
			
			TdlMroMgrsGridEutr tdlMroMgrsGridEutr = entry.getValue();
			String commonLine = _commonInfo.getLine() + _splitStr + cellLine + _splitStr + gridKey + _splitStr + gridInfo;
			_writeData.writeLine(commonLine + _splitStr + tdlMroMgrsGridEutr.getRsrpLine(_line), "tdl_mro_mgrs_rsrp_eutr_u", _startTime);
			_writeData.writeLine(commonLine + _splitStr + tdlMroMgrsGridEutr.getRsrqLine(_line), "tdl_mro_mgrs_rsrq_eutr_u", _startTime);
			_writeData.writeLine(commonLine + _splitStr + tdlMroMgrsGridEutr.getSinrUlLine(_line), "tdl_mro_mgrs_sinru_eutr_u", _startTime);
			_writeData.writeLine(commonLine + _splitStr + tdlMroMgrsGridEutr.getPhrLine(_line), "tdl_mro_mgrs_phr_eutr_u", _startTime);
			_writeData.writeLine(commonLine + _splitStr + tdlMroMgrsGridEutr.getSinrDlLine(_line), "tdl_mro_mgrs_sinrd_eutr_u", _startTime);
		}
	}
	
	public void writeMgrsEutr(String cellKey, TdlMroMgrsEutr tdlMroMgrsEutr) {
		String commonLine = _commonInfo.getLine() + _splitStr + _iniParse.getLteIniInfo(cellKey).getHighKeyLine();
		_writeData.writeLine(commonLine + _splitStr + tdlMroMgrsEutr.getRsrpLine(_line), "tdl_mro_mgrs_rsrp_eutr", _startTime);
	}
	
	private void makeMgrsGridEutr(TdlMroMgrsGridEutr tdlMroMgrsGridEutr, TdlMroGridUser tdlMroGridUser, int userType) {
		tdlMroMgrsGridEutr.setValue(tdlMroGridUser, userType);
	}
	
	private void makeMgrsEutr(TdlMroMgrsEutr tdlMroMgrsEutr, TdlMroGridUser tdlMroGridUser, String gridId) {
		tdlMroMgrsEutr.setValue(tdlMroGridUser, gridId);
	}
	
	private double div(int numerator, int denominator) {
		if (denominator == 0) {
			return 0;
		}
		return (double) numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel;

import java.io.BufferedReader;
import java.io.IOException;

import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.MrKeyInfo;
import com.boco.wangyou.ltemr.parse.entity.XmlCommonInfo;

public class MrParseDomain {
	public void parseFileHeader(String line, XmlCommonInfo xmlCommonInfo) {
		String reportTime = parseValue(line, "reporttime").replace("t", " ").replaceAll("\\.\\d+", "");
		String startTime = parseValue(line, "starttime").replace("t", " ").replaceAll("\\.\\d+", "");
		xmlCommonInfo.setHeader(reportTime, startTime);
	}
	
	public void parseEnb(String line, XmlCommonInfo xmlCommonInfo) {
		String enbId = parseValue(line, "id");
		if ("".equals(enbId)) {
			enbId = parseValue(line, "mr.enbid");
		}
		String userLabel = parseValue(line, "userlabel");
		xmlCommonInfo.setEnb(enbId, userLabel);
	}
	
	public void parseSmr(String line, MrIdxInfo idxInfo) {
		String[] smr = line.toLowerCase().replaceAll("\\<\\/?smr\\>", "").trim().split("\\s", -1);
		idxInfo.setIdx(smr);
	}
	
	public void parseSmrFlag(MrIdxInfo idxInfo) {
		idxInfo.setFlag();
	}
	
	public String parseMeasurement(String line) {
		return parseValue(line, "mrname");
	}
	
	public void parseObject(String line, MrKeyInfo keyInfo, String enodeb) {
		String mmeCode = parseValue(line, "mmecode");
		String mmeGroupId = parseValue(line, "mmegroupid");
		String mmeUeS1apId = parseValue(line, "mmeues1apid");
		String timeStamp = parseValue(line, "timestamp").replace("t", " ");
		String id = parseValue(line, "id");
		String eventType = parseValue(line, "eventtype");
		keyInfo.setObject(mmeCode, mmeGroupId, mmeUeS1apId, timeStamp, id, enodeb, eventType);
	}
	
	public void seekFile(BufferedReader br) throws IOException {
		String line = null;
		while ((line = br.readLine()) != null) {
			line = line.toLowerCase();
			if (line.contains("</measurement>")) {
				break;
			}
		}
	}
	
	public void seekFileToEnd(BufferedReader br) throws IOException {
		String line = null;
		while ((line = br.readLine()) != null) {
			line = line.toLowerCase();
			if (line.contains("</bulkpmmrdatafile>")) {
				break;
			}
		}
	}
	
	private String parseValue(String line, String key) {
		int keyIndex = line.indexOf(" " + key);
		if (keyIndex == -1) {
			if ("id".equals(key)) {
				key = "object" + key;
			}
			keyIndex = line.indexOf("." + key);
			if (keyIndex == -1) {
				return "";
			}
		}
		
		int valueStartIndex = line.indexOf("\"", keyIndex) + 1;
		int valueEndIndex = line.indexOf("\"", valueStartIndex);
		
		if(valueEndIndex < valueStartIndex) {
			return "";
		}
		return line.substring(valueStartIndex, valueEndIndex).trim();
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel.mrs;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.List;

import com.boco.wangyou.ltemr.parse.domainmodel.LteMrXmlParse;
import com.boco.wangyou.ltemr.parse.domainmodel.MrParseDomain;
import com.boco.wangyou.ltemr.parse.domainmodel.XmlParseStream;
import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.ltemr.parse.entity.MrKeyInfo;
import com.boco.wangyou.ltemr.parse.entity.XmlCommonInfo;
import com.boco.wangyou.utility.cfg.ConfigConstants;
import com.boco.wangyou.utility.ini.domainmodel.IniParseKeyDomain;
import com.boco.wangyou.utility.write.WriteData;

public class LteMrsXmlParse extends LteMrXmlParse {
	private XmlParseStream _stream = null;
	private CommonInfo _commonInfo = null;
	private WriteData _writeData = null;
	private IniParseKeyDomain _iniParse = null;
	private String _splitStr = "";
	private StringBuffer _line = new StringBuffer(1000);
	
	public LteMrsXmlParse(XmlParseStream stream, CommonInfo commonInfo, WriteData writeData, String iniDir, ConfigConstants cfgInfo, int type) {
		_stream = stream;
		_commonInfo = commonInfo;
		_writeData = writeData;
		List<String> variableTabs = cfgInfo.getMrsTabs("VARIABLE_MRS_TABLE_NAME");
		_writeData.setVariableTabs(variableTabs);
		_splitStr = cfgInfo.getValue("SPLIT_STRING", "|");
		String encode = cfgInfo.getValue("CHARACTER_SET", "UTF-8");
		_iniParse = new IniParseKeyDomain(iniDir, type, _splitStr, encode);
	}
	
	public void read() throws IOException {
		_iniParse.parse();
		
		MrKeyInfo keyInfo = new MrKeyInfo(_splitStr);
		XmlCommonInfo xmlCommonInfo = new XmlCommonInfo(_splitStr);
		
		MrParseDomain mrsParse = new MrParseDomain();
		MrsSumParseDomain sumParse = new MrsSumParseDomain(_writeData, _commonInfo, _iniParse, _splitStr);
		
		BufferedReader br = _stream.getStream();
		String line = null;
		String enodebBackup = null;
		String mrName = null;
		while ((line = br.readLine()) != null) {
			line = line.toLowerCase();
			if (line.contains("<enb")) {
				mrsParse.parseEnb(line, xmlCommonInfo);
				String enodeb = xmlCommonInfo.getEnodeb();
				if (enodebBackup == null) {
					enodebBackup = enodeb;
				} else if (!enodeb.equals(enodebBackup)) {
					sumParse.write(_line);
					enodebBackup = enodeb;
				}
				continue;
			}
			
			if (line.contains("<measurement")) {
				mrName = mrsParse.parseMeasurement(line);
				continue;
			}
			
			if (line.contains("<object")) {
				mrsParse.parseObject(line, keyInfo, enodebBackup);
				continue;
			}
			
			if (line.contains("<v>")) {
				String[] valueItems = line.toLowerCase().replaceAll("\\<\\/?v\\>", "").trim().split("\\s", -1);
				sumParse.sum(valueItems, mrName, keyInfo);
			}
		}
		br.close();
		sumParse.write(_line);
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel.mrs;

import java.util.HashMap;
import java.util.Map;

import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.ltemr.parse.entity.MrKeyInfo;
import com.boco.wangyou.ltemr.parse.entity.mrs.TdlMrsValue;
import com.boco.wangyou.utility.ini.domainmodel.IniParseKeyDomain;
import com.boco.wangyou.utility.ini.entity.LteIniKeyInfo;
import com.boco.wangyou.utility.write.WriteData;

public class MrsSumParseDomain {
	private Map<String, TdlMrsValue> mapEutr = new HashMap<String, TdlMrsValue>(20);
	private WriteData _writeData = null;
	private CommonInfo _commonInfo = null;
	private IniParseKeyDomain _iniParse = null;
	private String _splitStr = "";
	
	public MrsSumParseDomain(WriteData writeData, CommonInfo commonInfo, IniParseKeyDomain iniParse, String splitStr) {
		_writeData = writeData;
		_commonInfo = commonInfo;
		_iniParse = iniParse;
		_splitStr = splitStr;
	}
	
	public void sum(String[] valueItems, String mrName, MrKeyInfo keyInfo) {
		String cellId = keyInfo.getCell();
		LteIniKeyInfo iniInfo = _iniParse.getLteIniInfo(cellId);
		if (iniInfo == null) {
			return;
		}
		
		String subFrame = keyInfo.getSubFrame();
		TdlMrsValue tdlMrsEutr = null;
		if (mapEutr.containsKey(cellId)) {
			tdlMrsEutr = mapEutr.get(cellId);
		} else {
			tdlMrsEutr = new TdlMrsValue(_splitStr);
		}
		makeMrsValue(tdlMrsEutr, mrName, valueItems, subFrame, 0);
		mapEutr.put(cellId, tdlMrsEutr);
	}
	
	public void write(StringBuffer line) {
		WriteTdlMrsSumDomain write = new WriteTdlMrsSumDomain(_writeData, _commonInfo, _iniParse, _splitStr, line);
		write.writeData(mapEutr);
	}
	
	private void makeMrsValue(TdlMrsValue tdlMrsValue, String mrName, String[] valueItems, String subFrame, int flag) {
		if ("mr.rsrp".equals(mrName)) {
			tdlMrsValue.makeRsrp(valueItems);
		} else if ("mr.rsrq".equals(mrName)) {
			tdlMrsValue.makeRsrq(valueItems);
		} else if ("mr.rxtxtimediff".equals(mrName)) {
			tdlMrsValue.makeRxTxTimeDiff(valueItems);
		} else if ("mr.powerheadroom".equals(mrName)) {
			tdlMrsValue.makePowerHeadRoom(valueItems);
		} else if ("mr.receivedipower".equals(mrName)) {
			tdlMrsValue.makeReceivedIPower(valueItems, subFrame);
		} else if ("mr.aoa".equals(mrName)) {
			tdlMrsValue.makeAoa(valueItems);
		} else if (mrName.contains("mr.packetlossrateulqci")) {
			int qci = Integer.parseInt(mrName.substring(mrName.length() - 1, mrName.length()));
			tdlMrsValue.makePacketLossRateUlQci(valueItems, qci);
		} else if (mrName.contains("mr.packetlossratedlqci")) {
			int qci = Integer.parseInt(mrName.substring(mrName.length() - 1, mrName.length()));
			tdlMrsValue.makePacketLossRateDlQci(valueItems, qci);
		} else if ("mr.sinrul".equals(mrName)) {
			tdlMrsValue.makeSinrUl(valueItems);
		} else if ("mr.tadv".equals(mrName)) {
			tdlMrsValue.makeTadv(valueItems);
		} else if ("mr.ripprb".equals(mrName)) {
			tdlMrsValue.makeRipPrb(valueItems, subFrame);
		} else if ("mr.puschprbnum".equals(mrName)) {
			tdlMrsValue.makePuschPrbNum(valueItems);
		} else if ("mr.pdschprbnum".equals(mrName)) {
			tdlMrsValue.makePdschPrbNum(valueItems);
		} else if ("mr.enbrxtxtimediff".equals(mrName)) {
			tdlMrsValue.makeEnbRxTxTimeDiff(valueItems);
		} else if ("mr.rttdrsrp".equals(mrName)) {
			tdlMrsValue.makeRttdRsrp(valueItems);
		} else if ("mr.rttdaoa".equals(mrName)) {
			tdlMrsValue.makeRttdAoa(valueItems);
		} else if ("mr.rsrprsrq".equals(mrName)) {
			tdlMrsValue.makeRsrpRsrq(valueItems);
		} else if ("mr.riprsrp".equals(mrName)) {
			tdlMrsValue.makeRipRsrp(valueItems);
		} else if ("mr.riprsrq".equals(mrName)) {
			tdlMrsValue.makeRipRsrq(valueItems);
		} else if (mrName.contains("mr.plrulqci") && mrName.contains("sinrul")) {
			int idx = mrName.indexOf("sinrul");
			int qci = Integer.parseInt(mrName.substring(idx - 1, idx));
			tdlMrsValue.makePlrUlQciSinrUl(valueItems, qci);
		} else if (mrName.contains("mr.plrdlqci") && mrName.contains("rsrq")) {
			int idx = mrName.indexOf("rsrq");
			int qci = Integer.parseInt(mrName.substring(idx - 1, idx));
			tdlMrsValue.makePlrDlQciRsrq(valueItems, qci);
		} else if (mrName.contains("mr.plrdlqci") && mrName.contains("rsrp")) {
			int idx = mrName.indexOf("rsrp");
			int qci = Integer.parseInt(mrName.substring(idx - 1, idx));
			tdlMrsValue.makePlrDlQciRsrp(valueItems, qci);
		} else if (mrName.contains("mr.plrulqci") && mrName.contains("rip")) {
			int idx = mrName.indexOf("rip");
			int qci = Integer.parseInt(mrName.substring(idx - 1, idx));
			tdlMrsValue.makePlrUlQciRip(valueItems, qci);
		} else if ("mr.sinrulrip".equals(mrName)) {
			tdlMrsValue.makeSinrUlRip(valueItems);
		} else if ("mr.tadvrsrp".equals(mrName)) {
			tdlMrsValue.makeTadvRsrp(valueItems);
		} else if ("mr.tadvaoa".equals(mrName)) {
			tdlMrsValue.makeTadvAoa(valueItems);
		} else if ("mr.puschprbnumphr".equals(mrName)) {
			tdlMrsValue.makePuschPrbNumPhr(valueItems);
		} else if ("mr.pdschprbnumrsrq".equals(mrName)) {
			tdlMrsValue.makePdschPrbNumRsrq(valueItems);
		}
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel.mrs;

import java.util.HashMap;
import java.util.Map;

import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.ltemr.parse.entity.mrs.TdlMrsAverage;
import com.boco.wangyou.ltemr.parse.entity.mrs.TdlMrsValue;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PacketLossRateDlAll;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PacketLossRateDlQci;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PacketLossRateUlAll;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PacketLossRateUlQci;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.ReceivedIPower;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.RipPrb;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.PlrDlQciRsrp;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.PlrDlQciRsrq;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.PlrUlQciRip;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.PlrUlQciSinrUl;
import com.boco.wangyou.utility.ini.domainmodel.IniParseKeyDomain;
import com.boco.wangyou.utility.ini.entity.LteIniKeyInfo;
import com.boco.wangyou.utility.write.WriteData;

public class WriteTdlMrsSumDomain {
	private WriteData _writeData = null;
	private CommonInfo _commonInfo = null;
	private IniParseKeyDomain _iniParse = null;
	private String _startTime = "";
	private String _splitStr = "";
	private StringBuffer _line = null;
	
	public WriteTdlMrsSumDomain(WriteData writeData, CommonInfo commonInfo, IniParseKeyDomain iniParse, String splitStr, StringBuffer line) {
		_writeData = writeData;
		_commonInfo = commonInfo;
		_iniParse = iniParse;
		_splitStr = splitStr;
		_line = line;
		_startTime = _commonInfo.getStartTime();
	}
	
	public void writeData(Map<String, TdlMrsValue> mapEutr) {
		Map<String, TdlMrsValue> mapEnodeb = new HashMap<String, TdlMrsValue>(20);
		Map<String, TdlMrsAverage> mapAverageServ = new HashMap<String, TdlMrsAverage>(20);
		Map<String, String> mapEnodebKey = new HashMap<String, String>(20);
		for (Map.Entry<String, TdlMrsValue> entry : mapEutr.entrySet()) {
			String cellId = entry.getKey();
			LteIniKeyInfo iniInfo = _iniParse.getLteIniInfo(cellId);
			if (iniInfo == null) {
				return;
			}
			TdlMrsValue tdlMrsEutr = entry.getValue();
			
			String enodebKey = iniInfo.getEnodebKey();
			TdlMrsValue tdlMrsEnodeb = null;
			if (mapEnodeb.containsKey(enodebKey)) {
				tdlMrsEnodeb = mapEnodeb.get(enodebKey);
			} else {
				tdlMrsEnodeb = new TdlMrsValue(_splitStr);
			}
			tdlMrsEnodeb.sum(tdlMrsEutr);
			
			String coverType = iniInfo.getCoverType();
			String servKey = enodebKey + _splitStr + "101" + _splitStr + coverType;
			TdlMrsAverage tdlMrsAverage = null;
			if (mapAverageServ.containsKey(servKey)) {
				tdlMrsAverage = mapAverageServ.get(servKey);
			} else {
				tdlMrsAverage = new TdlMrsAverage(_splitStr);
			}
			
			String commonLine = _commonInfo.getTimeLine() + _splitStr + iniInfo.getEutrKey() + _splitStr + cellId;
			writeValue(commonLine, tdlMrsEutr, "eutr", tdlMrsEnodeb, tdlMrsAverage);
			mapEnodeb.put(enodebKey, tdlMrsEnodeb);
			mapAverageServ.put(servKey, tdlMrsAverage);
			String enodeb = cellId.contains(_splitStr) ? cellId.substring(0, cellId.indexOf(_splitStr)) : cellId;
			mapEnodebKey.put(enodebKey, iniInfo.getEnodebValue() + _splitStr + enodeb);
		}
		mapEutr.clear();
		
		for (Map.Entry<String, TdlMrsValue> entry : mapEnodeb.entrySet()) {
			String enodebId = entry.getKey();
			TdlMrsValue tdlMrsEnodeb = entry.getValue();
			String enodebLine = _splitStr + _splitStr + _splitStr + _splitStr;
			if (mapEnodebKey.containsKey(enodebId)) {
				enodebLine = mapEnodebKey.get(enodebId);
			}
			String commonLine = _commonInfo.getTimeLine() + _splitStr + enodebId + _splitStr + enodebLine;
			writeValue(commonLine, tdlMrsEnodeb, "sum", null, null);
		}
		mapEnodeb.clear();
		
		for (Map.Entry<String, TdlMrsAverage> entry : mapAverageServ.entrySet()) {
			String servKey = entry.getKey();
			TdlMrsAverage tdlMrsAverage = entry.getValue();
			String enodebId = servKey.contains(_splitStr) ? servKey.substring(0, servKey.indexOf(_splitStr)) : servKey;
			String enodebLine = _splitStr + _splitStr + _splitStr + _splitStr;
			if (mapEnodebKey.containsKey(enodebId)) {
				enodebLine = mapEnodebKey.get(enodebId);
			}
			String commonLine = _commonInfo.getTimeLine() + _splitStr + servKey + _splitStr + enodebLine;
			_writeData.writeLine(commonLine + _splitStr + tdlMrsAverage.getLine(_line), "tdl_mrs_average_sum_serv", _startTime);
		}
	}
	
	private void writeValue(String commonLine, TdlMrsValue tdlMrsValue, String tabTail, TdlMrsValue tdlMrsSumValue, TdlMrsAverage tdlMrsAverageServ) {
		if (tdlMrsValue.isNotEmptyRsrp()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getRsrpLine(_line), "tdl_mrs_rsrp_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyRsrq()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getRsrqLine(_line), "tdl_mrs_rsrq_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyRxTxTimeDiff()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getRxTxTimeDiffLine(_line), "tdl_mrs_rxtxtimediff_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyPowerHeadRoom()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getPowerHeadRoomLine(_line), "tdl_mrs_powerheadroom_" + tabTail, _startTime);
		}
		
		Map<String, ReceivedIPower> mapReceivedIPower = tdlMrsValue.getReceivedIPower();
		ReceivedIPower receivedIPowerSum = new ReceivedIPower(_splitStr);
		for (Map.Entry<String, ReceivedIPower> entry : mapReceivedIPower.entrySet()) {
			String subFrame = entry.getKey();
			ReceivedIPower receivedIPower = entry.getValue();
			if (receivedIPower.isNotEmpty()) {
				_writeData.writeLine(commonLine + _splitStr + subFrame + _splitStr + receivedIPower.getLine(_line), "tdl_mrs_receivedipower_subf", _startTime);
			}
			receivedIPowerSum.sum(receivedIPower);
		}
		if (tdlMrsSumValue != null) {
			if (receivedIPowerSum.isNotEmpty()) {
				_writeData.writeLine(commonLine + _splitStr + receivedIPowerSum.getLine(_line), "tdl_mrs_receivedipower_" + tabTail, _startTime);
				tdlMrsSumValue.makeReceivedIPowerSum(receivedIPowerSum);
			}
		} else {
			if (tdlMrsValue.isNotEmptyReceivedIPower()) {
				_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getReceivedIPowerLine(_line), "tdl_mrs_receivedipower_" + tabTail, _startTime);
			}
		}
		
		if (tdlMrsValue.isNotEmptyAoa()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getAoaLine(_line), "tdl_mrs_aoa_" + tabTail, _startTime);
		}
		
		Map<Integer, PacketLossRateUlQci> mapPacketLossRateUlQci = tdlMrsValue.getPacketLossRateUlQci();
		PacketLossRateUlAll packetLossRateUlAll = new PacketLossRateUlAll(_splitStr);
		for (Map.Entry<Integer, PacketLossRateUlQci> entry : mapPacketLossRateUlQci.entrySet()) {
			int qci = entry.getKey();
			PacketLossRateUlQci packetLossRateUlQci = entry.getValue();
			if (packetLossRateUlQci.isNotEmpty()) {
				_writeData.writeLine(commonLine + _splitStr + qci + _splitStr + packetLossRateUlQci.getLine(_line), "tdl_mrs_packetlrulq_" + tabTail, _startTime);
			}
			packetLossRateUlAll.sum(qci, packetLossRateUlQci);
		}
		if (packetLossRateUlAll.isNotEmpty()) {
			_writeData.writeLine(commonLine + _splitStr + packetLossRateUlAll.getLine(_line), "tdl_mrs_packetlrul_all_" + tabTail, _startTime);
		}
		
		Map<Integer, PacketLossRateDlQci> mapPacketLossRateDlQci = tdlMrsValue.getPacketLossRateDlQci();
		PacketLossRateDlAll packetLossRateDlAll = new PacketLossRateDlAll(_splitStr);
		for (Map.Entry<Integer, PacketLossRateDlQci> entry : mapPacketLossRateDlQci.entrySet()) {
			int qci = entry.getKey();
			PacketLossRateDlQci packetLossRateDlQci = entry.getValue();
			if (packetLossRateDlQci.isNotEmpty()) {
				_writeData.writeLine(commonLine + _splitStr + qci + _splitStr + packetLossRateDlQci.getLine(_line), "tdl_mrs_packetlrdlq_" + tabTail, _startTime);
			}
			packetLossRateDlAll.sum(qci, packetLossRateDlQci);
		}
		if (packetLossRateDlAll.isNotEmpty()) {
			_writeData.writeLine(commonLine + _splitStr + packetLossRateDlAll.getLine(_line), "tdl_mrs_packetlrdl_all_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptySinrUl()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getSinrUlLine(_line), "tdl_mrs_sinrul_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyTadv()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getTadvLine(_line), "tdl_mrs_tadv_" + tabTail, _startTime);
		}
		
		Map<String, RipPrb> mapRipPrb = tdlMrsValue.getRipPrb();
		for (Map.Entry<String, RipPrb> entry : mapRipPrb.entrySet()) {
			String subFrame = entry.getKey();
			RipPrb ripPrb = entry.getValue();
			if (ripPrb.isNotEmpty()) {
				_writeData.writeLine(commonLine + _splitStr + subFrame + _splitStr + ripPrb.getLine(_line), "tdl_mrs_ripprb_" + tabTail, _startTime);
			}
		}
		
		if (tdlMrsValue.isNotEmptyPuschPrbNum()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getPuschPrbNumLine(_line), "tdl_mrs_puschprbnum_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyPdschPrbNum()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getPdschPrbNumLine(_line), "tdl_mrs_pdschprbnum_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyEnbRxTxTimeDiff()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getEnbRxTxTimeDiffLine(_line), "tdl_mrs_enbrxtxtimediff_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyRttdRsrp()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getRttdRsrpLine(_line), "tdl_mrs_rttdrsrp_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyRttdAoa()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getRttdAoaLine(_line), "tdl_mrs_rttdaoa_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyRsrpRsrq()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getRsrpRsrqLine(_line), "tdl_mrs_rsrprsrq_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyRipRsrp()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getRipRsrpLine(_line), "tdl_mrs_riprsrp_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyRipRsrq()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getRipRsrqLine(_line), "tdl_mrs_riprsrq_" + tabTail, _startTime);
		}
		
		Map<Integer, PlrUlQciSinrUl> mapPlrUlQciSinrUl = tdlMrsValue.getPlrUlQciSinrUl();
		for (Map.Entry<Integer, PlrUlQciSinrUl> entry : mapPlrUlQciSinrUl.entrySet()) {
			int qci = entry.getKey();
			PlrUlQciSinrUl plrUlQciSinrUl = entry.getValue();
			if (plrUlQciSinrUl.isNotEmpty()) {
				_writeData.writeLine(commonLine + _splitStr + qci + _splitStr + plrUlQciSinrUl.getLine(_line), "tdl_mrs_plrulqcisinrul_" + tabTail, _startTime);
			}
		}
		
		Map<Integer, PlrDlQciRsrq> mapPlrDlQciRsrq = tdlMrsValue.getPlrDlQciRsrq();
		for (Map.Entry<Integer, PlrDlQciRsrq> entry : mapPlrDlQciRsrq.entrySet()) {
			int qci = entry.getKey();
			PlrDlQciRsrq plrDlQciRsrq = entry.getValue();
			if (plrDlQciRsrq.isNotEmpty()) {
				_writeData.writeLine(commonLine + _splitStr + qci + _splitStr + plrDlQciRsrq.getLine(_line), "tdl_mrs_plrdlqcirsrq_" + tabTail, _startTime);
			}
		}
		
		Map<Integer, PlrDlQciRsrp> mapPlrDlQciRsrp = tdlMrsValue.getPlrDlQciRsrp();
		for (Map.Entry<Integer, PlrDlQciRsrp> entry : mapPlrDlQciRsrp.entrySet()) {
			int qci = entry.getKey();
			PlrDlQciRsrp plrDlQciRsrp = entry.getValue();
			if (plrDlQciRsrp.isNotEmpty()) {
				_writeData.writeLine(commonLine + _splitStr + qci + _splitStr + plrDlQciRsrp.getLine(_line), "tdl_mrs_plrdlqcirsrp_" + tabTail, _startTime);
			}
		}
		
		Map<Integer, PlrUlQciRip> mapPlrUlQciRip = tdlMrsValue.getPlrUlQciRip();
		for (Map.Entry<Integer, PlrUlQciRip> entry : mapPlrUlQciRip.entrySet()) {
			int qci = entry.getKey();
			PlrUlQciRip plrUlQciRip = entry.getValue();
			if (plrUlQciRip.isNotEmpty()) {
				_writeData.writeLine(commonLine + _splitStr + qci + _splitStr + plrUlQciRip.getLine(_line), "tdl_mrs_plrulqcirip_" + tabTail, _startTime);
			}
		}
		
		if (tdlMrsValue.isNotEmptySinrUlRip()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getSinrUlRipLine(_line), "tdl_mrs_sinrulrip_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyTadvRsrp()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getTadvRsrpLine(_line), "tdl_mrs_tadvrsrp_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyTadvAoa()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getTadvAoaLine(_line), "tdl_mrs_tadvaoa_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyPuschPrbNumPhr()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getPuschPrbNumPhrLine(_line), "tdl_mrs_puschprbnumphr_" + tabTail, _startTime);
		}
		
		if (tdlMrsValue.isNotEmptyPdschPrbNumRsrq()) {
			_writeData.writeLine(commonLine + _splitStr + tdlMrsValue.getPdschPrbNumRsrqLine(_line), "tdl_mrs_pdschprbnumrsrq_" + tabTail, _startTime);
		}
		
		TdlMrsAverage tdlMrsAverage = new TdlMrsAverage(_splitStr);
		tdlMrsAverage.sum(tdlMrsValue);
		_writeData.writeLine(commonLine + _splitStr + tdlMrsAverage.getLine(_line), "tdl_mrs_average_" + tabTail, _startTime);
		if (tdlMrsAverageServ != null) {
			tdlMrsAverageServ.sum(tdlMrsAverage);
		}
	}
}
package com.boco.wangyou.ltemr.parse.domainmodel;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.zip.GZIPInputStream;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;

import com.boco.wangyou.utility.LogUtil;

public class XmlParseStream {
	private String _fileName = null;
	private BufferedReader br = null;
	private BufferedReader brUser = null;
	
	public void makeStream(File inputFile, int flag) {
		_fileName = inputFile.getName();
		try {
			br = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(inputFile))));
			if (flag == 1) {
				brUser = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(inputFile))));
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public void makeStream(Path inputFile, int flag) {
		_fileName = inputFile.getName();
		try {
			FileSystem fs = FileSystem.get(LogUtil.getConfig());
			br = new BufferedReader(new InputStreamReader(new GZIPInputStream(fs.open(inputFile))));
			if (flag == 1) {
				brUser = new BufferedReader(new InputStreamReader(new GZIPInputStream(fs.open(inputFile))));
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public String getFileName() {
		return _fileName;
	}
	
	public BufferedReader getStream() {
		return br;
	}
	
	public BufferedReader getUserStream() {
		return brUser;
	}
	
	public void close() {
		try {
			if (br != null) {
				br.close();
			}
			if (brUser != null) {
				brUser.close();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
package com.boco.wangyou.ltemr.parse.entity;

import com.boco.wangyou.utility.TimeUtils;

public class CommonInfo {
	private String _splitStr = "";
	private String _omcId = "";
	private String _vendorId = "";
	private String _startTime = "";
	private String _endTime = "";
	private String _startTimeStr = "";
	private TimeUtils timeUtils = new TimeUtils();
	
	public CommonInfo(String splitStr) {
		_splitStr = splitStr;
	}
	
	public void setTime(String startTime) {
		_startTimeStr = startTime;
		if (startTime.length() == 13) {
			_startTime = startTime.replace("_", " ") + ":00:00";
			_endTime = timeUtils.getNextHour(_startTime);
		} else {
			_startTime = startTime + " 00:00:00";
			_endTime = timeUtils.getNextDay(_startTime);
		}
	}
	
	public void setId(String fileName) {
		int idx1 = fileName.indexOf("_");
		if (idx1 == -1) {
			return;
		}
		_omcId = fileName.substring(0, idx1);
		
		int idx2 = fileName.indexOf("_", idx1 + 1);
		if (idx2 == -1) {
			return;
		}
		_vendorId = fileName.substring(idx1 + 1, idx2);
	}
	
	public String getLine() {
		return _omcId + _splitStr + _vendorId + _splitStr + _startTime + _splitStr + _endTime;
	}
	
	public String getTimeLine() {
		return _startTime + _splitStr + _endTime + _splitStr + _vendorId;
	}
	
	public String getIdLine() {
		return _omcId + _splitStr + _vendorId;
	}
	
	public String getOmcId() {
		return _omcId;
	}
	
	public String getVendorId() {
		return _vendorId;
	}
	
	public String getStartTime() {
		return _startTime;
	}
	
	public String getEndTime() {
		return _endTime;
	}
	
	public String getStartTimeStr() {
		return _startTimeStr;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mre;

public class GsmNcInfo {
	private int _rssi = -1;
	private String _bcchBsic = "";
	
	public void setValue(int rssi, String bcchBsic) {
		_rssi = rssi;
		_bcchBsic = bcchBsic;
	}
	
	public int getRssi() {
		return _rssi;
	}
	
	public String getBcchBsic() {
		return _bcchBsic;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mre;

public class LteNcInfo {
	private int _rsrp = -1;
	private String _earfcnPci = "";
	
	public void setValue(int rsrp, String earfcnPci) {
		_rsrp = rsrp;
		_earfcnPci = earfcnPci;
	}
	
	public int getRsrp() {
		return _rsrp;
	}
	
	public String getEarfcnPci() {
		return _earfcnPci;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mre.sum;

import com.boco.wangyou.algorithm.counter.RsrpParse;

public class TdlMreAdj {
	private String _splitStr = "";
	private double _distance = 0;
	private int scRsrpLen = 11;
	private int scDiffLen = 11;
	private int[][] scDiffs = new int[scRsrpLen][scDiffLen];
	private int[] diffs = new int[scDiffLen];
	private int ncScOverF6 = 0;
	private int ncScOverF3 = 0;
	private int ncScOverF12 = 0;
	
	public TdlMreAdj(String splitStr, double distance) {
		_splitStr = splitStr;
		_distance = distance;
		
		for (int i = 0; i < scRsrpLen; i++) {
			for (int j = 0; j < scDiffLen; j++) {
				scDiffs[i][j] = 0;
			}
		}
		
		for (int i = 0; i < scDiffLen; i++) {
			diffs[i] = 0;
		}
	}
	
	public void setValue(int scRsrp, int ncRsrp, RsrpParse rsrpParse) {
		if (scRsrp == -1 || ncRsrp == -1) {
			return;
		}
		
		int scRsrpIdx = rsrpParse.getIdxRsrpAdj(scRsrp);
		int diffIdx = rsrpParse.getIdxDiff(scRsrp - ncRsrp);
		
		scDiffs[scRsrpIdx][diffIdx]++;
		diffs[diffIdx]++;
		
		if (diffIdx >= 6) {
			ncScOverF6++;
		}
		if (diffIdx >= 5) {
			ncScOverF3++;
		}
		if (diffIdx >= 9) {
			ncScOverF12++;
		}
	}
	
	public String getDiffLine(StringBuffer line) {
		line.setLength(0);
		line.append(_distance);
		for (int j = 0; j < scDiffLen; j++) {
			for (int i = 0; i < scRsrpLen; i++) {
				line.append(_splitStr).append(scDiffs[i][j]);
			}
		}
		return line.toString();
	}
	
	public String getAdjTdlLine(StringBuffer line) {
		line.setLength(0);
		line.append(_distance);
		for (int i = 0; i < scDiffLen; i++) {
			line.append(_splitStr).append(diffs[i]);
		}
		line.append(_splitStr).append(ncScOverF6).append(_splitStr).append(ncScOverF3).append(_splitStr).append(ncScOverF12);
		return line.toString();
	}
	
	public int getNcScOverF6() {
		return ncScOverF6;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mre.sum;

import java.util.HashSet;
import java.util.Set;

public class TdlMreAdjUser {
	private String _splitStr = "";
	private double _distance = 0;
	private int a3Num = 0;
	private int a4Num = 0;
	private int a5Num = 0;
	private Set<String> a3User = new HashSet<String>(100);
	private Set<String> a4User = new HashSet<String>(100);
	private Set<String> a5User = new HashSet<String>(100);
	private Set<String> a3A4A5User = new HashSet<String>(100);
	private int ncTotalNum = 0;
	
	public TdlMreAdjUser(String splitStr, double distance) {
		_splitStr = splitStr;
		_distance = distance;
	}
	
	public void setValue(String userKey, String eventType) {
		ncTotalNum++;
		if (!"3".equals(eventType) && !"4".equals(eventType) && !"5".equals(eventType)) {
			return;
		}
		
		if ("3".equals(eventType)) {
			a3Num++;
			a3User.add(userKey);
		}
		
		if ("4".equals(eventType)) {
			a4Num++;
			a4User.add(userKey);
		}
		
		if ("5".equals(eventType)) {
			a5Num++;
			a5User.add(userKey);
		}
		a3A4A5User.add(userKey);
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		line.append(_distance).append(_splitStr).append(a3Num).append(_splitStr).append(a4Num).append(_splitStr).append(a5Num).append(_splitStr)
			.append(a3User.size()).append(_splitStr).append(a4User.size()).append(_splitStr).append(a5User.size()).append(_splitStr).append(a3A4A5User.size()).append(_splitStr)
			.append(ncTotalNum);
		return line.toString();
	}
}
package com.boco.wangyou.ltemr.parse.entity.mre.sum;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.boco.wangyou.utility.TimeUtils;

public class TdlMreEutr {
	private List<String> _variableTabs = null;
	private String _splitStr = "";
	private int totalNum = 0;
	private int gsmTotalNum = 0;
	private Set<String> a2User = new HashSet<String>(100);
	private Set<String> a2UserRepeat = new HashSet<String>(100);
	private int a2Num = 0;
	private int a2NumRepeat = 0;
	private int a2RepeatMeasNum = 0;
	private Set<String> a3A4A5User = new HashSet<String>(100);
	private Set<String> a3A4A5UserRepeat = new HashSet<String>(100);
	private int a3A4A5Num = 0;
	private int a3A4A5NumRepeat = 0;
	private int a3A4A5RepeatMeasNum = 0;
	private Map<String, UserInfo> mapUserInfo = new HashMap<String, UserInfo>(100);
	private int repeatNum = 0;
	private TimeUtils timeUtils = new TimeUtils();
	private DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
	
	public TdlMreEutr(List<String> variableTabs, String splitStr) {
		_variableTabs = variableTabs;
		_splitStr = splitStr;
	}
	
	public void setValue(int ncNum, int gsmNcNum, String userKey, String eventType, String timeStamp) {
		if (ncNum > 0) {
			totalNum++;
		}
		
		if (gsmNcNum > 0) {
			gsmTotalNum++;
		}
		
		if (_variableTabs.contains("tdl_mre_repeated_measure")) {
			setRepeatMeas(userKey, eventType, timeStamp);
		}
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		line.append(a2User.size()).append(_splitStr).append(a2UserRepeat.size()).append(_splitStr).append(a2Num).append(_splitStr).append(a2NumRepeat).append(_splitStr).append(a2RepeatMeasNum).append(_splitStr)
			.append(a3A4A5User.size()).append(_splitStr).append(a3A4A5UserRepeat.size()).append(_splitStr).append(a3A4A5Num).append(_splitStr).append(a3A4A5NumRepeat).append(_splitStr).append(a3A4A5RepeatMeasNum);
		return line.toString();
	}
	
	public int getTotalNum() {
		return totalNum;
	}
	
	public int getGsmTotalNum() {
		return gsmTotalNum;
	}
	
	private void setRepeatMeas(String userKey, String eventType, String timeStamp) {
		UserInfo userInfo = null;
		if (mapUserInfo.containsKey(userKey)) {
			userInfo = mapUserInfo.get(userKey);
		} else {
			userInfo = new UserInfo();
		}
		String eventTypeBackup = userInfo.getEventType();
		
		if ("2".equals(eventType)) {
			a2User.add(userKey);
			a2Num++;
			
			if (eventType.equals(eventTypeBackup)) {
				long dt = timeUtils.timeToTicks(timeStamp, df);
				long dtBackUp = timeUtils.timeToTicks(userInfo.getTimeStamp(), df);
				if (dt - dtBackUp <= 3 * 1000) {
					repeatNum++;
				}
			} else {
				if (repeatNum >= 10) {
					a2UserRepeat.add(userKey);
					a2NumRepeat += repeatNum;
					a2RepeatMeasNum++;
				}
				repeatNum = 0;
			}
			userInfo.setValue(eventType, timeStamp);
		}
		
		if ("2".equals(eventType) || "3".equals(eventType) || "4".equals(eventType)) {
			a3A4A5User.add(userKey);
			a3A4A5Num++;
			
			if (eventType.equals(eventTypeBackup)) {
				long dt = timeUtils.timeToTicks(timeStamp, df);
				long dtBackUp = timeUtils.timeToTicks(userInfo.getTimeStamp(), df);
				if (dt - dtBackUp <= 3 * 1000) {
					repeatNum++;
				}
			} else {
				if (repeatNum >= 10) {
					a3A4A5UserRepeat.add(userKey);
					a3A4A5NumRepeat += repeatNum;
					a3A4A5RepeatMeasNum++;
				}
				repeatNum = 0;
			}
			userInfo.setValue(eventType, timeStamp);
		}
	}
}
package com.boco.wangyou.ltemr.parse.entity.mre.sum;

import com.boco.wangyou.algorithm.counter.RsrpParse;
import com.boco.wangyou.algorithm.counter.RssiParse;
import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;

public class TdlMreGsmAdj {
	private String _splitStr = "";
	private String _intId = "";
	private String _bsicBcch = "";
	private String _name = "";
	private double _distance = 0;
	private int rsrpLen = 11;
	private int rssiLen = 10;
	private int[][] rsrpRssis = new int[rsrpLen][rssiLen];
	private int totalNum85 = 0;
	private int totalNum90 = 0;
	private int totalNum95 = 0;
	private int rssiov85Rsrpls85 = 0;
	private int rssiov90Rsrpls90 = 0;
	private int rssiov95Rsrpls95 = 0;
	
	public TdlMreGsmAdj(String splitStr, GsmNcIniInfo ncGsmKey) {
		_splitStr = splitStr;
		_intId = ncGsmKey.getIntId();
		_bsicBcch = ncGsmKey.getBsicBcch();
		_name = ncGsmKey.getName();
		_distance = ncGsmKey.getDistance();
		
		for (int i = 0; i < rsrpLen; i++) {
			for (int j = 0; j < rssiLen; j++) {
				rsrpRssis[i][j] = 0;
			}
		}
	}
	
	public void setValue(int scRsrp, int ncRssi, RsrpParse rsrpParse, RssiParse rssiParse) {
		if (scRsrp == -1 || ncRssi == -1) {
			return;
		}
		
		int rsrpIdx = rsrpParse.getRsrpRssiIdx(scRsrp);
		int rssiIdx = rssiParse.getIdx(ncRssi);
		rsrpRssis[rsrpIdx][rssiIdx]++;
		
		if (scRsrp < -85 + 141 && ncRssi >= -85 + 111) {
			totalNum85++;
		}
		if (scRsrp < -90 + 141 && ncRssi >= -90 + 111) {
			totalNum90++;
		}
		if (scRsrp < -95 + 141 && ncRssi >= -95 + 111) {
			totalNum95++;
		}
		
		if (rsrpIdx <= 6 && rssiIdx >= 6) {
			rssiov85Rsrpls85++;
		}
		if (rsrpIdx <= 5 && rssiIdx >= 5) {
			rssiov90Rsrpls90++;
		}
		if (rsrpIdx <= 4 && rssiIdx >= 4) {
			rssiov95Rsrpls95++;
		}
	}
	
	public String getKeyLine() {
		return _intId + _splitStr + _bsicBcch + _splitStr + _name;
	}
	
	public String getRsrpRssiLine(StringBuffer line) {
		line.setLength(0);
		line.append(_distance).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			for (int j = 0; j < rssiLen; j++) {
				line.append(rsrpRssis[i][j]).append(_splitStr);
			}
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public String getAdjtdlGsmLine(StringBuffer line) {
		line.setLength(0);
		line.append(_distance).append(_splitStr)
			.append(rssiov85Rsrpls85).append(_splitStr).append(rssiov90Rsrpls90).append(_splitStr).append(rssiov95Rsrpls95).append(_splitStr)
			.append(totalNum85).append(_splitStr).append(totalNum90).append(_splitStr).append(totalNum95).append(_splitStr)
			.append(div(rssiov85Rsrpls85, totalNum85)).append(_splitStr).append(div(rssiov90Rsrpls90, totalNum90)).append(_splitStr).append(div(rssiov95Rsrpls95, totalNum95));
		return line.toString();
	}
	
	private double div(int numerator, int denominator) {
		if (denominator == 0) {
			return 0;
		}
		return (double) numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mre.sum;

import java.util.HashSet;
import java.util.Set;

import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;

public class TdlMreGsmAdjUser {
	private String _splitStr = "";
	private String _intId = "";
	private String _bsicBcch = "";
	private String _name = "";
	private double _distance = 0;
	private int b1Num = 0;
	private int b2Num = 0;
	private Set<String> b1User = new HashSet<String>(100);
	private Set<String> b2User = new HashSet<String>(100);
	private Set<String> b1B2User = new HashSet<String>(100);
	
	public TdlMreGsmAdjUser(String splitStr, GsmNcIniInfo ncGsmKey) {
		_splitStr = splitStr;
		_intId = ncGsmKey.getIntId();
		_bsicBcch = ncGsmKey.getBsicBcch();
		_name = ncGsmKey.getName();
		_distance = ncGsmKey.getDistance();
	}
	
	public void setValue(String userKey, String eventType) {
		if (!"7".equals(eventType) && !"8".equals(eventType)) {
			return;
		}
		
		if ("7".equals(eventType)) {
			b1Num++;
			b1User.add(userKey);
		}
		
		if ("8".equals(eventType)) {
			b2Num++;
			b2User.add(userKey);
		}
		b1B2User.add(userKey);
	}
	
	public String getKeyLine() {
		return _intId + _splitStr + _bsicBcch + _splitStr + _name;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		line.append(_distance).append(_splitStr)
			.append(b1Num).append(_splitStr).append(b2Num).append(_splitStr)
			.append(b1User.size()).append(_splitStr).append(b2User.size()).append(_splitStr).append(b1B2User.size());
		return line.toString();
	}
}
package com.boco.wangyou.ltemr.parse.entity.mre.sum;

public class UserInfo {
	private String _eventType = "";
	private String _timeStamp = "";
	
	public void setValue(String eventType, String timeStamp) {
		_eventType = eventType;
		_timeStamp = timeStamp;
	}
	
	public String getEventType() {
		return _eventType;
	}
	
	public String getTimeStamp() {
		return _timeStamp;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mre;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.SmrValue;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;
import com.boco.wangyou.utility.ini.entity.LteIniInfo;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;

public class TdlMreBaseData {
	private int lteScRsrp = -1;
	private List<LteNcInfo> lteNcList = new ArrayList<LteNcInfo>(20);
	private List<String> earfcnPciList = new ArrayList<String>(20);
	private List<GsmNcInfo> gsmNcList = new ArrayList<GsmNcInfo>(20);
	private SmrValue _smr = null;
	private String _splitStr = "";
	
	public TdlMreBaseData(SmrValue smr, String splitStr) {
		_splitStr = splitStr;
		_smr = smr;
	}
	
	public void setValue(String[] valueItems, MrIdxInfo idxInfo, int len, LteIniInfo iniInfo) {
		if (len != idxInfo.getLen()) {
			return;
		}
		
		setScValue(valueItems, idxInfo, len, iniInfo);
		setNcValue(valueItems, idxInfo, len);
	}
	
	public void setNcValue(String[] valueItems, MrIdxInfo idxInfo, int len) {
		if (len != idxInfo.getLen()) {
			return;
		}
		
		int ncRsrp = Integer.parseInt(_smr.getValue("ltencrsrp", valueItems, idxInfo, len));
		if (ncRsrp != -1) {
			makeNcRsrpValue(valueItems, idxInfo, ncRsrp, len);
		}
		
		int ncRssi = Integer.parseInt(_smr.getValue("gsmncellcarrierrssi", valueItems, idxInfo, len));
		if (ncRssi != -1) {
			makeNcRssiValue(valueItems, idxInfo, ncRssi, len);
		}
	}
	
	public List<LteNcIniInfo> getNcCells(String cellKey, IniParseDomain iniParse, Map<String, LteNcIniInfo> iniInfoMap) {
		List<LteNcIniInfo> ncCells = new ArrayList<LteNcIniInfo>(20);
		int len = lteNcList.size();
		for (int i = 0; i < len; i++) {
			LteNcIniInfo ncIniInfo = iniParse.getAdjNcell(cellKey, lteNcList.get(i).getEarfcnPci(), iniInfoMap);
			ncCells.add(ncIniInfo);
		}
		return ncCells;
	}
	
	public List<GsmNcIniInfo> getNcGsmCells(String cellKey, IniParseDomain iniParse, Map<String, GsmNcIniInfo> gsmIniInfoMap) {
		List<GsmNcIniInfo> ncCells = new ArrayList<GsmNcIniInfo>(20);
		int len = gsmNcList.size();
		for (int i = 0; i < len; i++) {
			GsmNcIniInfo gsmInfo = iniParse.getGsmAdjNcell(cellKey, gsmNcList.get(i).getBcchBsic(), gsmIniInfoMap);
			ncCells.add(gsmInfo);
		}
		return ncCells;
	}
	
	public int getScRsrp() {
		return lteScRsrp;
	}
	
	public LteNcInfo getLteNcInfo(int idx) {
		if (idx < 0 || idx > lteNcList.size()) {
			return new LteNcInfo();
		}
		return lteNcList.get(idx);
	}
	
	public GsmNcInfo getGsmNcInfo(int idx) {
		if (idx < 0 || idx > gsmNcList.size()) {
			return new GsmNcInfo();
		}
		return gsmNcList.get(idx);
	}
	
	private void setScValue(String[] valueItems, MrIdxInfo idxInfo, int len, LteIniInfo iniInfo) {
		lteScRsrp = Integer.parseInt(_smr.getValue("ltescrsrp", valueItems, idxInfo, len));
		String lteScEarfcn = _smr.getValue("ltescearfcn", valueItems, idxInfo, len);
		String lteScPci = _smr.getValue("ltescpci", valueItems, idxInfo, len);
		if (("-1".equals(lteScEarfcn) || "-1".equals(lteScPci)) && !"".equals(iniInfo.getEarfcn()) && !"".equals(iniInfo.getPci())) {
			lteScEarfcn = iniInfo.getEarfcn();
			lteScPci = iniInfo.getPci();
		}
		earfcnPciList.add(lteScEarfcn + _splitStr + lteScPci);
	}
	
	private void makeNcRsrpValue(String[] valueItems, MrIdxInfo idxInfo, int ncRsrp, int len) {
		String ncEarfcn = _smr.getValue("ltencearfcn", valueItems, idxInfo, len);
		String ncPci = _smr.getValue("ltencpci", valueItems, idxInfo, len);
		if ("-1".equals(ncEarfcn) || "-1".equals(ncPci)) {
			return;
		}
		
		String ncEarfcnPci = ncEarfcn + _splitStr + ncPci;
		if (earfcnPciList.contains(ncEarfcnPci)) {
			return;
		}
		earfcnPciList.add(ncEarfcnPci);
		
		LteNcInfo lteNcInfo = new LteNcInfo();
		lteNcInfo.setValue(ncRsrp, ncEarfcnPci);
		lteNcList.add(lteNcInfo);
	}
	
	private void makeNcRssiValue(String[] valueItems, MrIdxInfo idxInfo, int rssi, int len) {
		String ncc = _smr.getValue("gsmncellncc", valueItems, idxInfo, len);
		String bcc = _smr.getValue("gsmncellbcc", valueItems, idxInfo, len);
		String bcch = _smr.getValue("gsmncellbcch", valueItems, idxInfo, len);
		if ("-1".equals(ncc) || "-1".equals(bcc) || "-1".equals(bcch)) {
			return;
		}
		
		String bcchBsic = ncc + _splitStr + bcc + _splitStr + bcch;
		if (gsmNcList.contains(bcchBsic)) {
			return;
		}
		
		GsmNcInfo gsmNcInfo = new GsmNcInfo();
		gsmNcInfo.setValue(rssi, bcchBsic);
		gsmNcList.add(gsmNcInfo);
	}
}
package com.boco.wangyou.ltemr.parse.entity.mre;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.boco.wangyou.algorithm.counter.RsrpParse;
import com.boco.wangyou.algorithm.counter.RssiParse;
import com.boco.wangyou.ltemr.parse.entity.mre.sum.TdlMreAdjUser;
import com.boco.wangyou.ltemr.parse.entity.mre.sum.TdlMreEutr;
import com.boco.wangyou.ltemr.parse.entity.mre.sum.TdlMreGsmAdj;
import com.boco.wangyou.ltemr.parse.entity.mre.sum.TdlMreAdj;
import com.boco.wangyou.ltemr.parse.entity.mre.sum.TdlMreGsmAdjUser;
import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;

public class TdlMreData {
	private TdlMreEutr tdlMreEutr = null;
	private Map<String, Map<String, TdlMreAdj>> mapAdj = new HashMap<String, Map<String, TdlMreAdj>>(200);
	private Map<String, Map<String, TdlMreGsmAdj>> mapGsmAdj = new HashMap<String, Map<String, TdlMreGsmAdj>>(200);
	private Map<String, TdlMreAdjUser> mapAdjUser = new HashMap<String, TdlMreAdjUser>(200);
	private Map<String, TdlMreGsmAdjUser> mapGsmAdjUser = new HashMap<String, TdlMreGsmAdjUser>(200);
	private String _splitStr = "";
	private RsrpParse rsrpParse = new RsrpParse();
	private RssiParse rssiParse = new RssiParse();
	
	public TdlMreData(List<String> variableTabs, String splitStr) {
		tdlMreEutr = new TdlMreEutr(variableTabs, splitStr);
		
		_splitStr = splitStr;
	}
	
	public void makeEutrInfo(int ncNum, int gsmNcNum, String userKey, String eventType, String timeStamp) {
		tdlMreEutr.setValue(ncNum, gsmNcNum, userKey, eventType, timeStamp);
	}
	
	public void makeAdjInfo(LteNcIniInfo ncKey, TdlMreBaseData base, String eventType, int idx) {
		int scRsrp = base.getScRsrp();
		int ncRsrp = base.getLteNcInfo(idx).getRsrp();
		String ncCellKey = ncKey.getCellId();
		Map<String, TdlMreAdj> mapAdjEvent = null;
		TdlMreAdj tdlMreAdj = null;
		if (mapAdj.containsKey(ncCellKey)) {
			mapAdjEvent = mapAdj.get(ncCellKey);
			if (mapAdjEvent.containsKey(eventType)) {
				tdlMreAdj = mapAdjEvent.get(eventType);
			} else {
				tdlMreAdj = new TdlMreAdj(_splitStr, ncKey.getDistance());
			}
		} else {
			mapAdjEvent = new HashMap<String, TdlMreAdj>(10);
			tdlMreAdj = new TdlMreAdj(_splitStr, ncKey.getDistance());
		}
		tdlMreAdj.setValue(scRsrp, ncRsrp, rsrpParse);
		mapAdjEvent.put(eventType, tdlMreAdj);
		mapAdj.put(ncCellKey, mapAdjEvent);
	}
	
	public void makeAdjUserInfo(LteNcIniInfo ncKey, String userKey, String eventType) {
		String ncCellKey = ncKey.getCellId();
		TdlMreAdjUser tdlMreAdjUser = null;
		if (mapAdjUser.containsKey(ncCellKey)) {
			tdlMreAdjUser = mapAdjUser.get(ncCellKey);
		} else {
			tdlMreAdjUser = new TdlMreAdjUser(_splitStr, ncKey.getDistance());
		}
		tdlMreAdjUser.setValue(userKey, eventType);
		mapAdjUser.put(ncCellKey, tdlMreAdjUser);
	}
	
	public void makeGsmAdjInfo(GsmNcIniInfo ncGsmKey, TdlMreBaseData base, String eventType, int idx) {
		int scRsrp = base.getScRsrp();
		int ncRssi = base.getGsmNcInfo(idx).getRssi();
		String adjKey = ncGsmKey.getCellId();
		Map<String, TdlMreGsmAdj> mapGsmAdjEvent = null;
		TdlMreGsmAdj tdlMreGsmAdj = null;
		if (mapGsmAdj.containsKey(adjKey)) {
			mapGsmAdjEvent = mapGsmAdj.get(adjKey);
			if (mapGsmAdjEvent.containsKey(eventType)) {
				tdlMreGsmAdj = mapGsmAdjEvent.get(eventType);
			} else {
				tdlMreGsmAdj = new TdlMreGsmAdj(_splitStr, ncGsmKey);
			}
		} else {
			mapGsmAdjEvent = new HashMap<String, TdlMreGsmAdj>(10);
			tdlMreGsmAdj = new TdlMreGsmAdj(_splitStr, ncGsmKey);
		}
		tdlMreGsmAdj.setValue(scRsrp, ncRssi, rsrpParse, rssiParse);
		mapGsmAdjEvent.put(eventType, tdlMreGsmAdj);
		mapGsmAdj.put(adjKey, mapGsmAdjEvent);
	}
	
	public void makeGsmAdjUserInfo(GsmNcIniInfo ncGsmKey, String userKey, String eventType) {
		String adjKey = ncGsmKey.getCellId();
		TdlMreGsmAdjUser tdlMreGsmAdjUser = null;
		if (mapGsmAdjUser.containsKey(adjKey)) {
			tdlMreGsmAdjUser = mapGsmAdjUser.get(adjKey);
		} else {
			tdlMreGsmAdjUser = new TdlMreGsmAdjUser(_splitStr, ncGsmKey);
		}
		tdlMreGsmAdjUser.setValue(userKey, eventType);
		mapGsmAdjUser.put(adjKey, tdlMreGsmAdjUser);
	}
	
	public TdlMreEutr getEutr() {
		return tdlMreEutr;
	}
	
	public Map<String, Map<String, TdlMreAdj>> getAdj() {
		return mapAdj;
	}
	
	public Map<String, Map<String, TdlMreGsmAdj>> getGsmAdj() {
		return mapGsmAdj;
	}
	
	public Map<String, TdlMreAdjUser> getAdjUser() {
		return mapAdjUser;
	}
	
	public Map<String, TdlMreGsmAdjUser> getGsmAdjUser() {
		return mapGsmAdjUser;
	}
}
package com.boco.wangyou.ltemr.parse.entity;

import java.util.ArrayList;
import java.util.List;

public class MrIdxInfo {
	private int len = 0;
	private List<String> mapIdx = new ArrayList<String>();
	private int dataFlag = 0;
	
	public void setIdx(String[] smr) {
		mapIdx.clear();
		len = smr.length;
		for (int i = 0; i < len; i++) {
			String col = smr[i].replace("mr.", "");
			mapIdx.add(col);
		}
	}
	
	public void setFlag() {
		if (mapIdx.contains("ltescrsrp")) {
			dataFlag = 1;
		} else if (mapIdx.contains("ltescplrulqci1")) {
			dataFlag = 2;
		} else if (mapIdx.contains("ltescrip")) {
			dataFlag = 3;
		}
	}
	
	public int getIdx(String key) {
		if (mapIdx.contains(key)) {
			return mapIdx.indexOf(key);
		}
		return -1;
	}
	
	public boolean judgeKey(String key) {
		if (mapIdx.contains(key)) {
			return true;
		}
		return false;
	}
	
	public int getLen() {
		return len;
	}
	
	public int getDataFlag() {
		return dataFlag;
	}
}
package com.boco.wangyou.ltemr.parse.entity;

import java.util.HashMap;
import java.util.Map;

public class MrKeyInfo {
	private String _mmeCode = "";
	private String _mmeGroupId = "";
	private String _mmeUeS1apId = "";
	private String _timeStamp = "";
	private String _id = "";
	private String _eventType = "";
	private String _subFrame = "";
	private String _splitStr = "";
	
	@SuppressWarnings("serial")
	private final Map<String, String> eventTypeValue = new HashMap<String, String>() {{
		put("a1", "1");
		put("a2", "2");
		put("a3", "3");
		put("a4", "4");
		put("a5", "5");
		put("a6", "6");
		put("b1", "7");
		put("b1", "8");
	}};
	
	public MrKeyInfo(String splitStr) {
		_splitStr = splitStr;
	}
	
	public void setObject(String mmeCode, String mmeGroupId, String mmeUeS1apId, String timeStamp, String id, String enodebId, String eventType) {
		_mmeCode = mmeCode;
		_mmeGroupId = mmeGroupId;
		_mmeUeS1apId = mmeUeS1apId;
		_timeStamp = timeStamp;
		_id = getObjCellId(id, enodebId);
		_eventType = (eventTypeValue.containsKey(eventType)) ? eventTypeValue.get(eventType) : "";
	}
	
	public String getMroKey() {
		return _mmeCode + _splitStr + _mmeGroupId + _splitStr + _mmeUeS1apId + _splitStr + _id;
	}
	
	public String getMreKey() {
		return _mmeCode + _splitStr + _mmeGroupId + _splitStr + _mmeUeS1apId + _splitStr + _id + _splitStr + _eventType;
	}
	
	public String getUserKey() {
		return _mmeCode + _splitStr + _mmeGroupId + _splitStr + _mmeUeS1apId;
	}
	
	public String getTimeStamp() {
		return _timeStamp;
	}
	
	public String getCell() {
		return _id;
	}
	
	public String getSubFrame() {
		return _subFrame;
	}
	
	public String getEventType() {
		return _eventType;
	}
	
	private String getObjCellId(String id, String enodebId) {
		if (id.contains(":")) {
			int idx = id.indexOf(":");
			_subFrame = id.substring(idx + 1, id.length()).replace(":", _splitStr);
			id = id.substring(0, idx);
		}
		
		if (id.contains("-")) {
			return id.replace("-", _splitStr);
		} else if (Integer.parseInt(id) < 256) {
			return enodebId + _splitStr + id;
		}
		long cellId = Long.parseLong(id);
		return String.valueOf(cellId / 256) + _splitStr + String.valueOf(cellId % 256);
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro;

public class LteNcInfo {
	private int _rsrp = -1;
	private String _earfcnPci = "";
	private int _freq = -1;
	private int _freqBand = -1;
	private int _isp = -1;
	
	public void setValue(int rsrp, String earfcnPci, int freq, int freqBand, int isp) {
		_rsrp = rsrp;
		_earfcnPci = earfcnPci;
		_freq = freq;
		_freqBand = freqBand;
		_isp = isp;
	}
	
	public int getRsrp() {
		return _rsrp;
	}
	
	public String getEarfcnPci() {
		return _earfcnPci;
	}
	
	public int getFreq() {
		return _freq;
	}
	
	public int getFreqBand() {
		return _freqBand;
	}
	
	public int getIsp() {
		return _isp;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import com.boco.wangyou.algorithm.depthcoverage.RsrpMethod;
import com.boco.wangyou.algorithm.depthcoverage.TaAoaMethod;
import com.boco.wangyou.algorithm.depthcoverage.fingerprint.FingerPrint;
import com.boco.wangyou.algorithm.depthcoverage.fingerprint.FingerPrintParse;
import com.boco.wangyou.algorithm.depthcoverage.militarygrid.MilitaryGrid;
import com.boco.wangyou.utility.cfg.ConfigConstants;
import com.boco.wangyou.utility.grid.GridInfo;
import com.boco.wangyou.utility.ini.domainmodel.IniParseDomain;
import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;
import com.boco.wangyou.utility.ini.entity.LteIniInfo;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;

public class MroGridInfo {
	private String gridId = "";
	private String gridLatLonLDRU = "";
	private String geoHash = "";
	private String[] gridIds = new String[7];
	private String[] gridLatLonLDRUs = new String[7];
	private String[] geoHashs = new String[7];
	private double latitude = 0;
	private double longitude = 0;
	private int locateCategory = -1;
	private int _userType = -1;
	private List<LteNcIniInfo> ncCells = new ArrayList<LteNcIniInfo>(20);
	private List<Integer> _overlapCondi1 = new ArrayList<Integer>(20);
	private List<Integer> _overlapCondi2 = new ArrayList<Integer>(20);
	private List<GsmNcIniInfo> gsmList = new ArrayList<GsmNcIniInfo>(20);
	private double _middleLongitude = 0;
	private String _coordinateMethod = null;
	private boolean _clockwiseFlag = false;
	private boolean _adjustFlag = false;
	private int _tadvThreshold = 0;
	private List<Integer> gridSize = new ArrayList<Integer>();
	private String _splitStr = "";
	
	public MroGridInfo(ConfigConstants cfgInfo, String vendorId, String splitStr) {
		_middleLongitude = Double.parseDouble(cfgInfo.getValue("MIDDLE_LONGITUDE", "120"));
		_coordinateMethod = cfgInfo.getValue("COORDINATE_METHOD", "").toUpperCase();
		_clockwiseFlag = getFlag(cfgInfo.getValue("CLOCKWISE_AOA_VENDOR", ""), vendorId);
		_adjustFlag = getFlag(cfgInfo.getValue("ADJUST_AOA_VENDOR", ""), vendorId);
		_tadvThreshold = Integer.parseInt(cfgInfo.getValue("TADV_THRESHOLD", "0"));
		gridSize = cfgInfo.getInts("GRID_LENGTH_LIST");
		_splitStr = splitStr;
		
		gridLatLonLDRU = _splitStr + _splitStr + _splitStr + _splitStr + _splitStr + _splitStr + _splitStr;
		for (int i = 0; i < 7; i++) {
			gridIds[i] = "";
			gridLatLonLDRUs[i] = _splitStr + _splitStr + _splitStr + _splitStr + _splitStr + _splitStr + _splitStr;
			geoHashs[i] = "";
		}
	}
	
	public void setUserType(int userType) {
		_userType = userType;
	}
	
	public void makeGrid(TdlMroGridUe gridUe, String cellKey, IniParseDomain iniParse, FingerPrintParse fingerPrintParse, Map<String, GridInfo> gridInfoMap, Map<String, LteNcIniInfo> iniInfoMap, Map<String, GsmNcIniInfo> gsmIniInfoMap) {
		List<LteNcInfo> lteNcList = gridUe.getLteNcList();
		int len = lteNcList.size();
		for (int i = 0; i < len; i++) {
			LteNcIniInfo ncIniInfo = iniParse.getAdjNcell(cellKey, lteNcList.get(i).getEarfcnPci(), iniInfoMap);
			ncCells.add(ncIniInfo);
		}
		
		List<String> ncBcchBsics = gridUe.getNcBcchBsicList();
		int gsmLen = ncBcchBsics.size();
		for (int i = 0; i < gsmLen; i++) {
			GsmNcIniInfo gsmInfo = iniParse.getGsmAdjNcell(cellKey, ncBcchBsics.get(i), gsmIniInfoMap);
			gsmList.add(gsmInfo);
		}
		
		setOverlap(gridUe.getRsrp(), lteNcList);
		setGrid(gridUe, cellKey, iniParse, fingerPrintParse, lteNcList, gridInfoMap);
	}
	
	public String getGridLine(StringBuffer line) {
		line.setLength(0);
		line.append(getGrid());
		for (int i = 0; i < 7; i++) {
			line.append(_splitStr).append(getGrids(i));
		}
		return line.toString();
	}
	
	public String getLatLon() {
		return String.format("%.8f", latitude) + _splitStr + String.format("%.8f", longitude);
	}
	
	public String getUserInfo() {
		return _userType + _splitStr + locateCategory + _splitStr + "-9999";
	}
	
	public String getGridId() {
		return gridId;
	}
	
	public String getGridIds(int idx) {
		if (idx >= 7) {
			return "";
		}
		return gridIds[idx];
	}
	
	public int getLocateCategory() {
		return locateCategory;
	}
	
	public List<LteNcIniInfo> getNcCells() {
		return ncCells;
	}
	
	public int getUserType() {
		return _userType;
	}
	
	public int getOverlapCondi1(int i) {
		if (i < 0 || i >= _overlapCondi1.size()) {
			return 0;
		}
		return _overlapCondi1.get(i);
	}
	
	public int getOverlapCondi2(int i) {
		if (i < 0 || i >= _overlapCondi2.size()) {
			return 0;
		}
		return _overlapCondi2.get(i);
	}
	
	public List<GsmNcIniInfo> getGsmList() {
		return gsmList;
	}
	
	public int getSizeIdx(int size) {
		return gridSize.indexOf(size);
	}
	
	private String getGrid() {
		return gridId + _splitStr + gridLatLonLDRU + _splitStr + geoHash;
	}
	
	private String getGrids(int idx) {
		if (idx >= 7) {
			return _splitStr + _splitStr + _splitStr + _splitStr + _splitStr + _splitStr + _splitStr + _splitStr + _splitStr;
		}
		return gridIds[idx] + _splitStr + gridLatLonLDRUs[idx] + _splitStr + geoHashs[idx];
	}
	
	private boolean getFlag(String vendorList, String vendorId) {
		List<String> vendors = Arrays.asList(vendorList.split(","));
		if (vendors.contains(vendorId)) {
			return true;
		}
		return false;
	}
	
	private void setOverlap(int scRsrp, List<LteNcInfo> lteNcList) {
		if (scRsrp == -1) {
			return;
		}
		
		boolean overlapCondi1 = false;
		boolean overlapCondi2 = false;
		int len = lteNcList.size();
		if (len >= 4) {
			for (int  i = 0; i < len; i++) {
				if (Math.abs(scRsrp - lteNcList.get(i).getRsrp()) < 6) {
					overlapCondi2 = true;
					overlapCondi1 = true;
					break;
				}
			}
		} else if (len == 3) {
			overlapCondi1 = true;
		}
		
		for (int i = 0; i < len; i++) {
			if (overlapCondi2) {
				if (Math.abs(scRsrp - lteNcList.get(i).getRsrp()) < 6) {
					_overlapCondi1.add(1);
					_overlapCondi2.add(1);
				} else {
					_overlapCondi1.add(0);
					_overlapCondi2.add(0);
				}
			} else if (overlapCondi1) {
				if (Math.abs(scRsrp - lteNcList.get(i).getRsrp()) < 6) {
					_overlapCondi1.add(1);
					_overlapCondi2.add(0);
				} else {
					_overlapCondi1.add(0);
					_overlapCondi2.add(0);
				}
			}
		}
	}
	
	private void setGrid(TdlMroGridUe gridUe, String cellKey, IniParseDomain iniParse, FingerPrintParse fingerPrintParse, List<LteNcInfo> lteNcList, Map<String, GridInfo> gridInfoMap) {
		LteIniInfo iniInfo = iniParse.getLteIniInfo(cellKey);
		if (fingerPrintParse != null) {
			List<String> cellList = new ArrayList<String>();
			List<Integer> rsrpList = new ArrayList<Integer>();
			cellList.add(cellKey);
			rsrpList.add(gridUe.getRsrp() - 141);
			int len = lteNcList.size();
			for (int i = 0; i < len; i++) {
				cellList.add(ncCells.get(i).getCellId());
				rsrpList.add(lteNcList.get(i).getRsrp() - 141);
			}
			FingerPrint gridInfo = fingerPrintParse.getGridInfo(cellList, rsrpList);
			if (!"".equals(gridInfo.getGridId())) {
				latitude = gridInfo.getLatitude();
				longitude = gridInfo.getLongitude();
				locateCategory = 1;
				makeGridId(gridInfoMap);
				return;
			}
		}
		
		if (Math.abs(iniInfo.getLatitude()) < 0.00001 || Math.abs(iniInfo.getLongitude()) < 0.00001 || "".equals(_coordinateMethod)) {
			return;
		}
		
		int lteScTadv = gridUe.getLteScTadv();
		int lteScAoa = gridUe.getLteScAoa();
		if (lteScTadv != -1 && lteScAoa != -1 && !"RSRP".equals(_coordinateMethod)) {
			TaAoaMethod coverageTaAoa = new TaAoaMethod(iniInfo, lteScTadv, lteScAoa, _middleLongitude, _clockwiseFlag, _adjustFlag);
			if (coverageTaAoa.setCoverage()) {
				latitude = coverageTaAoa.getLatitude();
				longitude = coverageTaAoa.getLongitude();
				locateCategory = 3;
				makeGridId(gridInfoMap);
				return;
			}
		}
		
		if (locateCategory == -1 && !"TAAOA".equals(_coordinateMethod)) {
			int lteScRsrp = gridUe.getRsrp();
			RsrpMethod coverageRsrp = new RsrpMethod(_middleLongitude, _tadvThreshold);
			coverageRsrp.setCoverage(iniInfo, lteScRsrp, ncCells, iniParse);
			latitude = coverageRsrp.getLatitude();
			longitude = coverageRsrp.getLongitude();
			locateCategory = 2;
			makeGridId(gridInfoMap);
		}
	}
	
	private void makeGridId(Map<String, GridInfo> gridInfoMap) {
		if (Math.abs(latitude) > 0.00001 && Math.abs(longitude) > 0.00001) {
			MilitaryGrid militaryGrid = new MilitaryGrid(_splitStr);
			militaryGrid.setMilitaryGridId(latitude, longitude, 50, gridInfoMap);
			gridId = militaryGrid.getGridId();
			gridLatLonLDRU = militaryGrid.getGridLatLonLDRU();
			geoHash = militaryGrid.getGeoHashValue();
			
			int idx = 0;
			for (int size : gridSize) {
				if (size == 50) {
					continue;
				}
				militaryGrid.setMilitaryGridId(latitude, longitude, (double) size, gridInfoMap);
				gridIds[idx] = militaryGrid.getGridId();
				gridLatLonLDRUs[idx] = militaryGrid.getGridLatLonLDRU();
				geoHashs[idx] = militaryGrid.getGeoHashValue();
				
				idx++;
				if (idx >= 7) {
					break;
				}
			}
		}
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro.sum;

import java.util.List;

import com.boco.wangyou.algorithm.counter.RsrpParse;
import com.boco.wangyou.ltemr.parse.entity.mro.MroGridInfo;
import com.boco.wangyou.ltemr.parse.entity.mro.TdlMroGridUe;

public class TdlMroAdj {
	private List<String> _variableTabs = null;
	private String _splitStr = "";
	private int _rsrpWeak = 0;
	private double _distance = 0;
	private int scRsrpLen = 11;
	private int scDiffLen = 11;
	private int ncRsrpLen = 11;
	private int[][] scDiffs = new int[scRsrpLen][scDiffLen];
	private int[] diffs = new int[scDiffLen];
	private int[] ncRsrps = new int[ncRsrpLen];
	private int[][] scDiffFreqs = new int[scRsrpLen][scDiffLen];
	private int[] diffFreqs = new int[scDiffLen];
	private int[] ncRsrpFreqs = new int[ncRsrpLen];
	private int[][] scDiffFreqBands = new int[scRsrpLen][scDiffLen];
	private int[] diffFreqBands = new int[scDiffLen];
	private int[] ncRsrpFreqBands = new int[ncRsrpLen];
	private int ncTotalNum = 0;
	private int ncTotalNumFreq = 0;
	private int ncTotalNumFreqBand = 0;
	private int freq = -1;
	private int freqBand = -1;
	private int[] ncScOverF6 = new int[3];
	private int[] ncScOverF3 = new int[3];
	private int[] ncScOverF12 = new int[3];
	private double tdlRscpSc = 0;
	private int tdlRscpScCnt = 0;
	private double tdlRscpNc = 0;
	private int tdlRscpNcCnt = 0;
	private int tdlTim = 0;
	private int tdlTimAlone = 0;
	private int tdlTimMax = 0;
	private double dlTimNcRsrp = 0;
	private int nrsrpThresholdCount = 0;
	private int overlapCount1 = 0;
	private int overlapCount2 = 0;
	private double tdlRscpNcOverlapCondi1 = 0;
	private double tdlRscpNcOverlapCondi2 = 0;
	private int tdlTimLen = 6;
	private int[] tdlTims = new int[tdlTimLen];
	private int[] tdlTimNcRsrps = new int[tdlTimLen];
	private int[] tdlTimOverlapCondi1 = new int[tdlTimLen];
	private int[] tdlTimNcRsrpOverlapCondi1 = new int[tdlTimLen];
	private int[] tdlTimOverlapCondi2 = new int[tdlTimLen];
	private int[] tdlTimNcRsrpOverlapCondi2 = new int[tdlTimLen];
	private double scRsrpSum = 0;
	private int rsrpDiffAbsSum = 0;
	private int rsrpAllLen = 98;
	private int[] ncRsrpAlls = new int[rsrpAllLen];
	private double ncRsrpAllSum = 0;
	private int ncRsrpAllCnt = 0;
	private int ncNeType = -1;
	
	public TdlMroAdj(List<String> variableTabs, String splitStr, int rsrpWeak, double distance) {
		_variableTabs = variableTabs;
		_splitStr = splitStr;
		_rsrpWeak = rsrpWeak;
		_distance = distance;
		
		for (int i = 0; i < scRsrpLen; i++) {
			for (int j = 0; j < scDiffLen; j++) {
				scDiffs[i][j] = 0;
				scDiffFreqs[i][j] = 0;
				scDiffFreqBands[i][j] = 0;
			}
		}
		
		for (int i = 0; i < scDiffLen; i++) {
			diffs[i] = 0;
			diffFreqs[i] = 0;
			diffFreqBands[i] = 0;
		}
		
		for (int i = 0; i < ncRsrpLen; i++) {
			ncRsrps[i] = 0;
			ncRsrpFreqs[i] = 0;
			ncRsrpFreqBands[i] = 0;
		}
		
		for (int i = 0; i < 3; i++) {
			ncScOverF6[i] = 0;
			ncScOverF3[i] = 0;
			ncScOverF12[i] = 0;
		}
		
		for (int i = 0; i < tdlTimLen; i++) {
			tdlTims[i] = 0;
			tdlTimNcRsrps[i] = 0;
			tdlTimOverlapCondi1[i] = 0;
			tdlTimNcRsrpOverlapCondi1[i] = 0;
			tdlTimOverlapCondi2[i] = 0;
			tdlTimNcRsrpOverlapCondi2[i] = 0;
		}
		
		for (int i = 0; i < rsrpAllLen; i++) {
			ncRsrpAlls[i] = 0;
		}
	}
	
	public void setValue(TdlMroGridUe gridUe, MroGridInfo gridInfo, int idx, RsrpParse rsrpParse) {
		int scRsrp = gridUe.getRsrp();
		int ncRsrp = gridUe.getNcRsrp(idx);
		int isp = gridUe.getNcIsp(idx);
		if ((_variableTabs.contains("tdl_mro_diff") || _variableTabs.contains("tdl_mro_adjtdl")) && isp == 0 && scRsrp >= 31) {
			setDiffAdj(scRsrp, ncRsrp, 0, rsrpParse);
			ncTotalNum++;
		}
		
		if (_variableTabs.contains("tdl_mro_diff_freq") || _variableTabs.contains("tdl_mro_adjtdl_freq") && isp == 0 && scRsrp >= 31) {
			freq = gridUe.getScFreq();
			if (freq == gridUe.getNcFreq(idx)) {
				setDiffAdj(scRsrp, ncRsrp, 1, rsrpParse);
				ncTotalNumFreq++;
			}
		}
		
		if (_variableTabs.contains("tdl_mro_diff_freqband") || _variableTabs.contains("tdl_mro_adjtdl_freqband") && isp == 0 && scRsrp >= 31) {
			freqBand = gridUe.getScFreqBand();
			if (freqBand == gridUe.getNcFreqBand(idx)) {
				setDiffAdj(scRsrp, ncRsrp, 2, rsrpParse);
				ncTotalNumFreqBand++;
			}
		}
		
		if (_variableTabs.contains("tdl_mro_pol_adj")) {
			setPolAdj(scRsrp, ncRsrp, isp, gridInfo, idx, rsrpParse);
		}
	}
	
	public String getDiffLine(StringBuffer line) {
		line.setLength(0);
		line.append(_distance).append(_splitStr);
		for (int j = 0; j < scDiffLen; j++) {
			for (int i = 0; i < scRsrpLen; i++) {
				line.append(scDiffs[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < ncRsrpLen; i++) {
			line.append(ncRsrps[i]).append(_splitStr);
		}
		line.append(ncTotalNum);
		return line.toString();
	}
	
	public String getDiffFreqLine(StringBuffer line) {
		line.setLength(0);
		line.append(freq).append(_splitStr).append(_distance).append(_splitStr);
		for (int j = 0; j < scDiffLen; j++) {
			for (int i = 0; i < scRsrpLen; i++) {
				line.append(scDiffFreqs[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < ncRsrpLen; i++) {
			line.append(ncRsrpFreqs[i]).append(_splitStr);
		}
		line.append(ncTotalNumFreq);
		return line.toString();
	}
	
	public String getDiffFreqBandLine(StringBuffer line) {
		line.setLength(0);
		line.append(freqBand).append(_splitStr).append(_distance).append(_splitStr);
		for (int j = 0; j < scDiffLen; j++) {
			for (int i = 0; i < scRsrpLen; i++) {
				line.append(scDiffFreqBands[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < ncRsrpLen; i++) {
			line.append(ncRsrpFreqBands[i]).append(_splitStr);
		}
		line.append(ncTotalNumFreqBand);
		return line.toString();
	}
	
	public String getAdjTdlLine(StringBuffer line) {
		line.setLength(0);
		line.append(_distance).append(_splitStr);
		for (int i = 0; i < scDiffLen; i++) {
			line.append(diffs[i]).append(_splitStr);
		}
		line.append(ncTotalNum).append(_splitStr).append(ncScOverF6[0]).append(_splitStr).append(ncScOverF3[0]).append(_splitStr).append(ncScOverF12[0]);
		for (int i = 0; i < ncRsrpLen; i++) {
			line.append(_splitStr).append(ncRsrps[i]);
		}
		return line.toString();
	}
	
	public String getAdjTdlFreqLine(StringBuffer line) {
		line.setLength(0);
		line.append(freq).append(_splitStr).append(_distance).append(_splitStr);
		for (int i = 0; i < scDiffLen; i++) {
			line.append(diffFreqs[i]).append(_splitStr);
		}
		line.append(ncTotalNumFreq).append(_splitStr).append(ncScOverF6[1]).append(_splitStr).append(ncScOverF3[1]).append(_splitStr).append(ncScOverF12[1]);
		for (int i = 0; i < ncRsrpLen; i++) {
			line.append(_splitStr).append(ncRsrpFreqs[i]);
		}
		return line.toString();
	}
	
	public String getAdjTdlFreqBandLine(StringBuffer line) {
		line.setLength(0);
		line.append(freqBand).append(_splitStr).append(_distance).append(_splitStr);
		for (int i = 0; i < scDiffLen; i++) {
			line.append(diffFreqBands[i]).append(_splitStr);
		}
		line.append(ncTotalNumFreqBand).append(_splitStr).append(ncScOverF6[2]).append(_splitStr).append(ncScOverF3[2]).append(_splitStr).append(ncScOverF12[2]);
		for (int i = 0; i < ncRsrpLen; i++) {
			line.append(_splitStr).append(ncRsrpFreqBands[i]);
		}
		return line.toString();
	}
	
	public String getPolAdjLine(StringBuffer line) {
		line.setLength(0);
		line.append(_distance).append(_splitStr).append(div(tdlRscpSc, tdlRscpScCnt)).append(_splitStr).append(div(scRsrpSum, ncRsrpAllCnt)).append(_splitStr).append(tdlTim).append(_splitStr).append(div(tdlRscpNc, tdlRscpNcCnt)).append(_splitStr)
			.append(tdlTimAlone).append(_splitStr).append(nrsrpThresholdCount).append(_splitStr).append(tdlTimMax).append(_splitStr).append(div(dlTimNcRsrp, tdlTimMax)).append(_splitStr);
		for (int i = 0; i < tdlTimLen; i++) {
			line.append(tdlTims[i]).append(_splitStr);
		}
		for (int i = 0; i < tdlTimLen; i++) {
			line.append(div((double) tdlTimNcRsrps[i], tdlTims[i])).append(_splitStr);
		}
		line.append(overlapCount1).append(_splitStr).append(overlapCount2).append(_splitStr).append(div(tdlRscpNcOverlapCondi1, overlapCount1)).append(_splitStr);
		for (int i = 0; i < tdlTimLen; i++) {
			line.append(tdlTimOverlapCondi1[i]).append(_splitStr);
		}
		for (int i = 0; i < tdlTimLen; i++) {
			line.append(div((double) tdlTimNcRsrpOverlapCondi1[i], tdlTimOverlapCondi1[i])).append(_splitStr);
		}
		line.append(div(tdlRscpNcOverlapCondi2, overlapCount2)).append(_splitStr);
		for (int i = 0; i < tdlTimLen; i++) {
			line.append(tdlTimOverlapCondi2[i]).append(_splitStr);
		}
		for (int i = 0; i < tdlTimLen; i++) {
			line.append(div((double) tdlTimNcRsrpOverlapCondi2[i], tdlTimOverlapCondi2[i])).append(_splitStr);
		}
		line.append(scRsrpSum).append(_splitStr).append(rsrpDiffAbsSum).append(_splitStr).append(div(rsrpDiffAbsSum, ncRsrpAllCnt)).append(_splitStr);
		for (int i = 0; i < rsrpAllLen; i++) {
			line.append(ncRsrpAlls[i]).append(_splitStr);
		}
		line.append(ncRsrpAllSum).append(_splitStr).append(ncRsrpAllCnt).append(_splitStr).append(ncNeType);
		return line.toString();
	}
	
	public int getTotalNum() {
		return ncTotalNum;
	}
	
	public int getFreq() {
		return freq;
	}
	
	public int getFreqBand() {
		return freqBand;
	}
	
	public int getNcScOverF6(int i) {
		if (i < 0 || i >= 3) {
			return 0;
		}
		return ncScOverF6[i];
	}
	
	private void setDiffAdj(int scRsrp, int ncRsrp, int type, RsrpParse rsrpParse) {
		if (scRsrp == -1 || ncRsrp == -1) {
			return;
		}
		
		int scRsrpIdx = rsrpParse.getIdxRsrpAdj(scRsrp);
		int ncRsrpIdx = rsrpParse.getIdxRsrpAdj(ncRsrp);
		int diffIdx = rsrpParse.getIdxDiff(scRsrp - ncRsrp);
		
		if (type == 0) {
			scDiffs[scRsrpIdx][diffIdx]++;
			diffs[diffIdx]++;
			ncRsrps[ncRsrpIdx]++;
		} else if (type == 1) {
			scDiffFreqs[scRsrpIdx][diffIdx]++;
			diffFreqs[diffIdx]++;
			ncRsrpFreqs[ncRsrpIdx]++;
		} else if (type == 2) {
			scDiffFreqBands[scRsrpIdx][diffIdx]++;
			diffFreqBands[diffIdx]++;
			ncRsrpFreqBands[ncRsrpIdx]++;
		}
		
		if (diffIdx <= 6) {
			ncScOverF6[type]++;
		}
		if (diffIdx <= 5) {
			ncScOverF3[type]++;
		}
		if (diffIdx <= 9) {
			ncScOverF12[type]++;
		}
	}
	
	private void setPolAdj(int scRsrp, int ncRsrp, int isp, MroGridInfo gridInfo, int idx, RsrpParse rsrpParse) {
		int nCellCnt = gridInfo.getNcCells().size();
		int overlapCondi1 = gridInfo.getOverlapCondi1(idx);
		int overlapCondi2 = gridInfo.getOverlapCondi2(idx);
		
		if (scRsrp != -1) {
			tdlRscpSc += scRsrp;
			tdlRscpScCnt++;
		}
		
		if (ncRsrp != -1) {
			tdlRscpNc += ncRsrp;
			tdlRscpNcCnt++;
		}
		
		tdlTim++;
		if (nCellCnt == 1) {
			tdlTimAlone++;
		}
		if (idx == 0 && scRsrp != -1 && ncRsrp > scRsrp) {
			tdlTimMax++;
			dlTimNcRsrp += ncRsrp;
		}
		
		if (ncRsrp != -1 && ncRsrp <= _rsrpWeak) {
			nrsrpThresholdCount++;
		}
		
		setTdlTims(idx, tdlTims, tdlTimNcRsrps, ncRsrp);
		if (overlapCondi1 == 1) {
			overlapCount1++;
			tdlRscpNcOverlapCondi1 += ncRsrp;
			setTdlTims(idx, tdlTimOverlapCondi1, tdlTimNcRsrpOverlapCondi1, ncRsrp);
		}
		
		if (overlapCondi2 == 1) {
			overlapCount2++;
			tdlRscpNcOverlapCondi2 += ncRsrp;
			setTdlTims(idx, tdlTimOverlapCondi2, tdlTimNcRsrpOverlapCondi2, ncRsrp);
		}
		
		if (scRsrp != -1) {
			scRsrpSum += rsrpParse.getRsrpValue(scRsrp);
		}
		
		if (ncRsrp >= 0 && ncRsrp < rsrpAllLen) {
			ncRsrpAlls[ncRsrp]++;
			ncRsrpAllSum += rsrpParse.getRsrpValue(ncRsrp);
			ncRsrpAllCnt++;
		}
		
		ncNeType = isp;
		if (scRsrp != -1 && ncRsrp != -1) {
			rsrpDiffAbsSum += Math.abs(scRsrp - ncRsrp);
		}
	}
	
	private void setTdlTims(int idx, int[] tims, int[] timNcRsrps, int ncRsrp) {
		if (idx >= tdlTimLen || ncRsrp == -1) {
			return;
		}
		
		tims[idx]++;
		timNcRsrps[idx] += ncRsrp;
	}
	
	private double div(double numerator, int denominator) {
		if (denominator == 0) {
			return 0;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro.sum;

import java.util.List;

import com.boco.wangyou.algorithm.counter.AoaParse;
import com.boco.wangyou.algorithm.counter.NumOfAdjParse;
import com.boco.wangyou.algorithm.counter.RipParse;
import com.boco.wangyou.algorithm.counter.RsrpParse;
import com.boco.wangyou.algorithm.counter.SinrULParse;
import com.boco.wangyou.ltemr.parse.entity.mro.TdlMroGridUe;

public class TdlMroEutr {
	private List<String> _variableTabs = null;
	private String _splitStr = "";
	private final int maxRsrpLen = 11;
	private int[] maxRsrps = new int[maxRsrpLen];
	private int maxRsrpCnt = 0;
	private final int rsrpDiffLen = 27;
	private int[] rsrpDiffs = new int[rsrpDiffLen];
	private final int diffDbmLen = 43;
	private int[] diffDbms = new int[diffDbmLen];
	private final int numOfAdjLen = 21;
	private int[][] numOfAdjs = new int[numOfAdjLen][2];
	private int[][] numOfAdjFreqs = new int[numOfAdjLen][2];
	private int freq = -1;
	private int[][] numOfAdjFreqBands = new int[numOfAdjLen][2];
	private int freqBand = -1;
	private final int rsrpLen = 12;
	private int[] rsrps = new int[rsrpLen];
	private double rsrpSum = 0;
	private int rsrpCnt = 0;
	private int rsrpLtF110 = 0;
	private int rsrpLtF113 = 0;
	private int rsrpLtF115 = 0;
	private int[] maxUnRsrps = new int[rsrpLen];
	private double maxUnRsrpSum = 0;
	private int maxUnRsrpCnt = 0;
	private int maxUnRsrpLtF110 = 0;
	private int maxUnRsrpLtF113 = 0;
	private int maxUnRsrpLtF115 = 0;
	private int[] maxTeRsrps = new int[rsrpLen];
	private double maxTeRsrpSum = 0;
	private int maxTeRsrpCnt = 0;
	private int maxTeRsrpLtF110 = 0;
	private int maxTeRsrpLtF113 = 0;
	private int maxTeRsrpLtF115 = 0;
	private int[] maxInterRsrps = new int[rsrpLen];
	private double maxInterRsrpSum = 0;
	private int maxInterRsrpCnt = 0;
	private int maxInterRsrpLtF110 = 0;
	private int maxInterRsrpLtF113 = 0;
	private int maxInterRsrpLtF115 = 0;
	private int ripLen = 104;
	private int[] rips = new int[ripLen];
	private double ripSum = 0;
	private int ripCnt = 0;
	private int sinrUlLen = 37;
	private int[] sinrUls = new int[sinrUlLen];
	private double sinrUlSum = 0;
	private int sinrUlCnt = 0;
	private int aoaLen = 720;
	private int[] aoas = new int[aoaLen];
	private double aoaSum = 0;
	private int aoaCnt = 0;
	private int totalNumOfAdj = 0;
	private int gsmTotalNum = 0;
	private double gsmRsrpSum = 0;
	private int totalNumPol = 0;
	
	public TdlMroEutr(List<String> variableTabs, String splitStr) {
		_variableTabs = variableTabs;
		_splitStr = splitStr;
		
		for (int i = 0; i < maxRsrpLen; i++) {
			maxRsrps[i] = 0;
		}
		
		for (int i = 0; i < rsrpDiffLen; i++) {
			rsrpDiffs[i] = 0;
		}
		
		for (int i = 0; i < diffDbmLen; i++) {
			diffDbms[i] = 0;
		}
		
		for (int i = 0; i < numOfAdjLen; i++) {
			for (int j = 0; j < 2; j++) {
				numOfAdjs[i][j] = 0;
				numOfAdjFreqs[i][j] = 0;
				numOfAdjFreqBands[i][j] = 0;
			}
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrps[i] = 0;
			maxUnRsrps[i] = 0;
			maxTeRsrps[i] = 0;
			maxInterRsrps[i] = 0;
		}
		
		for (int i = 0; i < ripLen; i++) {
			rips[i] = 0;
		}
		
		for (int i = 0; i < sinrUlLen; i++) {
			sinrUls[i] = 0;
		}
		
		for (int i = 0; i < aoaLen; i++) {
			aoas[i] = 0;
		}
	}
	
	public void setValue(TdlMroGridUe gridUe, RsrpParse rsrpParse, NumOfAdjParse numOfAdjParse, SinrULParse sinrULParse, AoaParse aoaParse) {
		int maxRsrp = gridUe.getMaxRsrp();
		if (_variableTabs.contains("tdl_mro_maxrsrp_eutr")) {
			setMaxRsrp(maxRsrp, rsrpParse);
		}
		
		int scRsrp = gridUe.getRsrp();
		if (_variableTabs.contains("tdl_mro_rsrpdiff_eutr")) {
			setRsrpDiff(maxRsrp, scRsrp, rsrpParse);
		}
		
		if (scRsrp >= 31) {
			totalNumOfAdj++;
		}
		if (_variableTabs.contains("tdl_mro_numofadj_eutr")) {
			int diff6Num = gridUe.getDiff6Num(0);
			int diff10Num = gridUe.getDiff10Num(0);
			setNumOfAdj(diff6Num, diff10Num, 0, numOfAdjParse);
		}
		
		int ncRsrpDbm = gridUe.getNcRsrpDbm();
		if (_variableTabs.contains("tdl_mro_overlap")) {
			setDiffDbm(scRsrp, ncRsrpDbm, rsrpParse);
		}
		
		if (_variableTabs.contains("tdl_mro_numofadj_freq") && gridUe.getFreqFlag(1) && scRsrp >= 31) {
			int diff6Num = gridUe.getDiff6Num(1);
			int diff10Num = gridUe.getDiff10Num(1);
			setNumOfAdj(diff6Num, diff10Num, 1, numOfAdjParse);
			freq = gridUe.getScFreq();
		}
		
		if (_variableTabs.contains("tdl_mro_numofadj_freqband") && gridUe.getFreqFlag(2) && scRsrp >= 31) {
			int diff6Num = gridUe.getDiff6Num(2);
			int diff10Num = gridUe.getDiff10Num(2);
			setNumOfAdj(diff6Num, diff10Num, 2, numOfAdjParse);
			freqBand = gridUe.getScFreqBand();
		}
		
		if (_variableTabs.contains("tdl_mro_rsrp")) {
			setRsrp(scRsrp, rsrpParse, 0);
			
			int unRsrp = gridUe.getUnMaxRsrp();
			setRsrp(unRsrp, rsrpParse, 1);
			
			int teRsrp = gridUe.getTeMaxRsrp();
			setRsrp(teRsrp, rsrpParse, 2);
			
			if (unRsrp != -1 || teRsrp != -1) {
				setRsrp(scRsrp, rsrpParse, 3);
			}
		}
		
		if (_variableTabs.contains("tdl_mro_sinrul")) {
			int sinrUl = gridUe.getSinrUl();
			setSinrUl(sinrUl, sinrULParse);
		}
		
		if (_variableTabs.contains("tdl_mro_aoa")) {
			int aoa = gridUe.getLteScAoa();
			setAoa(aoa, aoaParse);
		}
		
		if (gridUe.getNcBcchBsicList().size() != 0) {
			gsmRsrpSum += rsrpParse.getRsrpValue(scRsrp);
			gsmTotalNum++;
		}
		totalNumPol++;
	}
	
	public void setRipValue(int rip, RipParse ripParse) {
		int ripIdx = ripParse.getIdx(rip);
		rips[ripIdx]++;
		ripSum += ripParse.getValue(rip);
		ripCnt++;
	}
	
	public String getMaxRsrpLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < maxRsrpLen; i++) {
			line.append(maxRsrps[i]).append(_splitStr);
		}
		line.append(maxRsrpCnt);
		return line.toString();
	}
	
	public String getRsrpDiffLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rsrpDiffLen; i++) {
			line.append(rsrpDiffs[i]).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public String getOverlapLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < diffDbmLen; i++) {
			line.append(diffDbms[i]).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public String getNumOfAdjLine(StringBuffer line) {
		line.setLength(0);
		for (int j = 0; j < 2; j++) {
			for (int i = 0; i < numOfAdjLen; i++) {
				line.append(numOfAdjs[i][j]).append(_splitStr);
			}
		}
		line.append(totalNumOfAdj);
		return line.toString();
	}
	
	public String getNumOfAdjFreqLine(StringBuffer line) {
		line.setLength(0);
		line.append(freq).append(_splitStr);
		for (int j = 0; j < 2; j++) {
			for (int i = 0; i < numOfAdjLen; i++) {
				line.append(numOfAdjFreqs[i][j]).append(_splitStr);
			}
		}
		line.append(totalNumOfAdj);
		return line.toString();
	}
	
	public String getNumOfAdjFreqBandLine(StringBuffer line) {
		line.setLength(0);
		line.append(freqBand).append(_splitStr);
		for (int j = 0; j < 2; j++) {
			for (int i = 0; i < numOfAdjLen; i++) {
				line.append(numOfAdjFreqBands[i][j]).append(_splitStr);
			}
		}
		line.append(totalNumOfAdj);
		return line.toString();
	}
	
	public String getRsrpLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrps[i]).append(_splitStr);
		}
		line.append(rsrpSum).append(_splitStr).append(rsrpCnt).append(_splitStr).append(div(rsrpSum, rsrpCnt)).append(_splitStr).
			append(rsrpLtF110).append(_splitStr).append(rsrpLtF113).append(_splitStr).append(rsrpLtF115).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxUnRsrps[i]).append(_splitStr);
		}
		line.append(maxUnRsrpSum).append(_splitStr).append(maxUnRsrpCnt).append(_splitStr).append(div(maxUnRsrpSum, maxUnRsrpCnt)).append(_splitStr)
			.append(maxUnRsrpLtF110).append(_splitStr).append(maxUnRsrpLtF113).append(_splitStr).append(maxUnRsrpLtF115).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxTeRsrps[i]).append(_splitStr);
		}
		line.append(maxTeRsrpSum).append(_splitStr).append(maxTeRsrpCnt).append(_splitStr).append(div(maxTeRsrpSum, maxTeRsrpCnt)).append(_splitStr)
			.append(maxTeRsrpLtF110).append(_splitStr).append(maxTeRsrpLtF113).append(_splitStr).append(maxTeRsrpLtF115).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxInterRsrps[i]).append(_splitStr);
		}
		line.append(maxInterRsrpSum).append(_splitStr).append(maxInterRsrpCnt).append(_splitStr).append(div(maxInterRsrpSum, maxInterRsrpCnt)).append(_splitStr)
			.append(maxInterRsrpLtF110).append(_splitStr).append(maxInterRsrpLtF113).append(_splitStr).append(maxInterRsrpLtF115);
		return line.toString();
	}
	
	public String getRipLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < ripLen; i++) {
			line.append(rips[i]).append(_splitStr);
		}
		line.append(ripSum).append(_splitStr).append(ripCnt);
		return line.toString();
	}
	
	public String getSinrUlLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < sinrUlLen; i++) {
			line.append(sinrUls[i]).append(_splitStr);
		}
		line.append(sinrUlSum).append(_splitStr).append(sinrUlCnt);
		return line.toString();
	}
	
	public String getAoaLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < aoaLen; i++) {
			line.append(aoas[i]).append(_splitStr);
		}
		line.append(aoaSum).append(_splitStr).append(aoaCnt);
		return line.toString();
	}
	
	public int getFreq() {
		return freq;
	}
	
	public int getFreqBand() {
		return freqBand;
	}
	
	public int getTotalNum() {
		return totalNumOfAdj;
	}
	
	public int getGsmTotalNum() {
		return gsmTotalNum;
	}
	
	public int getTotalNumPol() {
		return totalNumPol;
	}
	
	public int getRipCnt() {
		return ripCnt;
	}
	
	public double getGsmAveRsrp() {
		if (gsmTotalNum == 0) {
			return 0;
		}
		return gsmRsrpSum / gsmTotalNum;
	}
	
	private void setMaxRsrp(int maxRsrp, RsrpParse rsrpParse) {
		if (maxRsrp == -1) {
			return;
		}
		
		int idx = rsrpParse.getIdxMaxRsrp(maxRsrp);
		maxRsrps[idx]++;
		maxRsrpCnt++;
	}
	
	private void setRsrpDiff(int maxRsrp, int scRsrp, RsrpParse rsrpParse) {
		if (maxRsrp == -1 || scRsrp == -1) {
			return;
		}
		
		int rsrpDiff = maxRsrp - scRsrp;
		int idx = rsrpParse.getIdxRsrpDiff(rsrpDiff);
		rsrpDiffs[idx]++;
	}
	
	private void setDiffDbm(int scRsrp, int ncRsrpDbm, RsrpParse rsrpParse) {
		if (scRsrp == -1 || ncRsrpDbm == 0) {
			return;
		}
		
		int diffDbm = scRsrp - 141 - ncRsrpDbm;
		int idx = rsrpParse.getIdxDiffDbm(diffDbm);
		diffDbms[idx]++;
	}
	
	private void setNumOfAdj(int diff6Num, int diff10Num, int type, NumOfAdjParse numOfAdjParse) {
		int idx6 = numOfAdjParse.getIdx(diff6Num, numOfAdjLen);
		int idx10 = numOfAdjParse.getIdx(diff10Num, numOfAdjLen);
		if (type == 0) {
			numOfAdjs[idx6][0]++;
			numOfAdjs[idx10][1]++;
		} else if (type == 1) {
			numOfAdjFreqs[idx6][0]++;
			numOfAdjFreqs[idx10][1]++;
		} else if (type == 2) {
			numOfAdjFreqBands[idx6][0]++;
			numOfAdjFreqBands[idx10][1]++;
		}
	}
	
	private void setRsrp(int rsrp, RsrpParse rsrpParse, int type) {
		if (rsrp == -1) {
			return;
		}
		
		int idx = rsrpParse.getIdxRsrp(rsrp);
		double rsrpValue = rsrpParse.getRsrpValue(rsrp);
		int ltF110 = (idx <= 4) ? 1 : 0;
		int ltF113 = (idx <= 3) ? 1 : 0;
		int ltF115 = (idx <= 2) ? 1 : 0;
		
		if (type == 0) {
			rsrps[idx]++;
			rsrpSum += rsrpValue;
			rsrpCnt++;
			rsrpLtF110 += ltF110;
			rsrpLtF113 += ltF113;
			rsrpLtF115 += ltF115;
		} else if (type == 1) {
			maxUnRsrps[idx]++;
			maxUnRsrpSum += rsrpValue;
			maxUnRsrpCnt++;
			maxUnRsrpLtF110 += ltF110;
			maxUnRsrpLtF113 += ltF113;
			maxUnRsrpLtF115 += ltF115;
		} else if (type == 2) {
			maxTeRsrps[idx]++;
			maxTeRsrpSum += rsrpValue;
			maxTeRsrpCnt++;
			maxTeRsrpLtF110 += ltF110;
			maxTeRsrpLtF113 += ltF113;
			maxTeRsrpLtF115 += ltF115;
		} else if (type == 3) {
			maxInterRsrps[idx]++;
			maxInterRsrpSum += rsrpValue;
			maxInterRsrpCnt++;
			maxInterRsrpLtF110 += ltF110;
			maxInterRsrpLtF113 += ltF113;
			maxInterRsrpLtF115 += ltF115;
		}
	}
	
	private void setSinrUl(int sinrUl, SinrULParse sinrULParse) {
		if (sinrUl == -1 || sinrUl >= sinrUlLen) {
			return;
		}
		
		sinrUls[sinrUl]++;
		sinrUlSum += sinrULParse.getValue(sinrUl);
		sinrUlCnt++;
	}
	
	private void setAoa(int aoa, AoaParse aoaParse) {
		if (aoa == -1 || aoa >= aoaLen) {
			return;
		}
		
		aoas[aoa]++;
		aoaSum += aoaParse.getValue(aoa);
		aoaCnt++;
	}
	
	private double div(double numerator, int denominator) {
		if (denominator == 0) {
			return 0;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro.sum;

import com.boco.wangyou.algorithm.counter.NumOfAdjParse;
import com.boco.wangyou.ltemr.parse.entity.mro.TdlMroGridUe;

public class TdlMroGrid {
	private String _splitStr = "";
	private final int numOfAdjLen = 21;
	private int[][] numOfAdjs = new int[numOfAdjLen][2];
	private int totalNumOfAdj = 0;
	
	public TdlMroGrid(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < numOfAdjLen; i++) {
			for (int j = 0; j < 2; j++) {
				numOfAdjs[i][j] = 0;
			}
		}
	}
	
	public void setValue(TdlMroGridUe gridUe, NumOfAdjParse numOfAdjParse) {
		int diff6Num = gridUe.getDiff6Num(0);
		int diff10Num = gridUe.getDiff10Num(0);
		setNumOfAdj(diff6Num, diff10Num, numOfAdjParse);
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int j = 0; j < 2; j++) {
			for (int i = 0; i < numOfAdjLen; i++) {
				line.append(numOfAdjs[i][j]).append(_splitStr);
			}
		}
		line.append(totalNumOfAdj);
		return line.toString();
	}
	
	private void setNumOfAdj(int diff6Num, int diff10Num, NumOfAdjParse numOfAdjParse) {
		int idx6 = numOfAdjParse.getIdx(diff6Num, numOfAdjLen);
		int idx10 = numOfAdjParse.getIdx(diff10Num, numOfAdjLen);
		numOfAdjs[idx6][0]++;
		numOfAdjs[idx10][1]++;
		totalNumOfAdj++;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro.sum;

import java.util.List;

import com.boco.wangyou.algorithm.counter.PhrParse;
import com.boco.wangyou.algorithm.counter.RsrpParse;
import com.boco.wangyou.algorithm.counter.RsrqParse;
import com.boco.wangyou.algorithm.counter.SinrDLParse;
import com.boco.wangyou.algorithm.counter.SinrULParse;
import com.boco.wangyou.ltemr.parse.entity.mro.TdlMroGridUe;

public class TdlMroGridUser {
	private List<String> _variableTabs = null;
	private String _splitStr = "";
	private int _rsrpWeak = 0;
	private final int rsrpLen = 12;
	private int[] scRsrps = new int[rsrpLen];
	private double scRsrpSum = 0;
	private int scRsrpCnt = 0;
	private int scRsrpCntWeak = 0;
	private int scRsrpCntWeakL2 = 0;
	private int[] maxRsrps = new int[rsrpLen];
	private double maxRsrpSum = 0;
	private int maxRsrpCnt = 0;
	private int maxRsrpCntWeak = 0;
	private int maxRsrpCntWeakL2 = 0;
	private int[] maxUnRsrps = new int[rsrpLen];
	private double maxUnRsrpSum = 0;
	private int maxUnRsrpCnt = 0;
	private int maxUnRsrpCntWeak = 0;
	private int maxUnRsrpCntWeakL2 = 0;
	private int[] maxTeRsrps = new int[rsrpLen];
	private double maxTeRsrpSum = 0;
	private int maxTeRsrpCnt = 0;
	private int maxTeRsrpCntWeak = 0;
	private int maxTeRsrpCntWeakL2 = 0;
	private int[] maxInterRsrps = new int[rsrpLen];
	private double maxInterRsrpSum = 0;
	private int maxInterRsrpCnt = 0;
	private int maxInterRsrpCntWeak = 0;
	private int maxInterRsrpCntWeakL2 = 0;
	private final int rsrqLen = 8;
	private int[] scRsrqs = new int[rsrqLen];
	private double scRsrqSum = 0;
	private int scRsrqCnt = 0;
	private final int sinrUlLen = 7;
	private int[] sinrUls = new int[sinrUlLen];
	private double sinrUlSum = 0;
	private int sinrUlCnt = 0;
	private final int phrLen = 6;
	private int[] phrs = new int[phrLen];
	private double phrSum = 0;
	private int phrCnt = 0;
	private int sinrDlLen = 57;
	private int[] sinrDls = new int[sinrDlLen];
	private double sinrDlSum = 0;
	private int sinrDlCnt = 0;
	
	public TdlMroGridUser(List<String> variableTabs, String splitStr, int rsrpWeak) {
		_variableTabs = variableTabs;
		_splitStr = splitStr;
		_rsrpWeak = rsrpWeak;
		
		for (int i = 0; i < rsrpLen; i++) {
			scRsrps[i] = 0;
			maxRsrps[i] = 0;
			maxUnRsrps[i] = 0;
			maxTeRsrps[i] = 0;
			maxInterRsrps[i] = 0;
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			scRsrqs[i] = 0;
		}
		
		for (int i = 0; i < sinrUlLen; i++) {
			sinrUls[i] = 0;
		}
		
		for (int i = 0; i < phrLen; i++) {
			phrs[i] = 0;
		}
		
		for (int i = 0; i < sinrDlLen; i++) {
			sinrDls[i] = 0;
		}
	}
	
	public void setValue(TdlMroGridUe gridUe, RsrpParse rsrpParse, RsrqParse rsrqParse, SinrULParse sinrULParse, PhrParse phrParse, SinrDLParse sinrDLParse) {
		if (_variableTabs.contains("tdl_mro_mgrs_user_rsrp")) {
			int scRsrp = gridUe.getRsrp();
			setRsrp(scRsrp, 0, rsrpParse);
			
			int maxRsrp = gridUe.getMaxRsrp();
			setRsrp(maxRsrp, 1, rsrpParse);
			
			int maxUnRsrp = gridUe.getUnMaxRsrp();
			setRsrp(maxUnRsrp, 2, rsrpParse);
			
			int maxTeRsrp = gridUe.getTeMaxRsrp();
			setRsrp(maxTeRsrp, 3, rsrpParse);
			
			if (maxUnRsrp != -1 || maxTeRsrp != -1) {
				setRsrp(maxRsrp, 4, rsrpParse);
			}
		}
		
		if (_variableTabs.contains("tdl_mro_mgrs_user_rsrq")) {
			int scRsrq = gridUe.getRsrq();
			setRsrq(scRsrq, rsrqParse);
		}
		
		if (_variableTabs.contains("tdl_mro_mgrs_user_sinrul")) {
			int sinrUl = gridUe.getSinrUl();
			setSinrUl(sinrUl, sinrULParse);
		}
		
		if (_variableTabs.contains("tdl_mro_mgrs_user_phr")) {
			int phr = gridUe.getPhr();
			setPhr(phr, phrParse);
		}
		
		if (_variableTabs.contains("tdl_mro_mgrs_user_sinrdl")) {
			int sinrDl = gridUe.getSinr();
			setSinrDl(sinrDl, sinrDLParse);
		}
	}
	
	public int getScRsrp(int i) {
		if (i < 0 || i >= rsrpLen) {
			return 0;
		}
		return scRsrps[i];
	}
	
	public double getScRsrpSum() {
		return scRsrpSum;
	}
	
	public int getScRsrpCnt() {
		return scRsrpCnt;
	}
	
	public int getScRsrpCntWeak() {
		return scRsrpCntWeak;
	}
	
	public int getScRsrpCntWeakL2() {
		return scRsrpCntWeakL2;
	}
	
	public int getMaxRsrp(int i) {
		if (i < 0 || i >= rsrpLen) {
			return 0;
		}
		return maxRsrps[i];
	}
	
	public double getMaxRsrpSum() {
		return maxRsrpSum;
	}
	
	public int getMaxRsrpCnt() {
		return maxRsrpCnt;
	}
	
	public int getMaxRsrpCntWeak() {
		return maxRsrpCntWeak;
	}
	
	public int getMaxRsrpCntWeakL2() {
		return maxRsrpCntWeakL2;
	}
	
	public int getMaxUnRsrp(int i) {
		if (i < 0 || i >= rsrpLen) {
			return 0;
		}
		return maxUnRsrps[i];
	}
	
	public double getMaxUnRsrpSum() {
		return maxUnRsrpSum;
	}
	
	public int getMaxUnRsrpCnt() {
		return maxUnRsrpCnt;
	}
	
	public int getMaxUnRsrpCntWeak() {
		return maxUnRsrpCntWeak;
	}
	
	public int getMaxUnRsrpCntWeakL2() {
		return maxUnRsrpCntWeakL2;
	}
	
	public int getMaxTeRsrp(int i) {
		if (i < 0 || i >= rsrpLen) {
			return 0;
		}
		return maxTeRsrps[i];
	}
	
	public double getMaxTeRsrpSum() {
		return maxTeRsrpSum;
	}
	
	public int getMaxTeRsrpCnt() {
		return maxTeRsrpCnt;
	}
	
	public int getMaxTeRsrpCntWeak() {
		return maxTeRsrpCntWeak;
	}
	
	public int getMaxTeRsrpCntWeakL2() {
		return maxTeRsrpCntWeakL2;
	}
	
	public int getMaxInterRsrp(int i) {
		if (i < 0 || i >= rsrpLen) {
			return 0;
		}
		return maxInterRsrps[i];
	}
	
	public double getMaxInterRsrpSum() {
		return maxInterRsrpSum;
	}
	
	public int getMaxInterRsrpCnt() {
		return maxInterRsrpCnt;
	}
	
	public int getMaxInterRsrpCntWeak() {
		return maxInterRsrpCntWeak;
	}
	
	public int getMaxInterRsrpCntWeakL2() {
		return maxInterRsrpCntWeakL2;
	}
	
	public int getScRsrq(int i) {
		if (i < 0 || i >= rsrqLen) {
			return 0;
		}
		return scRsrqs[i];
	}
	
	public double getScRsrqSum() {
		return scRsrqSum;
	}
	
	public int getScRsrqCnt() {
		return scRsrqCnt;
	}
	
	public int getSinrUl(int i) {
		if (i < 0 || i >= sinrUlLen) {
			return 0;
		}
		return sinrUls[i];
	}
	
	public double getSinrUlSum() {
		return sinrUlSum;
	}
	
	public int getSinrUlCnt() {
		return sinrUlCnt;
	}
	
	public int getPhr(int i) {
		if (i < 0 || i >= phrLen) {
			return 0;
		}
		return phrs[i];
	}
	
	public double getPhrSum() {
		return phrSum;
	}
	
	public int getPhrCnt() {
		return phrCnt;
	}
	
	public int getSinrDl(int i) {
		if (i < 0 || i >= sinrDlLen) {
			return 0;
		}
		return sinrDls[i];
	}
	
	public double getSinrDlSum() {
		return sinrDlSum;
	}
	
	public int getSinrDlCnt() {
		return sinrDlCnt;
	}
	
	public String getMgrsRsrpLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(scRsrps[i]).append(_splitStr);
		}
		line.append(scRsrpSum).append(_splitStr).append(scRsrpCnt).append(_splitStr).append(scRsrpCntWeak).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxRsrps[i]).append(_splitStr);
		}
		line.append(maxRsrpSum).append(_splitStr).append(maxRsrpCnt).append(_splitStr).append(maxRsrpCntWeak).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxUnRsrps[i]).append(_splitStr);
		}
		line.append(maxUnRsrpSum).append(_splitStr).append(maxUnRsrpCnt).append(_splitStr).append(maxUnRsrpCntWeak).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxTeRsrps[i]).append(_splitStr);
		}
		line.append(maxTeRsrpSum).append(_splitStr).append(maxTeRsrpCnt).append(_splitStr).append(maxTeRsrpCntWeak).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxInterRsrps[i]).append(_splitStr);
		}
		line.append(maxInterRsrpSum).append(_splitStr).append(maxInterRsrpCnt).append(_splitStr).append(maxInterRsrpCntWeak);
		return line.toString();
	}
	
	public String getMgrsRsrqLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rsrqLen; i++) {
			line.append(scRsrqs[i]).append(_splitStr);
		}
		line.append(scRsrqSum).append(_splitStr).append(scRsrqCnt);
		return line.toString();
	}
	
	public String getMgrsSinrUlLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < sinrUlLen; i++) {
			line.append(sinrUls[i]).append(_splitStr);
		}
		line.append(sinrUlSum).append(_splitStr).append(sinrUlCnt);
		return line.toString();
	}
	
	public String getMgrsPhrLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < phrLen; i++) {
			line.append(phrs[i]).append(_splitStr);
		}
		line.append(phrSum).append(_splitStr).append(phrCnt);
		return line.toString();
	}
	
	public String getMgrsSinrDlLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < sinrDlLen; i++) {
			line.append(sinrDls[i]).append(_splitStr);
		}
		line.append(sinrDlSum).append(_splitStr).append(sinrDlCnt);
		return line.toString();
	}
	
	private void setRsrp(int rsrp, int type, RsrpParse rsrpParse) {
		if (rsrp == -1) {
			return;
		}
		
		int idx = rsrpParse.getIdxRsrp(rsrp);
		double rsrpValue = rsrpParse.getRsrpValue(rsrp);
		int rsrpWeakFlag = (rsrp <= _rsrpWeak) ? 1 : 0;
		int rsrpWeakL2Flag = (rsrp <= 27) ? 1 : 0;
		
		if (type == 0) {
			scRsrps[idx]++;
			scRsrpSum += rsrpValue;
			scRsrpCnt++;
			scRsrpCntWeak += rsrpWeakFlag;
			scRsrpCntWeakL2 += rsrpWeakL2Flag;
		} else if (type == 1) {
			maxRsrps[idx]++;
			maxRsrpSum += rsrpValue;
			maxRsrpCnt++;
			maxRsrpCntWeak += rsrpWeakFlag;
			maxRsrpCntWeakL2 += rsrpWeakL2Flag;
		} else if (type == 2) {
			maxUnRsrps[idx]++;
			maxUnRsrpSum += rsrpValue;
			maxUnRsrpCnt++;
			maxUnRsrpCntWeak += rsrpWeakFlag;
			maxUnRsrpCntWeakL2 += rsrpWeakL2Flag;
		} else if (type == 3) {
			maxTeRsrps[idx]++;
			maxTeRsrpSum += rsrpValue;
			maxTeRsrpCnt++;
			maxTeRsrpCntWeak += rsrpWeakFlag;
			maxTeRsrpCntWeakL2 += rsrpWeakL2Flag;
		} else if (type == 4) {
			maxInterRsrps[idx]++;
			maxInterRsrpSum += rsrpValue;
			maxInterRsrpCnt++;
			maxInterRsrpCntWeak += rsrpWeakFlag;
			maxInterRsrpCntWeakL2 += rsrpWeakL2Flag;
		}
	}
	
	private void setRsrq(int rsrq, RsrqParse rsrqParse) {
		if (rsrq == -1) {
			return;
		}
		
		int idx = rsrqParse.getIdx(rsrq);
		scRsrqs[idx]++;
		scRsrqSum += rsrqParse.getRsrqValue(rsrq);
		scRsrqCnt++;
	}
	
	private void setSinrUl(int sinrUl, SinrULParse sinrULParse) {
		if (sinrUl == -1) {
			return;
		}
		
		int idx = sinrULParse.getIdx(sinrUl);
		sinrUls[idx]++;
		sinrUlSum += sinrULParse.getValue(sinrUl);
		sinrUlCnt++;
	}
	
	private void setPhr(int phr, PhrParse phrParse) {
		if (phr == -1) {
			return;
		}
		
		int idx = phrParse.getIdx(phr);
		phrs[idx]++;
		phrSum += phrParse.getValue(phr);
		phrCnt++;
	}
	
	private void setSinrDl(int sinrDl, SinrDLParse sinrDLParse) {
		if (sinrDl == -999) {
			return;
		}
		
		int idx = sinrDLParse.getIdx(sinrDl);
		sinrDls[idx]++;
		sinrDlSum += sinrDLParse.getValue(idx);
		sinrDlCnt++;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro.sum;

import com.boco.wangyou.algorithm.counter.RsrpParse;
import com.boco.wangyou.ltemr.parse.entity.mro.MroGridInfo;
import com.boco.wangyou.ltemr.parse.entity.mro.TdlMroGridUe;

public class TdlMroGridUserAdj {
	private String _splitStr = "";
	private int _rsrpWeak = 0;
	private int rsrpLen = 12;
	private int[] rsrps = new int[rsrpLen];
	private double rsrpSum = 0;
	private int rsrpCnt = 0;
	private int rsrpCntWeak = 0;
	private int ncNeType = -1;
	
	public TdlMroGridUserAdj(String splitStr, int rsrpWeak) {
		_splitStr = splitStr;
		_rsrpWeak = rsrpWeak;
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrps[i] = 0;
		}
	}
	
	public void setValue(TdlMroGridUe gridUe, MroGridInfo gridInfo, int idx, RsrpParse rsrpParse) {
		int scRsrp = gridUe.getRsrp();
		setRsrp(scRsrp, rsrpParse);
		ncNeType = gridUe.getNcIsp(idx);
	}
	
	public String getRsrpLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrps[i]).append(_splitStr);
		}
		line.append(rsrpSum).append(_splitStr).append(rsrpCnt).append(_splitStr).append(rsrpCntWeak).append(_splitStr).append(ncNeType);
		return line.toString();
	}
	
	private void setRsrp(int scRsrp, RsrpParse rsrpParse) {
		if (scRsrp == -1) {
			return;
		}
		
		int idx = rsrpParse.getIdxRsrp(scRsrp);
		rsrps[idx]++;
		rsrpSum += rsrpParse.getRsrpValue(scRsrp);
		rsrpCnt++;
		rsrpCntWeak += (scRsrp <= _rsrpWeak) ? 1 : 0;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro.sum;

import com.boco.wangyou.algorithm.counter.RsrpParse;
import com.boco.wangyou.algorithm.counter.RssiParse;
import com.boco.wangyou.ltemr.parse.entity.mro.TdlMroGridUe;
import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;

public class TdlMroGsmAdj {
	private String _splitStr = "";
	private String _intId = "";
	private String _bsicBcch = "";
	private String _name = "";
	private double _distance = 0;
	private int rsrpLen = 11;
	private int rssiLen = 10;
	private int[][] rsrpRssis = new int[rsrpLen][rssiLen];
	private int[] ncRssis = new int[rssiLen];
	private int ncTotalNum = 0;
	private int totalNum85 = 0;
	private int totalNum90 = 0;
	private int totalNum95 = 0;
	private int rssiov85Rsrpls85 = 0;
	private int rssiov90Rsrpls90 = 0;
	private int rssiov95Rsrpls95 = 0;
	private double rsrpSum = 0;
	
	public TdlMroGsmAdj(String splitStr, GsmNcIniInfo ncGsmKey) {
		_splitStr = splitStr;
		_intId = ncGsmKey.getIntId();
		_bsicBcch = ncGsmKey.getBsicBcch();
		_name = ncGsmKey.getName();
		_distance = ncGsmKey.getDistance();
		
		for (int i = 0; i < rsrpLen; i++) {
			for (int j = 0; j < rssiLen; j++) {
				rsrpRssis[i][j] = 0;
			}
		}
		
		for (int i = 0; i < rssiLen; i++) {
			ncRssis[i] = 0;
		}
	}
	
	public void setValue(TdlMroGridUe gridUe, int idx, RsrpParse rsrpParse, RssiParse rssiParse) {
		int scRsrp = gridUe.getRsrp();
		int ncRssi = gridUe.getNcRssi(idx);
		setRsrpRssi(scRsrp, ncRssi, rsrpParse, rssiParse);
	}
	
	public String getKeyLine() {
		return _intId + _splitStr + _bsicBcch + _splitStr + _name;
	}
	
	public String getRsrpRssiLine(StringBuffer line) {
		line.setLength(0);
		line.append(_distance).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			for (int j = 0; j < rssiLen; j++) {
				line.append(rsrpRssis[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < rssiLen; i++) {
			line.append(ncRssis[i]).append(_splitStr);
		}
		line.append(ncTotalNum).append(_splitStr).append(totalNum85).append(_splitStr).append(totalNum90).append(_splitStr).append(totalNum95);
		return line.toString();
	}
	
	public String getAdjtdlGsmLine(StringBuffer line) {
		line.setLength(0);
		line.append(_distance).append(_splitStr)
			.append(rssiov85Rsrpls85).append(_splitStr).append(rssiov90Rsrpls90).append(_splitStr).append(rssiov95Rsrpls95).append(_splitStr)
			.append(ncTotalNum).append(_splitStr).append(totalNum85).append(_splitStr).append(totalNum90).append(_splitStr).append(totalNum95).append(_splitStr)
			.append(div(rssiov85Rsrpls85, totalNum85)).append(_splitStr).append(div(rssiov90Rsrpls90, totalNum90)).append(_splitStr).append(div(rssiov95Rsrpls95, totalNum95))
			.append(_splitStr).append(div(rsrpSum, ncTotalNum));
		for (int i = 0; i < rssiLen; i++) {
			line.append(_splitStr).append(ncRssis[i]);
		}
		return line.toString();
	}
	
	private void setRsrpRssi(int scRsrp, int ncRssi, RsrpParse rsrpParse, RssiParse rssiParse) {
		if (scRsrp == -1 || ncRssi == -1) {
			return;
		}
		
		int rsrpIdx = rsrpParse.getRsrpRssiIdx(scRsrp);
		int rssiIdx = rssiParse.getIdx(ncRssi);
		rsrpRssis[rsrpIdx][rssiIdx]++;
		ncRssis[rssiIdx]++;
		
		ncTotalNum++;
		if (scRsrp < -85 + 141 && ncRssi >= -85 + 111) {
			totalNum85++;
		}
		if (scRsrp < -90 + 141 && ncRssi >= -90 + 111) {
			totalNum90++;
		}
		if (scRsrp < -95 + 141 && ncRssi >= -95 + 111) {
			totalNum95++;
		}
		
		if (rsrpIdx <= 6 && rssiIdx >= 6) {
			rssiov85Rsrpls85++;
		}
		if (rsrpIdx <= 5 && rssiIdx >= 5) {
			rssiov90Rsrpls90++;
		}
		if (rsrpIdx <= 4 && rssiIdx >= 4) {
			rssiov95Rsrpls95++;
		}
		rsrpSum += rsrpParse.getRsrpValue(scRsrp);
	}
	
	private double div(int numerator, int denominator) {
		if (denominator == 0) {
			return 0;
		}
		return (double) numerator / denominator;
	}
	
	private double div(double numerator, int denominator) {
		if (denominator == 0) {
			return 0;
		}
		return (double) numerator / denominator;
	}
}package com.boco.wangyou.ltemr.parse.entity.mro.sum;

import java.util.HashSet;
import java.util.Set;

public class TdlMroMgrsEutr {
	private String _splitStr = "";
	private Set<String> grids = new HashSet<String>(2000);
	private final int rsrpLen = 12;
	private int[] scRsrps = new int[rsrpLen];
	private double scRsrpSum = 0;
	private int scRsrpCnt = 0;
	private int scRsrpCntWeak = 0;
	private int scRsrpCntWeakL2 = 0;
	private Set<String> effectiveGrids = new HashSet<String>(2000);
	private Set<String> weakCoverGrids = new HashSet<String>(2000);
	private Set<String> weakL2CoverGrids = new HashSet<String>(2000);
	private int[] maxRsrps = new int[rsrpLen];
	private double maxRsrpSum = 0;
	private int maxRsrpCnt = 0;
	private int maxRsrpCntWeak = 0;
	private int maxRsrpCntWeakL2 = 0;
	private Set<String> maxEffectiveGrids = new HashSet<String>(2000);
	private Set<String> maxWeakCoverGrids = new HashSet<String>(2000);
	private Set<String> maxWeakL2CoverGrids = new HashSet<String>(2000);
	private int[] maxUnRsrps = new int[rsrpLen];
	private double maxUnRsrpSum = 0;
	private int maxUnRsrpCnt = 0;
	private int maxUnRsrpCntWeak = 0;
	private int maxUnRsrpCntWeakL2 = 0;
	private Set<String> maxUnEffectiveGrids = new HashSet<String>(2000);
	private Set<String> maxUnWeakCoverGrids = new HashSet<String>(2000);
	private Set<String> maxUnWeakL2CoverGrids = new HashSet<String>(2000);
	private int[] maxTeRsrps = new int[rsrpLen];
	private double maxTeRsrpSum = 0;
	private int maxTeRsrpCnt = 0;
	private int maxTeRsrpCntWeak = 0;
	private int maxTeRsrpCntWeakL2 = 0;
	private Set<String> maxTeEffectiveGrids = new HashSet<String>(2000);
	private Set<String> maxTeWeakCoverGrids = new HashSet<String>(2000);
	private Set<String> maxTeWeakL2CoverGrids = new HashSet<String>(2000);
	private int[] maxInterRsrps = new int[rsrpLen];
	private double maxInterRsrpSum = 0;
	private int maxInterRsrpCnt = 0;
	private int maxInterRsrpCntWeak = 0;
	private int maxInterRsrpCntWeakL2 = 0;
	private Set<String> maxInterEffectiveGrids = new HashSet<String>(2000);
	private Set<String> maxInterWeakCoverGrids = new HashSet<String>(2000);
	private Set<String> maxInterWeakL2CoverGrids = new HashSet<String>(2000);
	
	public TdlMroMgrsEutr(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < rsrpLen; i++) {
			scRsrps[i] = 0;
			maxRsrps[i] = 0;
			maxUnRsrps[i] = 0;
			maxTeRsrps[i] = 0;
			maxInterRsrps[i] = 0;
		}
	}
	
	public void setValue(TdlMroGridUser tdlMroGridUser, String gridId) {
		for (int i = 0; i < rsrpLen; i++) {
			scRsrps[i] += tdlMroGridUser.getScRsrp(i);
			maxRsrps[i] += tdlMroGridUser.getMaxRsrp(i);
			maxUnRsrps[i] += tdlMroGridUser.getMaxUnRsrp(i);
			maxTeRsrps[i] += tdlMroGridUser.getMaxTeRsrp(i);
			maxInterRsrps[i] += tdlMroGridUser.getMaxInterRsrp(i);
		}
		
		scRsrpSum += tdlMroGridUser.getScRsrpSum();
		maxRsrpSum += tdlMroGridUser.getMaxRsrpSum();
		maxUnRsrpSum += tdlMroGridUser.getMaxUnRsrpSum();
		maxTeRsrpSum += tdlMroGridUser.getMaxTeRsrpSum();
		maxInterRsrpSum += tdlMroGridUser.getMaxInterRsrpSum();
		
		int rsrpCnt = tdlMroGridUser.getScRsrpCnt();
		int rsrpMaxCnt = tdlMroGridUser.getMaxRsrpCnt();
		int rsrpMaxUnCnt = tdlMroGridUser.getMaxUnRsrpCnt();
		int rsrpMaxTeCnt = tdlMroGridUser.getMaxTeRsrpCnt();
		int rsrpMaxInterCnt = tdlMroGridUser.getMaxInterRsrpCnt();
		
		scRsrpCnt += rsrpCnt;
		maxRsrpCnt += rsrpMaxCnt;
		maxUnRsrpCnt += rsrpMaxUnCnt;
		maxTeRsrpCnt += rsrpMaxTeCnt;
		maxInterRsrpCnt += rsrpMaxInterCnt;
		
		int rsrpCntWeak = tdlMroGridUser.getScRsrpCntWeak();
		int rsrpMaxCntWeak = tdlMroGridUser.getMaxRsrpCntWeak();
		int rsrpMaxUnCntWeak = tdlMroGridUser.getMaxUnRsrpCntWeak();
		int rsrpMaxTeCntWeak = tdlMroGridUser.getMaxTeRsrpCntWeak();
		int rsrpMaxInterCntWeak = tdlMroGridUser.getMaxInterRsrpCntWeak();
		
		scRsrpCntWeak += rsrpCntWeak;
		maxRsrpCntWeak += rsrpMaxCntWeak;
		maxUnRsrpCntWeak += rsrpMaxUnCntWeak;
		maxTeRsrpCntWeak += rsrpMaxTeCntWeak;
		maxInterRsrpCntWeak += rsrpMaxInterCntWeak;
		
		int rsrpCntWeakL2 = tdlMroGridUser.getScRsrpCntWeakL2();
		int rsrpMaxCntWeakL2 = tdlMroGridUser.getMaxRsrpCntWeakL2();
		int rsrpMaxUnCntWeakL2 = tdlMroGridUser.getMaxUnRsrpCntWeakL2();
		int rsrpMaxTeCntWeakL2 = tdlMroGridUser.getMaxTeRsrpCntWeakL2();
		int rsrpMaxInterCntWeakL2 = tdlMroGridUser.getMaxInterRsrpCntWeakL2();
		
		scRsrpCntWeakL2 += rsrpCntWeakL2;
		maxRsrpCntWeakL2 += rsrpMaxCntWeakL2;
		maxUnRsrpCntWeakL2 += rsrpMaxUnCntWeakL2;
		maxTeRsrpCntWeakL2 += rsrpMaxTeCntWeakL2;
		maxInterRsrpCntWeakL2 += rsrpMaxInterCntWeakL2;
		
		grids.add(gridId);
		if (rsrpCnt > 100) {
			effectiveGrids.add(gridId);
			if (div(rsrpCntWeak, rsrpCnt) > 0.1) {
				weakCoverGrids.add(gridId);
			}
			if (div(rsrpCntWeakL2, rsrpCnt) > 0.1) {
				weakL2CoverGrids.add(gridId);
			}
		}
		
		if (rsrpMaxCnt > 100) {
			maxEffectiveGrids.add(gridId);
			if (div(maxRsrpCntWeak, rsrpMaxCnt) > 0.1) {
				maxWeakCoverGrids.add(gridId);
			}
			if (div(maxRsrpCntWeakL2, rsrpMaxCnt) > 0.1) {
				maxWeakL2CoverGrids.add(gridId);
			}
		}
		
		if (rsrpMaxUnCnt > 100) {
			maxUnEffectiveGrids.add(gridId);
			if (div(rsrpMaxUnCntWeak, rsrpMaxUnCnt) > 0.1) {
				maxUnWeakCoverGrids.add(gridId);
			}
			if (div(rsrpMaxUnCntWeakL2, rsrpMaxUnCnt) > 0.1) {
				maxUnWeakL2CoverGrids.add(gridId);
			}
		}
		
		if (rsrpMaxTeCnt > 100) {
			maxTeEffectiveGrids.add(gridId);
			if (div(rsrpMaxTeCntWeak, rsrpMaxTeCnt) > 0.1) {
				maxTeWeakCoverGrids.add(gridId);
			}
			if (div(rsrpMaxTeCntWeakL2, rsrpMaxTeCnt) > 0.1) {
				maxTeWeakL2CoverGrids.add(gridId);
			}
		}
		
		if (rsrpMaxInterCnt > 100) {
			maxInterEffectiveGrids.add(gridId);
			if (div(rsrpMaxInterCntWeak, rsrpMaxInterCnt) > 0.1) {
				maxInterWeakCoverGrids.add(gridId);
			}
			if (div(rsrpMaxInterCntWeakL2, rsrpMaxInterCnt) > 0.1) {
				maxInterWeakL2CoverGrids.add(gridId);
			}
		}
	}
	
	public String getRsrpLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(scRsrps[i]).append(_splitStr);
		}
		line.append(scRsrpSum).append(_splitStr).append(scRsrpCnt).append(_splitStr).append(scRsrpCntWeak).append(_splitStr).append(div(scRsrpSum, scRsrpCnt)).append(_splitStr).append(div((double) scRsrpCntWeak, scRsrpCnt)).append(_splitStr)
			.append(grids.size()).append(_splitStr).append(effectiveGrids.size()).append(_splitStr).append(weakCoverGrids.size()).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxRsrps[i]).append(_splitStr);
		}
		line.append(maxRsrpSum).append(_splitStr).append(maxRsrpCnt).append(_splitStr).append(maxRsrpCntWeak).append(_splitStr).append(div(maxRsrpSum, maxRsrpCnt)).append(_splitStr).append(div((double) maxRsrpCntWeak, maxRsrpCnt)).append(_splitStr)
			.append(maxEffectiveGrids.size()).append(_splitStr).append(maxWeakCoverGrids.size()).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxUnRsrps[i]).append(_splitStr);
		}
		line.append(maxUnRsrpSum).append(_splitStr).append(maxUnRsrpCnt).append(_splitStr).append(maxUnRsrpCntWeak).append(_splitStr).append(div(maxUnRsrpSum, maxUnRsrpCnt)).append(_splitStr).append(div((double) maxUnRsrpCntWeak, maxUnRsrpCnt)).append(_splitStr)
			.append(maxUnEffectiveGrids.size()).append(_splitStr).append(maxUnWeakCoverGrids.size()).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxTeRsrps[i]).append(_splitStr);
		}
		line.append(maxTeRsrpSum).append(_splitStr).append(maxTeRsrpCnt).append(_splitStr).append(maxTeRsrpCntWeak).append(_splitStr).append(div(maxTeRsrpSum, maxTeRsrpCnt)).append(_splitStr).append(div((double) maxTeRsrpCntWeak, maxTeRsrpCnt)).append(_splitStr)
			.append(maxTeEffectiveGrids.size()).append(_splitStr).append(maxTeWeakCoverGrids.size()).append(_splitStr);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxInterRsrps[i]).append(_splitStr);
		}
		line.append(maxInterRsrpSum).append(_splitStr).append(maxInterRsrpCnt).append(_splitStr).append(maxInterRsrpCntWeak).append(_splitStr).append(div(maxInterRsrpSum, maxInterRsrpCnt)).append(_splitStr).append(div((double) maxInterRsrpCntWeak, maxInterRsrpCnt)).append(_splitStr)
			.append(maxInterEffectiveGrids.size()).append(_splitStr).append(maxInterWeakCoverGrids.size()).append(_splitStr)
			.append(scRsrpCntWeakL2).append(_splitStr).append(div(scRsrpCntWeakL2, scRsrpCnt)).append(_splitStr).append(weakL2CoverGrids.size()).append(_splitStr)
			.append(maxRsrpCntWeakL2).append(_splitStr).append(div(maxRsrpCntWeakL2, maxRsrpCnt)).append(_splitStr).append(maxWeakL2CoverGrids.size()).append(_splitStr)
			.append(maxUnRsrpCntWeakL2).append(_splitStr).append(div(maxUnRsrpCntWeakL2, maxUnRsrpCnt)).append(_splitStr).append(maxUnWeakL2CoverGrids.size()).append(_splitStr)
			.append(maxTeRsrpCntWeakL2).append(_splitStr).append(div(maxTeRsrpCntWeakL2, maxTeRsrpCnt)).append(_splitStr).append(maxTeWeakL2CoverGrids.size()).append(_splitStr)
			.append(maxInterRsrpCntWeakL2).append(_splitStr).append(div(maxInterRsrpCntWeakL2, maxInterRsrpCnt)).append(_splitStr).append(maxInterWeakL2CoverGrids.size());
		return line.toString();
	}
	
	private double div(double numerator, int denominator) {
		if (denominator == 0) {
			return 0;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro.sum;

import java.util.List;

public class TdlMroMgrsGridEutr {
	private List<String> _variableTabs = null;
	private String _splitStr = "";
	private final int rsrpLen = 12;
	private int[] scRsrps = new int[rsrpLen];
	private double scRsrpSum = 0;
	private int scRsrpCnt = 0;
	private int scRsrpCntWeak = 0;
	private int scRsrpCntWeakL2 = 0;
	private int[] scRsrpCntType = new int[4];
	private int[] scRsrpCntWeakType = new int[4];
	private int[] maxRsrps = new int[rsrpLen];
	private double maxRsrpSum = 0;
	private int maxRsrpCnt = 0;
	private int maxRsrpCntWeak = 0;
	private int maxRsrpCntWeakL2 = 0;
	private int[] maxRsrpCntType = new int[4];
	private int[] maxRsrpCntWeakType = new int[4];
	private int[] maxUnRsrps = new int[rsrpLen];
	private double maxUnRsrpSum = 0;
	private int maxUnRsrpCnt = 0;
	private int maxUnRsrpCntWeak = 0;
	private int maxUnRsrpCntWeakL2 = 0;
	private int[] maxUnRsrpCntType = new int[4];
	private int[] maxUnRsrpCntWeakType = new int[4];
	private int[] maxTeRsrps = new int[rsrpLen];
	private double maxTeRsrpSum = 0;
	private int maxTeRsrpCnt = 0;
	private int maxTeRsrpCntWeak = 0;
	private int maxTeRsrpCntWeakL2 = 0;
	private int[] maxTeRsrpCntType = new int[4];
	private int[] maxTeRsrpCntWeakType = new int[4];
	private int[] maxInterRsrps = new int[rsrpLen];
	private double maxInterRsrpSum = 0;
	private int maxInterRsrpCnt = 0;
	private int maxInterRsrpCntWeak = 0;
	private int maxInterRsrpCntWeakL2 = 0;
	private int[] maxInterRsrpCntType = new int[4];
	private int[] maxInterRsrpCntWeakType = new int[4];
	private final int rsrqLen = 8;
	private int[] scRsrqs = new int[rsrqLen];
	private double scRsrqSum = 0;
	private int scRsrqCnt = 0;
	private final int sinrUlLen = 7;
	private int[] sinrUls = new int[sinrUlLen];
	private double sinrUlSum = 0;
	private int sinrUlCnt = 0;
	private final int phrLen = 6;
	private int[] phrs = new int[phrLen];
	private double phrSum = 0;
	private int phrCnt = 0;
	private int sinrDlLen = 57;
	private int[] sinrDls = new int[sinrDlLen];
	private double sinrDlSum = 0;
	private int sinrDlCnt = 0;
	
	public TdlMroMgrsGridEutr(List<String> variableTabs, String splitStr) {
		_variableTabs = variableTabs;
		_splitStr = splitStr;
		
		for (int i = 0; i < rsrpLen; i++) {
			scRsrps[i] = 0;
			maxRsrps[i] = 0;
			maxUnRsrps[i] = 0;
			maxTeRsrps[i] = 0;
			maxInterRsrps[i] = 0;
		}
		
		for (int i = 0; i < 4; i++) {
			scRsrpCntType[i] = 0;
			scRsrpCntWeakType[i] = 0;
			maxRsrpCntType[i] = 0;
			maxRsrpCntWeakType[i] = 0;
			maxUnRsrpCntType[i] = 0;
			maxUnRsrpCntWeakType[i] = 0;
			maxTeRsrpCntType[i] = 0;
			maxTeRsrpCntWeakType[i] = 0;
			maxInterRsrpCntType[i] = 0;
			maxInterRsrpCntWeakType[i] = 0;
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			scRsrqs[i] = 0;
		}
		
		for (int i = 0; i < sinrUlLen; i++) {
			sinrUls[i] = 0;
		}
		
		for (int i = 0; i < phrLen; i++) {
			phrs[i] = 0;
		}
	}
	
	public void setValue(TdlMroGridUser tdlMroGridUser, int userType) {
		if (_variableTabs.contains("tdl_mro_mgrs_rsrp_eutr_u")) {
			setRsrp(tdlMroGridUser, userType);
		}
		
		if (_variableTabs.contains("tdl_mro_mgrs_rsrq_eutr_u")) {
			setRsrq(tdlMroGridUser);
		}
		
		if (_variableTabs.contains("tdl_mro_mgrs_sinru_eutr_u")) {
			setSinrUl(tdlMroGridUser);
		}
		
		if (_variableTabs.contains("tdl_mro_mgrs_phr_eutr_u")) {
			setPhr(tdlMroGridUser);
		}
		
		if (_variableTabs.contains("tdl_mro_mgrs_sinrd_eutr_u")) {
			setSinrDl(tdlMroGridUser);
		}
	}
	
	public String getRsrpLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(scRsrps[i]).append(_splitStr);
		}
		line.append(scRsrpSum).append(_splitStr).append(scRsrpCnt).append(_splitStr).append(scRsrpCntWeak).append(_splitStr).append(div(scRsrpSum, scRsrpCnt)).append(_splitStr).append(div((double) scRsrpCntWeak, scRsrpCnt)).append(_splitStr);
		for (int i = 0; i < 4; i++) {
			line.append(scRsrpCntType[i]).append(_splitStr).append(scRsrpCntWeakType[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxRsrps[i]).append(_splitStr);
		}
		line.append(maxRsrpSum).append(_splitStr).append(maxRsrpCnt).append(_splitStr).append(maxRsrpCntWeak).append(_splitStr).append(div(maxRsrpSum, maxRsrpCnt)).append(_splitStr).append(div((double) maxRsrpCntWeak, maxRsrpCnt)).append(_splitStr);
		for (int i = 0; i < 4; i++) {
			line.append(maxRsrpCntType[i]).append(_splitStr).append(maxRsrpCntWeakType[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxUnRsrps[i]).append(_splitStr);
		}
		line.append(maxUnRsrpSum).append(_splitStr).append(maxUnRsrpCnt).append(_splitStr).append(maxUnRsrpCntWeak).append(_splitStr).append(div(maxUnRsrpSum, maxUnRsrpCnt)).append(_splitStr).append(div((double) maxUnRsrpCntWeak, maxUnRsrpCnt)).append(_splitStr);
		for (int i = 0; i < 4; i++) {
			line.append(maxUnRsrpCntType[i]).append(_splitStr).append(maxUnRsrpCntWeakType[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxTeRsrps[i]).append(_splitStr);
		}
		line.append(maxTeRsrpSum).append(_splitStr).append(maxTeRsrpCnt).append(_splitStr).append(maxTeRsrpCntWeak).append(_splitStr).append(div(maxTeRsrpSum, maxTeRsrpCnt)).append(_splitStr).append(div((double) maxTeRsrpCntWeak, maxTeRsrpCnt)).append(_splitStr);
		for (int i = 0; i < 4; i++) {
			line.append(maxTeRsrpCntType[i]).append(_splitStr).append(maxTeRsrpCntWeakType[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(maxInterRsrps[i]).append(_splitStr);
		}
		line.append(maxInterRsrpSum).append(_splitStr).append(maxInterRsrpCnt).append(_splitStr).append(maxInterRsrpCntWeak).append(_splitStr).append(div(maxInterRsrpSum, maxInterRsrpCnt)).append(_splitStr).append(div((double) maxInterRsrpCntWeak, maxInterRsrpCnt)).append(_splitStr);
		for (int i = 0; i < 4; i++) {
			line.append(maxInterRsrpCntType[i]).append(_splitStr).append(maxInterRsrpCntWeakType[i]).append(_splitStr);
		}
		line.append(scRsrpCntWeakL2).append(_splitStr).append(div((double) scRsrpCntWeakL2, scRsrpCnt)).append(_splitStr)
			.append(maxRsrpCntWeakL2).append(_splitStr).append(div((double) maxRsrpCntWeakL2, maxRsrpCnt)).append(_splitStr)
			.append(maxUnRsrpCntWeakL2).append(_splitStr).append(div((double) maxUnRsrpCntWeakL2, maxUnRsrpCnt)).append(_splitStr)
			.append(maxTeRsrpCntWeakL2).append(_splitStr).append(div((double) maxTeRsrpCntWeakL2, maxTeRsrpCnt)).append(_splitStr)
			.append(maxInterRsrpCntWeakL2).append(_splitStr).append(div((double) maxInterRsrpCntWeakL2, maxInterRsrpCnt));
		return line.toString();
	}
	
	public String getRsrqLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rsrqLen; i++) {
			line.append(scRsrqs[i]).append(_splitStr);
		}
		line.append(scRsrqSum).append(_splitStr).append(scRsrqCnt);
		return line.toString();
	}
	
	public String getSinrUlLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < sinrUlLen; i++) {
			line.append(sinrUls[i]).append(_splitStr);
		}
		line.append(sinrUlSum).append(_splitStr).append(sinrUlCnt);
		return line.toString();
	}
	
	public String getPhrLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < phrLen; i++) {
			line.append(phrs[i]).append(_splitStr);
		}
		line.append(phrSum).append(_splitStr).append(phrCnt);
		return line.toString();
	}
	
	public String getSinrDlLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < sinrDlLen; i++) {
			line.append(sinrDls[i]).append(_splitStr);
		}
		line.append(sinrDlSum).append(_splitStr).append(sinrDlCnt);
		return line.toString();
	}
	
	private void setRsrp(TdlMroGridUser tdlMroGridUser, int userType) {
		for (int i = 0; i < rsrpLen; i++) {
			scRsrps[i] += tdlMroGridUser.getScRsrp(i);
			maxRsrps[i] += tdlMroGridUser.getMaxRsrp(i);
			maxUnRsrps[i] += tdlMroGridUser.getMaxUnRsrp(i);
			maxTeRsrps[i] += tdlMroGridUser.getMaxTeRsrp(i);
			maxInterRsrps[i] += tdlMroGridUser.getMaxInterRsrp(i);
		}
		
		scRsrpSum += tdlMroGridUser.getScRsrpSum();
		maxRsrpSum += tdlMroGridUser.getMaxRsrpSum();
		maxUnRsrpSum += tdlMroGridUser.getMaxUnRsrpSum();
		maxTeRsrpSum += tdlMroGridUser.getMaxTeRsrpSum();
		maxInterRsrpSum += tdlMroGridUser.getMaxInterRsrpSum();
		
		int rsrpCnt = tdlMroGridUser.getScRsrpCnt();
		int rsrpMaxCnt = tdlMroGridUser.getMaxRsrpCnt();
		int rsrpMaxUnCnt = tdlMroGridUser.getMaxUnRsrpCnt();
		int rsrpMaxTeCnt = tdlMroGridUser.getMaxTeRsrpCnt();
		int rsrpMaxInterCnt = tdlMroGridUser.getMaxInterRsrpCnt();
		
		scRsrpCnt += rsrpCnt;
		maxRsrpCnt += rsrpMaxCnt;
		maxUnRsrpCnt += rsrpMaxUnCnt;
		maxTeRsrpCnt += rsrpMaxTeCnt;
		maxInterRsrpCnt += rsrpMaxInterCnt;
		
		int rsrpCntWeak = tdlMroGridUser.getScRsrpCntWeak();
		int rsrpMaxCntWeak = tdlMroGridUser.getMaxRsrpCntWeak();
		int rsrpMaxUnCntWeak = tdlMroGridUser.getMaxUnRsrpCntWeak();
		int rsrpMaxTeCntWeak = tdlMroGridUser.getMaxTeRsrpCntWeak();
		int rsrpMaxInterCntWeak = tdlMroGridUser.getMaxInterRsrpCntWeak();
		
		scRsrpCntWeak += rsrpCntWeak;
		maxRsrpCntWeak += rsrpMaxCntWeak;
		maxUnRsrpCntWeak += rsrpMaxUnCntWeak;
		maxTeRsrpCntWeak += rsrpMaxTeCntWeak;
		maxInterRsrpCntWeak += rsrpMaxInterCntWeak;
		
		scRsrpCntWeakL2 += tdlMroGridUser.getScRsrpCntWeakL2();
		maxRsrpCntWeakL2 += tdlMroGridUser.getMaxRsrpCntWeakL2();
		maxUnRsrpCntWeakL2 += tdlMroGridUser.getMaxUnRsrpCntWeakL2();
		maxTeRsrpCntWeakL2 += tdlMroGridUser.getMaxTeRsrpCntWeakL2();
		maxInterRsrpCntWeakL2 += tdlMroGridUser.getMaxInterRsrpCntWeakL2();
		
		if (userType >=0 && userType < 4) {
			scRsrpCntType[userType] += rsrpCnt;
			maxRsrpCntType[userType] += rsrpMaxCnt;
			maxUnRsrpCntType[userType] += rsrpMaxUnCnt;
			maxTeRsrpCntType[userType] += rsrpMaxTeCnt;
			maxInterRsrpCntType[userType] += rsrpMaxInterCnt;
			
			scRsrpCntWeakType[userType] += rsrpCntWeak;
			maxRsrpCntWeakType[userType] += rsrpMaxCntWeak;
			maxUnRsrpCntWeakType[userType] += rsrpMaxUnCntWeak;
			maxTeRsrpCntWeakType[userType] += rsrpMaxTeCntWeak;
			maxInterRsrpCntWeakType[userType] += rsrpMaxInterCntWeak;
		}
	}
	
	private void setRsrq(TdlMroGridUser tdlMroGridUser) {
		for (int i = 0; i < rsrqLen; i++) {
			scRsrqs[i] += tdlMroGridUser.getScRsrq(i);
		}
		scRsrqSum += tdlMroGridUser.getScRsrqSum();
		scRsrqCnt += tdlMroGridUser.getScRsrqCnt();
	}
	
	private void setSinrUl(TdlMroGridUser tdlMroGridUser) {
		for (int i = 0; i < sinrUlLen; i++) {
			sinrUls[i] += tdlMroGridUser.getSinrUl(i);
		}
		sinrUlSum += tdlMroGridUser.getSinrUlSum();
		sinrUlCnt += tdlMroGridUser.getSinrUlCnt();
	}
	
	private void setPhr(TdlMroGridUser tdlMroGridUser) {
		for (int i = 0; i < phrLen; i++) {
			phrs[i] += tdlMroGridUser.getPhr(i);
		}
		phrSum += tdlMroGridUser.getPhrSum();
		phrCnt += tdlMroGridUser.getPhrCnt();
	}
	
	private void setSinrDl(TdlMroGridUser tdlMroGridUser) {
		for (int i = 0; i < sinrDlLen; i++) {
			sinrDls[i] += tdlMroGridUser.getSinrDl(i);
		}
		sinrDlSum += tdlMroGridUser.getSinrDlSum();
		sinrDlCnt += tdlMroGridUser.getSinrDlCnt();
	}
	
	private double div(double numerator, int denominator) {
		if (denominator == 0) {
			return 0;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.boco.wangyou.algorithm.counter.AoaParse;
import com.boco.wangyou.algorithm.counter.NumOfAdjParse;
import com.boco.wangyou.algorithm.counter.PhrParse;
import com.boco.wangyou.algorithm.counter.RipParse;
import com.boco.wangyou.algorithm.counter.RsrpParse;
import com.boco.wangyou.algorithm.counter.RsrqParse;
import com.boco.wangyou.algorithm.counter.RssiParse;
import com.boco.wangyou.algorithm.counter.SinrDLParse;
import com.boco.wangyou.algorithm.counter.SinrULParse;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroAdj;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroEutr;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroGrid;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroGridUser;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroGridUserAdj;
import com.boco.wangyou.ltemr.parse.entity.mro.sum.TdlMroGsmAdj;
import com.boco.wangyou.utility.ini.entity.GsmNcIniInfo;
import com.boco.wangyou.utility.ini.entity.LteNcIniInfo;

public class TdlMroData {
	private TdlMroEutr tdlMroEutr = null;
	private Map<String, TdlMroAdj> mapAdj = new HashMap<String, TdlMroAdj>(200);
	private Map<String, TdlMroGsmAdj> mapGsmAdj = new HashMap<String, TdlMroGsmAdj>(200);
	private Map<String, TdlMroGrid> mapGrid = new HashMap<String, TdlMroGrid>(2000);
	private Map<String, Map<Integer, TdlMroGridUser>> mapGridUser = new HashMap<String, Map<Integer, TdlMroGridUser>>(2000);
	private Map<String, Map<String, Map<Integer, TdlMroGridUserAdj>>> mapGridUserAdj = new HashMap<String, Map<String, Map<Integer, TdlMroGridUserAdj>>>(2000);
	private RsrpParse rsrpParse = new RsrpParse();
	private RsrqParse rsrqParse = new RsrqParse();
	private NumOfAdjParse numOfAdjParse = new NumOfAdjParse();
	private SinrULParse sinrULParse = new SinrULParse();
	private PhrParse phrParse = new PhrParse();
	private SinrDLParse sinrDLParse = new SinrDLParse();
	private AoaParse aoaParse = new AoaParse();
	private RipParse ripParse = new RipParse();
	private RssiParse rssiParse = new RssiParse();
	private List<String> _variableTabs = null;
	private String _splitStr = "";
	
	public TdlMroData(List<String> variableTabs, String splitStr) {
		tdlMroEutr = new TdlMroEutr(variableTabs, splitStr);
		
		_variableTabs = variableTabs;
		_splitStr = splitStr;
	}
	
	public void makeEutrInfo(TdlMroGridUe gridUe) {
		tdlMroEutr.setValue(gridUe, rsrpParse, numOfAdjParse, sinrULParse, aoaParse);
	}
	
	public void makeRipInfo(int rip) {
		tdlMroEutr.setRipValue(rip, ripParse);
	}
	
	public void makeAdjInfo(LteNcIniInfo ncIniInfo, TdlMroGridUe gridUe, MroGridInfo gridInfo, int idx, int rsrpWeak) {
		String ncCellKey = ncIniInfo.getCellId();
		TdlMroAdj tdlMroAdj = null;
		if (mapAdj.containsKey(ncCellKey)) {
			tdlMroAdj = mapAdj.get(ncCellKey);
		} else {
			tdlMroAdj = new TdlMroAdj(_variableTabs, _splitStr, rsrpWeak, ncIniInfo.getDistance());
		}
		tdlMroAdj.setValue(gridUe, gridInfo, idx, rsrpParse);
		mapAdj.put(ncCellKey, tdlMroAdj);
	}
	
	public void makeGsmAdjInfo(GsmNcIniInfo ncGsmKey, TdlMroGridUe gridUe, int idx) {
		String adjKey = ncGsmKey.getCellId();
		TdlMroGsmAdj tdlMroGsmAdj = null;
		if (mapGsmAdj.containsKey(adjKey)) {
			tdlMroGsmAdj = mapGsmAdj.get(adjKey);
		} else {
			tdlMroGsmAdj = new TdlMroGsmAdj(_splitStr, ncGsmKey);
		}
		tdlMroGsmAdj.setValue(gridUe, idx, rsrpParse, rssiParse);
		mapGsmAdj.put(adjKey, tdlMroGsmAdj);
	}
	
	public void makeGridInfo(TdlMroGridUe gridUe, MroGridInfo gridInfo) {
		String gridKey = gridInfo.getGridId();
		TdlMroGrid tdlMroGrid = null;
		if (mapGrid.containsKey(gridKey)) {
			tdlMroGrid = mapGrid.get(gridKey);
		} else {
			tdlMroGrid = new TdlMroGrid(_splitStr);
		}
		tdlMroGrid.setValue(gridUe, numOfAdjParse);
		mapGrid.put(gridKey, tdlMroGrid);
	}
	
	public void makeGridUserInfo(TdlMroGridUe gridUe, MroGridInfo gridInfo, int rsrpWeak, int size) {
		String gridKey = "";
		if (size == 50) {
			gridKey = gridInfo.getGridId();
		} else {
			int idx = gridInfo.getSizeIdx(size);
			if (idx == -1 || idx >= 7) {
				return;
			}
			gridKey = gridInfo.getGridIds(idx);
		}
		
		int userKey = gridInfo.getUserType();
		Map<Integer, TdlMroGridUser> mapUser = null;
		TdlMroGridUser tdlMroGridUser = null;
		if (mapGridUser.containsKey(gridKey)) {
			mapUser = mapGridUser.get(gridKey);
			if (mapUser.containsKey(userKey)) {
				tdlMroGridUser = mapUser.get(userKey);
			} else {
				tdlMroGridUser = new TdlMroGridUser(_variableTabs, _splitStr, rsrpWeak);
			}
		} else {
			mapUser = new HashMap<Integer, TdlMroGridUser>(10);
			tdlMroGridUser = new TdlMroGridUser(_variableTabs, _splitStr, rsrpWeak);
		}
		tdlMroGridUser.setValue(gridUe, rsrpParse, rsrqParse, sinrULParse, phrParse, sinrDLParse);
		mapUser.put(userKey, tdlMroGridUser);
		mapGridUser.put(gridKey, mapUser);
	}
	
	public void makeGridAdjInfo(String ncCellKey, TdlMroGridUe gridUe, MroGridInfo gridInfo, int idx, int rsrpWeak, int size) {
		String gridKey = "";
		if (size == 50) {
			gridKey = gridInfo.getGridId();
		} else {
			int gridIdx = gridInfo.getSizeIdx(size);
			if (gridIdx == -1 || gridIdx >= 7) {
				return;
			}
			gridKey = gridInfo.getGridIds(gridIdx);
		}
		int userType = gridInfo.getUserType();
		
		Map<String, Map<Integer, TdlMroGridUserAdj>> mapAdj = null;
		Map<Integer, TdlMroGridUserAdj> mapUser = null;
		TdlMroGridUserAdj tdlMroGridUserAdj = null;
		if (mapGridUserAdj.containsKey(gridKey)) {
			mapAdj = mapGridUserAdj.get(gridKey);
			if (mapAdj.containsKey(ncCellKey)) {
				mapUser = mapAdj.get(ncCellKey);
				if (mapUser.containsKey(userType)) {
					tdlMroGridUserAdj = mapUser.get(userType);
				} else {
					tdlMroGridUserAdj = new TdlMroGridUserAdj(_splitStr, rsrpWeak);
				}
			} else {
				mapUser = new HashMap<Integer, TdlMroGridUserAdj>(10);
				tdlMroGridUserAdj = new TdlMroGridUserAdj(_splitStr, rsrpWeak);
			}
		} else {
			mapUser = new HashMap<Integer, TdlMroGridUserAdj>(10);
			mapAdj = new HashMap<String, Map<Integer, TdlMroGridUserAdj>>(100);
			tdlMroGridUserAdj = new TdlMroGridUserAdj(_splitStr, rsrpWeak);
		}
		tdlMroGridUserAdj.setValue(gridUe, gridInfo, idx, rsrpParse);
		mapUser.put(userType, tdlMroGridUserAdj);
		mapAdj.put(ncCellKey, mapUser);
		mapGridUserAdj.put(gridKey, mapAdj);
	}
	
	public TdlMroEutr getEutr() {
		return tdlMroEutr;
	}
	
	public Map<String, TdlMroAdj> getAdj() {
		return mapAdj;
	}
	
	public Map<String, TdlMroGsmAdj> getGsmAdj() {
		return mapGsmAdj;
	}
	
	public Map<String, TdlMroGrid> getGrid() {
		return mapGrid;
	}
	
	public Map<String, Map<Integer, TdlMroGridUser>> getGridUser() {
		return mapGridUser;
	}
	
	public Map<String, Map<String, Map<Integer, TdlMroGridUserAdj>>> getGridUserAdj() {
		return mapGridUserAdj;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro;

import java.util.ArrayList;
import java.util.List;

import com.boco.wangyou.algorithm.counter.FreqParse;
import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;
import com.boco.wangyou.ltemr.parse.entity.SmrValue;
import com.boco.wangyou.utility.ini.entity.LteIniInfo;

public class TdlMroGridUe {
	private int lteScRsrp = -1;
	private int lteScRsrq = -1;
	private int lteScTadv = -1;
	private int lteScAoa = -1;
	private String lteScEarfcn = "";
	private String lteScPci = "";
	private int lteScSinrUL = -1;
	private int lteScPhr = -1;
	private int maxRsrp = -1;
	private String maxRsrpEarfcn = "-99999";
	private String maxRsrpPci = "-99999";
	private int unMaxRsrp = -1;
	private String unMaxRsrpEarfcn = "-99999";
	private String unMaxRsrpPci = "-99999";
	private int teMaxRsrp = -1;
	private String teMaxRsrpEarfcn = "-99999";
	private String teMaxRsrpPci = "-99999";
	private int[] diff6Num = new int[3];
	private int[] diff10Num = new int[3];
	private List<LteNcInfo> lteNcList = new ArrayList<LteNcInfo>(10);
	private List<String> earfcnPciList = new ArrayList<String>(10);
	private int scFreq = -1;
	private int scFreqBand = -1;
	private boolean freqFlag = false;
	private boolean freqFlagBand = false;
	private List<Integer> rssis = new ArrayList<Integer>(10);
	private List<String> bcchBsicList = new ArrayList<String>(10);
	private double ncRsrpDbm = 0;
	private int sinr = -999;
	private SmrValue _smr = null;
	private FreqParse _freqParse = null;
	private String _splitStr = "";
	
	public TdlMroGridUe(SmrValue smr, FreqParse freqParse, String splitStr) {
		_splitStr = splitStr;
		_smr = smr;
		_freqParse = freqParse;
		
		for (int i = 0; i < 3; i++) {
			diff6Num[i] = 0;
			diff10Num[i] = 0;
		}
	}
	
	public void setValue(String[] valueItems, MrIdxInfo idxInfo, int len, LteIniInfo iniInfo) {
		if (len != idxInfo.getLen()) {
			return;
		}
		
		setScValue(valueItems, idxInfo, len, iniInfo);
		setNcValue(valueItems, idxInfo, len);
	}
	
	public void setNcValue(String[] valueItems, MrIdxInfo idxInfo, int len) {
		if (len != idxInfo.getLen()) {
			return;
		}
		
		int ncRsrp = Integer.parseInt(_smr.getValue("ltencrsrp", valueItems, idxInfo, len));
		if (ncRsrp != -1) {
			makeNcRsrpValue(valueItems, idxInfo, ncRsrp, len);
		}
		
		int ncRssi = Integer.parseInt(_smr.getValue("gsmncellcarrierrssi", valueItems, idxInfo, len));
		if (ncRssi != -1) {
			makeNcRssiValue(valueItems, idxInfo, ncRssi, len);
		}
	}
	
	public String getLine1(StringBuffer line) {
		line.setLength(0);
		line.append(lteScRsrp).append(_splitStr).append(lteScRsrq).append(_splitStr).append(-9999).append(_splitStr).append(-9999).append(_splitStr)
			.append(lteScTadv).append(_splitStr).append(lteScAoa).append(_splitStr).append(lteScEarfcn).append(_splitStr).append(lteScPci);
		int len = lteNcList.size();
		int cnt = 0;
		for (int i = 0; i < len; i++) {
			if (lteNcList.get(i).getIsp() == 0) {
				line.append(_splitStr).append(lteNcList.get(i).getEarfcnPci());
				cnt++;
			}
			if (cnt == 6) {
				break;
			}
		}
		for (int i = 6 - cnt; i > 0; i--) {
			line.append(_splitStr).append(_splitStr);
		}
		return line.toString();
	}
	
	public String getLine2(StringBuffer line) {
		line.setLength(0);
		line.append(maxRsrp).append(_splitStr).append(unMaxRsrp).append(_splitStr).append(teMaxRsrp).append(_splitStr).append(lteScSinrUL).append(_splitStr).append(lteScPhr)
			.append(_splitStr).append(diff6Num[0]).append(_splitStr).append(diff10Num[0]).append(_splitStr).append(maxRsrpEarfcn).append(_splitStr).append(maxRsrpPci)
			.append(_splitStr).append(unMaxRsrpEarfcn).append(_splitStr).append(unMaxRsrpPci).append(_splitStr).append(teMaxRsrpEarfcn).append(_splitStr).append(teMaxRsrpPci)
			.append(_splitStr).append(lteScEarfcn).append(_splitStr).append(lteScPci);
		return line.toString();
	}
		
	public String getLine3(StringBuffer line) {
		line.setLength(0);
		int len = lteNcList.size();
		int cnt = 0;
		for (int i = 0; i < len; i++) {
			if (lteNcList.get(i).getIsp() == 0) {
				line.append(lteNcList.get(i).getRsrp()).append(_splitStr);
				cnt++;
			}
			if (cnt == 6) {
				break;
			}
		}
		for (int i = 6 - cnt; i > 0; i--) {
			line.append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public String getLteScEarfcn() {
		return lteScEarfcn;
	}
	
	public String getLteScPci() {
		return lteScPci;
	}
	
	public int getRsrp() {
		return lteScRsrp;
	}
	
	public int getMaxRsrp() {
		return maxRsrp;
	}
	
	public int getUnMaxRsrp() {
		return unMaxRsrp;
	}
	
	public int getTeMaxRsrp() {
		return teMaxRsrp;
	}
	
	public int getRsrq() {
		return lteScRsrq;
	}
	
	public int getPhr() {
		return lteScPhr;
	}
	
	public int getSinrUl() {
		return lteScSinrUL;
	}
	
	public int getLteScTadv() {
		return lteScTadv;
	}
	
	public int getLteScAoa() {
		return lteScAoa;
	}
	
	public int getDiff6Num(int i) {
		if (i < 0 || i >= 3) {
			return 0;
		}
		return diff6Num[i];
	}
	
	public int getDiff10Num(int i) {
		if (i < 0 || i >= 3) {
			return 0;
		}
		return diff10Num[i];
	}
	
	public boolean getFreqFlag(int i) {
		if (i == 1) {
			return freqFlag;
		} else if (i == 2) {
			return freqFlagBand;
		}
		return false;
	}
	
	public int getNcRsrp(int i) {
		if (i < 0 || i >= lteNcList.size()) {
			return -1;
		}
		return lteNcList.get(i).getRsrp();
	}
	
	public List<LteNcInfo> getLteNcList() {
		return lteNcList;
	}
	
	public int getScFreq() {
		return scFreq;
	}
	
	public int getScFreqBand() {
		return scFreqBand;
	}
	
	public int getNcFreq(int i) {
		if (i < 0 || i >= lteNcList.size()) {
			return -1;
		}
		return lteNcList.get(i).getFreq();
	}
	
	public int getNcFreqBand(int i) {
		if (i < 0 || i >= lteNcList.size()) {
			return -1;
		}
		return lteNcList.get(i).getFreqBand();
	}
	
	public int getNcIsp(int i) {
		if (i < 0 || i >= lteNcList.size()) {
			return -1;
		}
		return lteNcList.get(i).getIsp();
	}
	
	public int getNcRssi(int i) {
		if (i < 0 || i >= rssis.size()) {
			return -1;
		}
		return rssis.get(i);
	}
	
	public String getNcBcchBsic(int i) {
		if (i < 0 || i >= bcchBsicList.size()) {
			return "";
		}
		return bcchBsicList.get(i);
	}
	
	public List<String> getNcBcchBsicList() {
		return bcchBsicList;
	}
	
	public int getNcRsrpDbm() {
		if (ncRsrpDbm <= 0) {
			return 0;
		}
		return (int)(10 * Math.log10(ncRsrpDbm));
	}
	
	public int getSinr() {
		return sinr;
	}
	
	private void setScValue(String[] valueItems, MrIdxInfo idxInfo, int len, LteIniInfo iniInfo) {
		lteScRsrp = Integer.parseInt(_smr.getValue("ltescrsrp", valueItems, idxInfo, len));
		lteScRsrq = Integer.parseInt(_smr.getValue("ltescrsrq", valueItems, idxInfo, len));
		lteScTadv = Integer.parseInt(_smr.getValue("ltesctadv", valueItems, idxInfo, len));
		lteScAoa = Integer.parseInt(_smr.getValue("ltescaoa", valueItems, idxInfo, len));
		lteScEarfcn = _smr.getValue("ltescearfcn", valueItems, idxInfo, len);
		lteScPci = _smr.getValue("ltescpci", valueItems, idxInfo, len);
		if (("-1".equals(lteScEarfcn) || "-1".equals(lteScPci)) && !"".equals(iniInfo.getEarfcn()) && !"".equals(iniInfo.getPci())) {
			lteScEarfcn = iniInfo.getEarfcn();
			lteScPci = iniInfo.getPci();
		}
		lteScSinrUL = Integer.parseInt(_smr.getValue("ltescsinrul", valueItems, idxInfo, len));
		lteScPhr = Integer.parseInt(_smr.getValue("ltescphr", valueItems, idxInfo, len));
		
		maxRsrp = lteScRsrp;
		maxRsrpEarfcn = lteScEarfcn;
		maxRsrpPci = lteScPci;
		
		scFreq = _freqParse.getFreqType(Integer.parseInt(lteScEarfcn));
		scFreqBand = _freqParse.getFreqBandType(scFreq);
		earfcnPciList.add(lteScEarfcn + _splitStr + lteScPci);
		
		double rssi = getRssi();
		int lteScPdschPrbNum = Integer.parseInt(_smr.getValue("ltescpdschprbnum", valueItems, idxInfo, len));
		sinr = getSinr(rssi, lteScPdschPrbNum);
	}
	
	private void makeNcRsrpValue(String[] valueItems, MrIdxInfo idxInfo, int ncRsrp, int len) {
		String ncEarfcn = _smr.getValue("ltencearfcn", valueItems, idxInfo, len);
		String ncPci = _smr.getValue("ltencpci", valueItems, idxInfo, len);
		if ("-1".equals(ncEarfcn) || "-1".equals(ncPci)) {
			return;
		}
		
		String ncEarfcnPci = ncEarfcn + _splitStr + ncPci;
		if (earfcnPciList.contains(ncEarfcnPci)) {
			return;
		}
		earfcnPciList.add(ncEarfcnPci);
		
		int earfcn = Integer.parseInt(ncEarfcn);
		int ncFreq = _freqParse.getFreqType(earfcn);
		int ncFreqBand = _freqParse.getFreqBandType(ncFreq);
		int isp = _freqParse.getISP(earfcn);
		
		LteNcInfo lteNcInfo = new LteNcInfo();
		lteNcInfo.setValue(ncRsrp, ncEarfcnPci, ncFreq, ncFreqBand, isp);
		
		if (isp == 0) {
			if (maxRsrp == -1 || maxRsrp < ncRsrp) {
				maxRsrp = ncRsrp;
				maxRsrpEarfcn = ncEarfcn;
				maxRsrpPci = ncPci;
			}
			
			if (scFreq != -1 && scFreq == ncFreq) {
				freqFlag = true;
			}
			if (scFreqBand != -1 && scFreqBand == ncFreqBand) {
				freqFlagBand = true;
			}
			if (lteScRsrp != -1 && Math.abs(lteScRsrp - ncRsrp) < 6) {
				diff6Num[0]++;
				if (scFreq != -1 && scFreq == ncFreq) {
					diff6Num[1]++;
				}
				if (scFreqBand != -1 && scFreqBand == ncFreqBand) {
					diff6Num[2]++;
				}
			}
			if (lteScRsrp != -1 && Math.abs(lteScRsrp - ncRsrp) < 10) {
				diff10Num[0]++;
				if (scFreq != -1 && scFreq == ncFreq) {
					diff10Num[1]++;
				}
				if (scFreqBand != -1 && scFreqBand == ncFreqBand) {
					diff10Num[2]++;
				}
			}
		}
		
		if (isp == 1) {
			if (unMaxRsrp == -1 || unMaxRsrp < ncRsrp) {
				unMaxRsrp = ncRsrp;
				unMaxRsrpEarfcn = ncEarfcn;
				unMaxRsrpPci = ncPci;
			}
		}
		
		if (isp == 2) {
			if (teMaxRsrp == -1 || teMaxRsrp < ncRsrp) {
				teMaxRsrp = ncRsrp;
				teMaxRsrpEarfcn = ncEarfcn;
				teMaxRsrpPci = ncPci;
			}
		}
		
		ncRsrpDbm += Math.pow(10, ((double) (ncRsrp - 141)) / 10);
		
		int ncLen = lteNcList.size();
		int flag = 0;
		for (int i = ncLen - 1; i >= 0; i--) {
			if (ncRsrp <= lteNcList.get(i).getRsrp()) {
				if (i == ncLen - 1) {
					lteNcList.add(lteNcInfo);
				} else {
					lteNcList.add(i + 1, lteNcInfo);
				}
				flag = 1;
				break;
			}
		}
		if (flag == 0) {
			lteNcList.add(0, lteNcInfo);
		}
	}
	
	private void makeNcRssiValue(String[] valueItems, MrIdxInfo idxInfo, int rssi, int len) {
		String ncc = _smr.getValue("gsmncellncc", valueItems, idxInfo, len);
		String bcc = _smr.getValue("gsmncellbcc", valueItems, idxInfo, len);
		String bcch = _smr.getValue("gsmncellbcch", valueItems, idxInfo, len);
		if ("-1".equals(ncc) || "-1".equals(bcc) || "-1".equals(bcch)) {
			return;
		}
		
		String bcchBsic = ncc + _splitStr + bcc + _splitStr + bcch;
		if (bcchBsicList.contains(bcchBsic)) {
			return;
		}
		
		rssis.add(rssi);
		bcchBsicList.add(bcchBsic);
	}
	
	private double getRssi() {
		if (lteScRsrp == -1 || lteScRsrq == -1) {
			return -1;
		}
		return (double) (20 + (lteScRsrp - 141) - (lteScRsrq * 0.5 - 20));
	}
	
	private int getSinr(double rssi, int lteScPdschPrbNum) {
		if (lteScRsrp == -1 || Math.abs(rssi + 1) < 0.00001) {
			return -999;
		}
		
		int pdsch = (lteScPdschPrbNum == -1) ? 20 : lteScPdschPrbNum;
		double tmp = 1200 * Math.pow(10, (double) (lteScRsrp - 141) / 10) /
				(Math.pow(10, (double) rssi / 10) - 200 * Math.pow(10, (double) (lteScRsrp - 141) / 10) - pdsch * 8 * Math.pow(10, (double) (lteScRsrp - 141 - 3) / 10));
		if (tmp < 0) {
			return -999;
		}
		double sinr = 2 * (10 * Math.log10(tmp)) + 10;
		return (int) Math.floor(sinr);
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro.user;

import com.boco.wangyou.ltemr.parse.entity.MrIdxInfo;

public class MroUserInfo {
	private String _timeStamp = "";
	private int adjNum = 0;
	private int ta = -1;
	private int scRsrp = -1;
	private int phr = -1;
	private int maxRsrp = -1;
	private String maxEarfcnPci = "";
	
	public void setValue(String[] valueItems, MrIdxInfo idxInfo, String timeStamp) {
		if (valueItems.length != idxInfo.getLen()) {
			return;
		}
		
		setScValue(valueItems, idxInfo, timeStamp);
		setNcValue(valueItems, idxInfo);
	}
	
	public void setNcValue(String[] valueItems, MrIdxInfo idxInfo) {
		if (valueItems.length != idxInfo.getLen()) {
			return;
		}
		
		int len = valueItems.length;
		int idxNcRsrp = idxInfo.getIdx("ltencrsrp");
		if (idxNcRsrp != -1 && idxNcRsrp < len && !"nil".equals(valueItems[idxNcRsrp].toLowerCase())) {
			adjNum++;
			
			int ncRsrp = Integer.parseInt(valueItems[idxNcRsrp]);
			if (maxRsrp == -1 || maxRsrp < ncRsrp) {
				maxRsrp = ncRsrp;
				
				int idxEarfcn = idxInfo.getIdx("ltencearfcn");
				int idxPci = idxInfo.getIdx("ltencpci");
				if (idxEarfcn != -1 && idxEarfcn < len && idxPci != -1 && idxPci < len) {
					maxEarfcnPci = valueItems[idxEarfcn] + "_" + valueItems[idxPci];
				}
			}
		}
	}
	
	public String getTimeStamp() {
		return _timeStamp;
	}
	
	public int getAdjNum() {
		return adjNum;
	}
	
	public int getTa() {
		return ta;
	}
	
	public int getScRsrp() {
		return scRsrp;
	}
	
	public int getPhr() {
		return phr;
	}
	
	public int getMaxRsrp() {
		return maxRsrp;
	}
	
	public String getMaxEarfcnPci() {
		return maxEarfcnPci;
	}
	
	private void setScValue(String[] valueItems, MrIdxInfo idxInfo, String timeStamp) {
		_timeStamp = timeStamp;
		
		int len = valueItems.length;
		int idxTa = idxInfo.getIdx("ltesctadv");
		if (idxTa != -1 && idxTa < len && !"nil".equals(valueItems[idxTa].toLowerCase())) {
			ta = Integer.parseInt(valueItems[idxTa]);
		}
		
		int idxRsrp = idxInfo.getIdx("ltescrsrp");
		if (idxRsrp != -1 && idxRsrp < len && !"nil".equals(valueItems[idxRsrp].toLowerCase())) {
			scRsrp = Integer.parseInt(valueItems[idxRsrp]);
		}
		
		int idxPhr = idxInfo.getIdx("ltescphr");
		if (idxPhr != -1 && idxPhr < len && !"nil".equals(valueItems[idxPhr].toLowerCase())) {
			phr = Integer.parseInt(valueItems[idxPhr]);
		}
	}
	
	public void clear() {
		_timeStamp = null;
		adjNum = 0;
		ta = -1;
		scRsrp = -1;
		phr = -1;
		maxRsrp = -1;
		maxEarfcnPci = null;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mro.user;

import java.text.DateFormat;
import java.text.SimpleDateFormat;

import com.boco.wangyou.utility.TimeUtils;

public class MroUserTypeInfo {
	private long timeMax = -1;
	private long timeMin = -1;
	private int adjNumSum = 0;
	private int adjNumCnt = 0;
	private int taSum = 0;
	private int taCnt = 0;
	private int taMax = -1;
	private int taMin = -1;
	private int scRsrpSum = 0;
	private int scRsrpCnt = 0;
	private int scRsrpMax = -1;
	private int scRsrpMin = -1;
	private int phrSum = 0;
	private int phrCnt = 0;
	private int maxRsrpSum = -1;
	private int maxRsrpCnt = 0;
	private int changeNum = 0;
	private String _maxEarfcnPci = null;
	private String _coverType = null;
	private TimeUtils timeUtils = new TimeUtils();
	
	public void setValue(MroUserInfo userData, String coverType) {
		String timeStamp = userData.getTimeStamp();
		if ("".equals(timeStamp)) {
			return;
		}
		
		DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
		long time = timeUtils.timeToTicks(timeStamp, df);
		if (timeMax == -1 || timeMax < time) {
			timeMax = time;
		}
		if (timeMin == -1 || timeMin > time) {
			timeMin = time;
		}
		
		adjNumSum += userData.getAdjNum();
		adjNumCnt++;
		
		int ta = userData.getTa();
		if (ta != -1) {
			taSum += ta;
			taCnt++;
			
			if (taMax == -1 || taMax < ta) {
				taMax = ta;
			}
			if (taMin == -1 || taMin > ta) {
				taMin = ta;
			}
		}
		
		int rsrp = userData.getScRsrp();
		if (rsrp != -1) {
			scRsrpSum += rsrp;
			scRsrpCnt++;
			
			if (scRsrpMax == -1 || scRsrpMax < rsrp) {
				scRsrpMax = rsrp;
			}
			if (scRsrpMin == -1 || scRsrpMin > rsrp) {
				scRsrpMin = rsrp;
			}
		}
		
		int phr = userData.getPhr();
		if (phr != -1) {
			phrSum += phr;
			phrCnt++;
		}
		
		int maxRsrp = userData.getMaxRsrp();
		if (maxRsrp != -1) {
			maxRsrpSum += maxRsrp;
			maxRsrpCnt++;
		}
		
		String maxEarfcnPci = userData.getMaxEarfcnPci();
		if (maxEarfcnPci != null) {
			if (_maxEarfcnPci != null && !_maxEarfcnPci.equals(maxEarfcnPci)) {
				changeNum++;
			}
			_maxEarfcnPci = maxEarfcnPci;
		}
		
		_coverType = coverType;
	}
	
	public long getTimeDiff() {
		if (timeMax == -1 || timeMin == -1) {
			return 0;
		}
		return (timeMax - timeMin) / 1000;
	}
	
	public double getAdjNum() {
		if (adjNumCnt == 0) {
			return 0;
		}
		return (double) adjNumSum / adjNumCnt;
	}
	
	public double getTa() {
		if (taCnt == 0) {
			return -1;
		}
		return (double) taSum / taCnt;
	}
	
	public int getTaDiff() {
		if (taMax == -1 || taMin == -1) {
			return -1;
		}
		return taMax - taMin;
	}
	
	public double getRsrp() {
		if (scRsrpCnt == 0) {
			return -1;
		}
		return (double) scRsrpSum / scRsrpCnt;
	}
	
	public int getRsrpDiff() {
		if (scRsrpMax == -1 || scRsrpMin == -1) {
			return -1;
		}
		return scRsrpMax - scRsrpMin;
	}
	
	public double getPhr() {
		if (phrCnt == 0) {
			return -1;
		}
		return (double) phrSum / phrCnt;
	}
	
	public double getMaxRsrp() {
		if (maxRsrpCnt == 0) {
			return -1;
		}
		return (double) maxRsrpSum / maxRsrpCnt;
	}
	
	public int getChangeNum() {
		return changeNum;
	}
	
	public String getCoverType() {
		return _coverType;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class Aoa {
	private final int aoaLen = 72;
	private int[] aoas = new int[aoaLen];
	private double aoaSum = 0;
	private int aoaCnt = 0;
	private boolean aoaFlag = false;
	private String _splitStr = "";
	
	public Aoa(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < aoaLen; i++) {
			aoas[i] = 0;
		}
	}
	
	public void sum(Aoa aoa) {
		if (!aoa.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < aoaLen; i++) {
			aoas[i] += aoa.getAoa(i);
		}
		aoaSum += aoa.getAoaSum();
		aoaCnt += aoa.getAoaCnt();
		aoaFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != aoaLen) {
			return;
		}
		
		for (int i = 0; i < aoaLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			aoas[i] += num;
			aoaSum += parse.getAoaValue(i) * num;
			aoaCnt += num;
		}
		aoaFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < aoaLen; i++) {
			line.append(aoas[i]).append(_splitStr);
		}
		line.append(aoaSum).append(_splitStr).append(aoaCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return aoaFlag;
	}
	
	public int getAoa(int idx) {
		if (idx < 0 || idx >= aoaLen) {
			return 0;
		}
		return aoas[idx];
	}
	
	public double getAoaSum() {
		return aoaSum;
	}
	
	public int getAoaCnt() {
		return aoaCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class EnbRxTxTimeDiff {
	private final int enbRxTxTimeDiffLen = 64;
	private int[] enbRxTxTimeDiffs = new int[enbRxTxTimeDiffLen];
	private double enbRxTxTimeDiffSum = 0;
	private int enbRxTxTimeDiffCnt = 0;
	private boolean enbRxTxTimeDiffFlag = false;
	private String _splitStr = "";
	
	public EnbRxTxTimeDiff(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < enbRxTxTimeDiffLen; i++) {
			enbRxTxTimeDiffs[i] = 0;
		}
	}
	
	public void sum(EnbRxTxTimeDiff enbRxTxTimeDiff) {
		if (!enbRxTxTimeDiff.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < enbRxTxTimeDiffLen; i++) {
			enbRxTxTimeDiffs[i] += enbRxTxTimeDiff.getEnbRxTxTimeDiff(i);
		}
		enbRxTxTimeDiffSum += enbRxTxTimeDiff.getEnbRxTxTimeDiffSum();
		enbRxTxTimeDiffCnt += enbRxTxTimeDiff.getEnbRxTxTimeDiffCnt();
		enbRxTxTimeDiffFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != enbRxTxTimeDiffLen) {
			return;
		}
		
		for (int i = 0; i < enbRxTxTimeDiffLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			enbRxTxTimeDiffs[i] += num;
			enbRxTxTimeDiffSum += parse.getEnbRxTxTimeDiffValue(i) * num;
			enbRxTxTimeDiffCnt += num;
		}
		enbRxTxTimeDiffFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < enbRxTxTimeDiffLen; i++) {
			line.append(enbRxTxTimeDiffs[i]).append(_splitStr);
		}
		line.append(enbRxTxTimeDiffSum).append(_splitStr).append(enbRxTxTimeDiffCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return enbRxTxTimeDiffFlag;
	}
	
	public int getEnbRxTxTimeDiff(int idx) {
		if (idx < 0 || idx >= enbRxTxTimeDiffLen) {
			return 0;
		}
		return enbRxTxTimeDiffs[idx];
	}
	
	public double getEnbRxTxTimeDiffSum() {
		return enbRxTxTimeDiffSum;
	}
	
	public int getEnbRxTxTimeDiffCnt() {
		return enbRxTxTimeDiffCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

public class PacketLossRateDlAll {
	private final int qciNum = 9;
	private final int packetLossRateDlAllLen = 28;
	private int[][] packetLossRateDlAlls = new int[qciNum][packetLossRateDlAllLen];
	private double[] packetLossRateDlAllSum = new double[qciNum];
	private int[] packetLossRateDlAllCnt = new int[qciNum];
	private boolean packetLossRateDlAllFlag = false;
	private String _splitStr = "";
	
	public PacketLossRateDlAll(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < qciNum; i++) {
			for (int j = 0; j < packetLossRateDlAllLen; j++) {
				packetLossRateDlAlls[i][j] = 0;
			}
			packetLossRateDlAllSum[i] = 0;
			packetLossRateDlAllCnt[i] = 0;
		}
	}
	
	public void sum(int qci, PacketLossRateDlQci packetLossRateDlQci) {
		if (qci < 0 || qci >= qciNum || !packetLossRateDlQci.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < packetLossRateDlAllLen; i++) {
			packetLossRateDlAlls[qci][i] += packetLossRateDlQci.getPacketLossRateDlQci(i);
		}
		packetLossRateDlAllSum[qci] += packetLossRateDlQci.getPacketLossRateDlQciSum();
		packetLossRateDlAllCnt[qci] += packetLossRateDlQci.getPacketLossRateDlQciCnt();
		packetLossRateDlAllFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < qciNum; i++) {
			for (int j = 0; j < packetLossRateDlAllLen; j++) {
				line.append(packetLossRateDlAlls[i][j]).append(_splitStr);
			}
			line.append(packetLossRateDlAllSum[i]).append(_splitStr).append(packetLossRateDlAllCnt[i]).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return packetLossRateDlAllFlag;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class PacketLossRateDlQci {
	private final int packetLossRateDlQciLen = 28;
	private int[] packetLossRateDlQcis = new int[packetLossRateDlQciLen];
	private double packetLossRateDlQciSum = 0;
	private int packetLossRateDlQciCnt = 0;
	private boolean packetLossRateDlQciFlag = false;
	private String _splitStr = "";
	
	public PacketLossRateDlQci(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < packetLossRateDlQciLen; i++) {
			packetLossRateDlQcis[i] = 0;
		}
	}
	
	public void sum(PacketLossRateDlQci packetLossRateDlQci) {
		if (!packetLossRateDlQci.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < packetLossRateDlQciLen; i++) {
			packetLossRateDlQcis[i] += packetLossRateDlQci.getPacketLossRateDlQci(i);
		}
		packetLossRateDlQciSum += packetLossRateDlQci.getPacketLossRateDlQciSum();
		packetLossRateDlQciCnt += packetLossRateDlQci.getPacketLossRateDlQciCnt();
		packetLossRateDlQciFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != packetLossRateDlQciLen) {
			return;
		}
		
		for (int i = 0; i < packetLossRateDlQciLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			packetLossRateDlQcis[i] += num;
			packetLossRateDlQciSum += parse.getPacketLossRateDlQciValue(i) * num;
			packetLossRateDlQciCnt += num;
		}
		packetLossRateDlQciFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < packetLossRateDlQciLen; i++) {
			line.append(packetLossRateDlQcis[i]).append(_splitStr);
		}
		line.append(packetLossRateDlQciSum).append(_splitStr).append(packetLossRateDlQciCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return packetLossRateDlQciFlag;
	}
	
	public int getPacketLossRateDlQci(int idx) {
		if (idx < 0 || idx >= packetLossRateDlQciLen) {
			return 0;
		}
		return packetLossRateDlQcis[idx];
	}
	
	public double getPacketLossRateDlQciSum() {
		return packetLossRateDlQciSum;
	}
	
	public int getPacketLossRateDlQciCnt() {
		return packetLossRateDlQciCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

public class PacketLossRateUlAll {
	private final int qciNum = 9;
	private final int packetLossRateUlAllLen = 28;
	private int[][] packetLossRateUlAlls = new int[qciNum][packetLossRateUlAllLen];
	private double[] packetLossRateUlAllSum = new double[qciNum];
	private int[] packetLossRateUlAllCnt = new int[qciNum];
	private boolean packetLossRateUlAllFlag = false;
	private String _splitStr = "";
	
	public PacketLossRateUlAll(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < qciNum; i++) {
			for (int j = 0; j < packetLossRateUlAllLen; j++) {
				packetLossRateUlAlls[i][j] = 0;
			}
			packetLossRateUlAllSum[i] = 0;
			packetLossRateUlAllCnt[i] = 0;
		}
	}
	
	public void sum(int qci, PacketLossRateUlQci packetLossRateUlQci) {
		if (qci < 0 || qci >= qciNum || !packetLossRateUlQci.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < packetLossRateUlAllLen; i++) {
			packetLossRateUlAlls[qci][i] += packetLossRateUlQci.getPacketLossRateUlQci(i);
		}
		packetLossRateUlAllSum[qci] += packetLossRateUlQci.getPacketLossRateUlQciSum();
		packetLossRateUlAllCnt[qci] += packetLossRateUlQci.getPacketLossRateUlQciCnt();
		packetLossRateUlAllFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < qciNum; i++) {
			for (int j = 0; j < packetLossRateUlAllLen; j++) {
				line.append(packetLossRateUlAlls[i][j]).append(_splitStr);
			}
			line.append(packetLossRateUlAllSum[i]).append(_splitStr).append(packetLossRateUlAllCnt[i]).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return packetLossRateUlAllFlag;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class PacketLossRateUlQci {
	private final int packetLossRateUlQciLen = 28;
	private int[] packetLossRateUlQcis = new int[packetLossRateUlQciLen];
	private double packetLossRateUlQciSum = 0;
	private int packetLossRateUlQciCnt = 0;
	private boolean packetLossRateUlQciFlag = false;
	private String _splitStr = "";
	
	public PacketLossRateUlQci(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < packetLossRateUlQciLen; i++) {
			packetLossRateUlQcis[i] = 0;
		}
	}
	
	public void sum(PacketLossRateUlQci packetLossRateUlQci) {
		if (!packetLossRateUlQci.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < packetLossRateUlQciLen; i++) {
			packetLossRateUlQcis[i] += packetLossRateUlQci.getPacketLossRateUlQci(i);
		}
		packetLossRateUlQciSum += packetLossRateUlQci.getPacketLossRateUlQciSum();
		packetLossRateUlQciCnt += packetLossRateUlQci.getPacketLossRateUlQciCnt();
		packetLossRateUlQciFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != packetLossRateUlQciLen) {
			return;
		}
		
		for (int i = 0; i < packetLossRateUlQciLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			packetLossRateUlQcis[i] += num;
			packetLossRateUlQciSum += parse.getPacketLossRateUlQciValue(i) * num;
			packetLossRateUlQciCnt += num;
		}
		packetLossRateUlQciFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < packetLossRateUlQciLen; i++) {
			line.append(packetLossRateUlQcis[i]).append(_splitStr);
		}
		line.append(packetLossRateUlQciSum).append(_splitStr).append(packetLossRateUlQciCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return packetLossRateUlQciFlag;
	}
	
	public int getPacketLossRateUlQci(int idx) {
		if (idx < 0 || idx >= packetLossRateUlQciLen) {
			return 0;
		}
		return packetLossRateUlQcis[idx];
	}
	
	public double getPacketLossRateUlQciSum() {
		return packetLossRateUlQciSum;
	}
	
	public int getPacketLossRateUlQciCnt() {
		return packetLossRateUlQciCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class PdschPrbNum {
	private final int pdschPrbNumLen = 11;
	private int[] pdschPrbNums = new int[pdschPrbNumLen];
	private double pdschPrbNumSum = 0;
	private int pdschPrbNumCnt = 0;
	private boolean pdschPrbNumFlag = false;
	private String _splitStr = "";
	
	public PdschPrbNum(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < pdschPrbNumLen; i++) {
			pdschPrbNums[i] = 0;
		}
	}
	
	public void sum(PdschPrbNum pdschPrbNum) {
		if (!pdschPrbNum.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < pdschPrbNumLen; i++) {
			pdschPrbNums[i] += pdschPrbNum.getPdschPrbNum(i);
		}
		pdschPrbNumSum += pdschPrbNum.getPdschPrbNumSum();
		pdschPrbNumCnt += pdschPrbNum.getPdschPrbNumCnt();
		pdschPrbNumFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != pdschPrbNumLen) {
			return;
		}
		
		for (int i = 0; i < pdschPrbNumLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			pdschPrbNums[i] += num;
			pdschPrbNumSum += parse.getPdschPrbNumValue(i) * num;
			pdschPrbNumCnt += num;
		}
		pdschPrbNumFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < pdschPrbNumLen; i++) {
			line.append(pdschPrbNums[i]).append(_splitStr);
		}
		line.append(pdschPrbNumSum).append(_splitStr).append(pdschPrbNumCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return pdschPrbNumFlag;
	}
	
	public int getPdschPrbNum(int idx) {
		if (idx < 0 || idx >= pdschPrbNumLen) {
			return 0;
		}
		return pdschPrbNums[idx];
	}
	
	public double getPdschPrbNumSum() {
		return pdschPrbNumSum;
	}
	
	public int getPdschPrbNumCnt() {
		return pdschPrbNumCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class PowerHeadRoom {
	private final int powerHeadRoomLen = 64;
	private int[] powerHeadRooms = new int[powerHeadRoomLen];
	private double powerHeadRoomSum = 0;
	private int powerHeadRoomCnt = 0;
	private boolean powerHeadRoomFlag = false;
	private String _splitStr = "";
	
	public PowerHeadRoom(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < powerHeadRoomLen; i++) {
			powerHeadRooms[i] = 0;
		}
	}
	
	public void sum(PowerHeadRoom powerHeadRoom) {
		if (!powerHeadRoom.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < powerHeadRoomLen; i++) {
			powerHeadRooms[i] += powerHeadRoom.getPowerHeadRoom(i);
		}
		powerHeadRoomSum += powerHeadRoom.getPowerHeadRoomSum();
		powerHeadRoomCnt += powerHeadRoom.getPowerHeadRoomCnt();
		powerHeadRoomFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != powerHeadRoomLen) {
			return;
		}
		
		for (int i = 0; i < powerHeadRoomLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			powerHeadRooms[i] += num;
			powerHeadRoomSum += parse.getPowerHeadRoomValue(i) * num;
			powerHeadRoomCnt += num;
		}
		powerHeadRoomFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < powerHeadRoomLen; i++) {
			line.append(powerHeadRooms[i]).append(_splitStr);
		}
		line.append(powerHeadRoomSum).append(_splitStr).append(powerHeadRoomCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return powerHeadRoomFlag;
	}
	
	public int getPowerHeadRoom(int idx) {
		if (idx < 0 || idx >= powerHeadRoomLen) {
			return 0;
		}
		return powerHeadRooms[idx];
	}
	
	public double getPowerHeadRoomSum() {
		return powerHeadRoomSum;
	}
	
	public int getPowerHeadRoomCnt() {
		return powerHeadRoomCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class PuschPrbNum {
	private final int puschPrbNumLen = 11;
	private int[] puschPrbNums = new int[puschPrbNumLen];
	private double puschPrbNumSum = 0;
	private int puschPrbNumCnt = 0;
	private boolean puschPrbNumFlag = false;
	private String _splitStr = "";
	
	public PuschPrbNum(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < puschPrbNumLen; i++) {
			puschPrbNums[i] = 0;
		}
	}
	
	public void sum(PuschPrbNum puschPrbNum) {
		if (!puschPrbNum.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < puschPrbNumLen; i++) {
			puschPrbNums[i] += puschPrbNum.getPuschPrbNum(i);
		}
		puschPrbNumSum += puschPrbNum.getPuschPrbNumSum();
		puschPrbNumCnt += puschPrbNum.getPuschPrbNumCnt();
		puschPrbNumFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != puschPrbNumLen) {
			return;
		}
		
		for (int i = 0; i < puschPrbNumLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			puschPrbNums[i] += num;
			puschPrbNumSum += parse.getPuschPrbNumValue(i) * num;
			puschPrbNumCnt += num;
		}
		puschPrbNumFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < puschPrbNumLen; i++) {
			line.append(puschPrbNums[i]).append(_splitStr);
		}
		line.append(puschPrbNumSum).append(_splitStr).append(puschPrbNumCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return puschPrbNumFlag;
	}
	
	public int getPuschPrbNum(int idx) {
		if (idx < 0 || idx >= puschPrbNumLen) {
			return 0;
		}
		return puschPrbNums[idx];
	}
	
	public double getPuschPrbNumSum() {
		return puschPrbNumSum;
	}
	
	public int getPuschPrbNumCnt() {
		return puschPrbNumCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class ReceivedIPower {
	private final int receivedIPowerLen = 53;
	private int[] receivedIPowers = new int[receivedIPowerLen];
	private double receivedIPowerSum = 0;
	private int receivedIPowerCnt = 0;
	private boolean receivedIPowerFlag = false;
	private String _splitStr = "";
	
	public ReceivedIPower(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < receivedIPowerLen; i++) {
			receivedIPowers[i] = 0;
		}
	}
	
	public void sum(ReceivedIPower receivedIPower) {
		if (!receivedIPower.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < receivedIPowerLen; i++) {
			receivedIPowers[i] += receivedIPower.getReceivedIPower(i);
		}
		receivedIPowerSum += receivedIPower.getReceivedIPowerSum();
		receivedIPowerCnt += receivedIPower.getReceivedIPowerCnt();
		receivedIPowerFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != receivedIPowerLen) {
			return;
		}
		
		for (int i = 0; i < receivedIPowerLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			receivedIPowers[i] += num;
			receivedIPowerSum += parse.getReceivedIPowerValue(i) * num;
			receivedIPowerCnt += num;
		}
		receivedIPowerFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < receivedIPowerLen; i++) {
			line.append(receivedIPowers[i]).append(_splitStr);
		}
		line.append(receivedIPowerSum).append(_splitStr).append(receivedIPowerCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return receivedIPowerFlag;
	}
	
	public int getReceivedIPower(int idx) {
		if (idx < 0 || idx >= receivedIPowerLen) {
			return 0;
		}
		return receivedIPowers[idx];
	}
	
	public double getReceivedIPowerSum() {
		return receivedIPowerSum;
	}
	
	public int getReceivedIPowerCnt() {
		return receivedIPowerCnt;
	}
	
	public int getReceivedIPowerLen() {
		return receivedIPowerLen;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class RipPrb {
	private final int ripPrbLen = 53;
	private int[] ripPrbs = new int[ripPrbLen];
	private double ripPrbSum = 0;
	private int ripPrbCnt = 0;
	private boolean ripPrbFlag = false;
	private String _splitStr = "";
	
	public RipPrb(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < ripPrbLen; i++) {
			ripPrbs[i] = 0;
		}
	}
	
	public void sum(RipPrb ripPrb) {
		if (!ripPrb.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < ripPrbLen; i++) {
			ripPrbs[i] += ripPrb.getRipPrb(i);
		}
		ripPrbSum += ripPrb.getRipPrbSum();
		ripPrbCnt += ripPrb.getRipPrbCnt();
		ripPrbFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != ripPrbLen) {
			return;
		}
		
		for (int i = 0; i < ripPrbLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			ripPrbs[i] += num;
			ripPrbSum += parse.getRipPrbValue(i) * num;
			ripPrbCnt += num;
		}
		ripPrbFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < ripPrbLen; i++) {
			line.append(ripPrbs[i]).append(_splitStr);
		}
		line.append(ripPrbSum).append(_splitStr).append(ripPrbCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return ripPrbFlag;
	}
	
	public int getRipPrb(int idx) {
		if (idx < 0 || idx >= ripPrbLen) {
			return 0;
		}
		return ripPrbs[idx];
	}
	
	public double getRipPrbSum() {
		return ripPrbSum;
	}
	
	public int getRipPrbCnt() {
		return ripPrbCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class Rsrp {
	private final int rsrpLen = 48;
	private int[] rsrps = new int[rsrpLen];
	private double rsrpSum = 0;
	private int rsrpCnt = 0;
	private boolean rsrpFlag = false;
	private String _splitStr = "";
	
	public Rsrp(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrps[i] = 0;
		}
	}
	
	public void sum(Rsrp rsrp) {
		if (!rsrp.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrps[i] += rsrp.getRsrp(i);
		}
		rsrpSum += rsrp.getRsrpSum();
		rsrpCnt += rsrp.getRsrpCnt();
		rsrpFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != rsrpLen) {
			return;
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			rsrps[i] += num;
			rsrpSum += parse.getRsrpValue(i) * num;
			rsrpCnt += num;
		}
		rsrpFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrps[i]).append(_splitStr);
		}
		line.append(rsrpSum).append(_splitStr).append(rsrpCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return rsrpFlag;
	}
	
	public int getRsrp(int idx) {
		if (idx < 0 || idx >= rsrpLen) {
			return 0;
		}
		return rsrps[idx];
	}
	
	public double getRsrpSum() {
		return rsrpSum;
	}
	
	public int getRsrpCnt() {
		return rsrpCnt;
	}
	
	public int getRsrpLen() {
		return rsrpLen;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class Rsrq {
	private final int rsrqLen = 18;
	private int[] rsrqs = new int[rsrqLen];
	private double rsrqSum = 0;
	private int rsrqCnt = 0;
	private boolean rsrqFlag = false;
	private String _splitStr = "";
	
	public Rsrq(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < rsrqLen; i++) {
			rsrqs[i] = 0;
		}
	}
	
	public void sum(Rsrq rsrq) {
		if (!rsrq.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			rsrqs[i] += rsrq.getRsrq(i);
		}
		rsrqSum += rsrq.getRsrqSum();
		rsrqCnt += rsrq.getRsrqCnt();
		rsrqFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != rsrqLen) {
			return;
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			rsrqs[i] += num;
			rsrqSum += parse.getRsrqValue(i) * num;
			rsrqCnt += num;
		}
		rsrqFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rsrqLen; i++) {
			line.append(rsrqs[i]).append(_splitStr);
		}
		line.append(rsrqSum).append(_splitStr).append(rsrqCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return rsrqFlag;
	}
	
	public int getRsrq(int idx) {
		if (idx < 0 || idx >= rsrqLen) {
			return 0;
		}
		return rsrqs[idx];
	}
	
	public double getRsrqSum() {
		return rsrqSum;
	}
	
	public int getRsrqCnt() {
		return rsrqCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class RxTxTimeDiff {
	private final int rxTxTimeDiffLen = 48;
	private int[] rxTxTimeDiffs = new int[rxTxTimeDiffLen];
	private double rxTxTimeDiffSum = 0;
	private int rxTxTimeDiffCnt = 0;
	private boolean rxTxTimeDiffFlag = false;
	private String _splitStr = "";
	
	public RxTxTimeDiff(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < rxTxTimeDiffLen; i++) {
			rxTxTimeDiffs[i] = 0;
		}
	}
	
	public void sum(RxTxTimeDiff rxTxTimeDiff) {
		if (!rxTxTimeDiff.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < rxTxTimeDiffLen; i++) {
			rxTxTimeDiffs[i] += rxTxTimeDiff.getRxTxTimeDiff(i);
		}
		rxTxTimeDiffSum += rxTxTimeDiff.getRxTxTimeDiffSum();
		rxTxTimeDiffCnt += rxTxTimeDiff.getRxTxTimeDiffCnt();
		rxTxTimeDiffFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != rxTxTimeDiffLen) {
			return;
		}
		
		for (int i = 0; i < rxTxTimeDiffLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			rxTxTimeDiffs[i] += num;
			rxTxTimeDiffSum += parse.getRxTxTimeDiffValue(i) * num;
			rxTxTimeDiffCnt += num;
		}
		rxTxTimeDiffFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rxTxTimeDiffLen; i++) {
			line.append(rxTxTimeDiffs[i]).append(_splitStr);
		}
		line.append(rxTxTimeDiffSum).append(_splitStr).append(rxTxTimeDiffCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return rxTxTimeDiffFlag;
	}
	
	public int getRxTxTimeDiff(int idx) {
		if (idx < 0 || idx >= rxTxTimeDiffLen) {
			return 0;
		}
		return rxTxTimeDiffs[idx];
	}
	
	public double getRxTxTimeDiffSum() {
		return rxTxTimeDiffSum;
	}
	
	public int getRxTxTimeDiffCnt() {
		return rxTxTimeDiffCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class SinrUl {
	private final int sinrUlLen = 37;
	private int[] sinrUls = new int[sinrUlLen];
	private double sinrUlSum = 0;
	private int sinrUlCnt = 0;
	private boolean sinrUlFlag = false;
	private String _splitStr = "";
	
	public SinrUl(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < sinrUlLen; i++) {
			sinrUls[i] = 0;
		}
	}
	
	public void sum(SinrUl sinrUl) {
		if (!sinrUl.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < sinrUlLen; i++) {
			sinrUls[i] += sinrUl.getSinrUl(i);
		}
		sinrUlSum += sinrUl.getSinrUlSum();
		sinrUlCnt += sinrUl.getSinrUlCnt();
		sinrUlFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != sinrUlLen) {
			return;
		}
		
		for (int i = 0; i < sinrUlLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			sinrUls[i] += num;
			sinrUlSum += parse.getSinrUlValue(i) * num;
			sinrUlCnt += num;
		}
		sinrUlFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < sinrUlLen; i++) {
			line.append(sinrUls[i]).append(_splitStr);
		}
		line.append(sinrUlSum).append(_splitStr).append(sinrUlCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return sinrUlFlag;
	}
	
	public int getSinrUl(int idx) {
		if (idx < 0 || idx >= sinrUlLen) {
			return 0;
		}
		return sinrUls[idx];
	}
	
	public double getSinrUlSum() {
		return sinrUlSum;
	}
	
	public int getSinrUlCnt() {
		return sinrUlCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.onedim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class Tadv {
	private final int tadvLen = 45;
	private int[] tadvs = new int[tadvLen];
	private double tadvSum = 0;
	private int tadvCnt = 0;
	private boolean tadvFlag = false;
	private String _splitStr = "";
	
	public Tadv(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < tadvLen; i++) {
			tadvs[i] = 0;
		}
	}
	
	public void sum(Tadv tadv) {
		if (!tadv.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < tadvLen; i++) {
			tadvs[i] += tadv.getTadv(i);
		}
		tadvSum += tadv.getTadvSum();
		tadvCnt += tadv.getTadvCnt();
		tadvFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != tadvLen) {
			return;
		}
		
		for (int i = 0; i < tadvLen; i++) {
			int num = Integer.parseInt(valueItems[i]);
			tadvs[i] += num;
			tadvSum += parse.getTadvValue(i) * num;
			tadvCnt += num;
		}
		tadvFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < tadvLen; i++) {
			line.append(tadvs[i]).append(_splitStr);
		}
		line.append(tadvSum).append(_splitStr).append(tadvCnt);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return tadvFlag;
	}
	
	public int getTadv(int idx) {
		if (idx < 0 || idx >= tadvLen) {
			return 0;
		}
		return tadvs[idx];
	}
	
	public double getTadvSum() {
		return tadvSum;
	}
	
	public int getTadvCnt() {
		return tadvCnt;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs;

import java.util.Map;

import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.Aoa;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.EnbRxTxTimeDiff;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PacketLossRateDlQci;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PacketLossRateUlQci;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PdschPrbNum;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PowerHeadRoom;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PuschPrbNum;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.ReceivedIPower;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.Rsrp;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.Rsrq;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.RxTxTimeDiff;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.SinrUl;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.Tadv;

public class TdlMrsAverage {
	private double rsrpSum = 0;
	private int rsrpCnt = 0;
	private double rsrqSum = 0;
	private int rsrqCnt = 0;
	private double rxTxTimeDiffSum = 0;
	private int rxTxTimeDiffCnt = 0;
	private double powerHeadRoomSum = 0;
	private int powerHeadRoomCnt = 0;
	private double receivedIPowerSum = 0;
	private int receivedIPowerCnt = 0;
	private double aoaSum = 0;
	private int aoaCnt = 0;
	private double[] packetLossRateUlQciSum = new double[9];
	private int[] packetLossRateUlQciCnt = new int[9];
	private double[] packetLossRateDlQciSum = new double[9];
	private int[] packetLossRateDlQciCnt = new int[9];
	private double sinrUlSum = 0;
	private int sinrUlCnt = 0;
	private double tadvSum = 0;
	private int tadvCnt = 0;
	private double puschPrbNumSum = 0;
	private int puschPrbNumCnt = 0;
	private double pdschPrbNumSum = 0;
	private int pdschPrbNumCnt = 0;
	private double enbRxTxTimeDiffSum = 0;
	private int enbRxTxTimeDiffCnt = 0;
	private int rsrpGtF110 = 0;
	private int rsrpLtF110 = 0;
	private int ripGtF105 = 0;
	private int sinrUlLt0 = 0;
	private int totalNum = 0;
	private int weakCover = 0;
	private int highRip = 0;
	private String _splitStr = null;
	
	public TdlMrsAverage(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < 9; i++) {
			packetLossRateUlQciSum[i] = 0;
			packetLossRateUlQciCnt[i] = 0;
			packetLossRateDlQciSum[i] = 0;
			packetLossRateDlQciCnt[i] = 0;
		}
	}
	
	public void sum(TdlMrsValue tdlMrsValue) {
		Rsrp rsrp = tdlMrsValue.getRsrp();
		rsrpSum += rsrp.getRsrpSum();
		rsrpCnt += rsrp.getRsrpCnt();
		for (int i = 7; i < rsrp.getRsrpLen(); i++) {
			rsrpGtF110 += rsrp.getRsrp(i);
		}
		double rsrpWeak = 0;
		for (int i = 0; i <= 6; i++) {
			rsrpWeak += rsrp.getRsrp(i);
		}
		rsrpLtF110 += rsrpWeak;
		if (div(rsrpLtF110, rsrp.getRsrpCnt(), 0) > 0.1) {
			weakCover++;
		}
		Rsrq rsrq = tdlMrsValue.getRsrq();
		rsrqSum += rsrq.getRsrqSum();
		rsrqCnt += rsrq.getRsrqCnt();
		RxTxTimeDiff rxTxTimeDiff = tdlMrsValue.getRxTxTimeDiff();
		rxTxTimeDiffSum += rxTxTimeDiff.getRxTxTimeDiffSum();
		rxTxTimeDiffCnt += rxTxTimeDiff.getRxTxTimeDiffCnt();
		PowerHeadRoom powerHeadRoom = tdlMrsValue.getPowerHeadRoom();
		powerHeadRoomSum += powerHeadRoom.getPowerHeadRoomSum();
		powerHeadRoomCnt += powerHeadRoom.getPowerHeadRoomCnt();
		Map<String, ReceivedIPower> mapReceivedIPower = tdlMrsValue.getReceivedIPower();
		double ripHigh = 0;
		int ripCnt = 0;
		for (Map.Entry<String, ReceivedIPower> entry : mapReceivedIPower.entrySet()) {
			ReceivedIPower receivedIPower = entry.getValue();
			receivedIPowerSum += receivedIPower.getReceivedIPowerSum();
			ripCnt += receivedIPower.getReceivedIPowerCnt();
			for (int i = 22; i <= receivedIPower.getReceivedIPowerLen(); i++) {
				ripHigh += receivedIPower.getReceivedIPower(i);
			}
		}
		receivedIPowerCnt += ripCnt;
		ripGtF105 += ripHigh;
		if (div(ripHigh, ripCnt, 0) >= 0.05) {
			highRip++;
		}
		Map<Integer, PacketLossRateUlQci> mapPacketLossRateUlQci = tdlMrsValue.getPacketLossRateUlQci();
		for (Map.Entry<Integer, PacketLossRateUlQci> entry : mapPacketLossRateUlQci.entrySet()) {
			int qci = entry.getKey();
			if (qci <= 0 || qci > 9) {
				continue;
			}
			int idx = qci - 1;
			PacketLossRateUlQci packetLossRateUlQci = entry.getValue();
			packetLossRateUlQciSum[idx] += packetLossRateUlQci.getPacketLossRateUlQciSum();
			packetLossRateUlQciCnt[idx] += packetLossRateUlQci.getPacketLossRateUlQciCnt();
		}
		Map<Integer, PacketLossRateDlQci> mapPacketLossRateDlQci = tdlMrsValue.getPacketLossRateDlQci();
		for (Map.Entry<Integer, PacketLossRateDlQci> entry : mapPacketLossRateDlQci.entrySet()) {
			int qci = entry.getKey();
			if (qci <= 0 || qci > 9) {
				continue;
			}
			int idx = qci - 1;
			PacketLossRateDlQci packetLossRateDlQci = entry.getValue();
			packetLossRateDlQciSum[idx] += packetLossRateDlQci.getPacketLossRateDlQciSum();
			packetLossRateDlQciCnt[idx] += packetLossRateDlQci.getPacketLossRateDlQciCnt();
		}
		Aoa aoa = tdlMrsValue.getAoa();
		aoaSum += aoa.getAoaSum();
		aoaCnt += aoa.getAoaCnt();
		SinrUl sinrUl = tdlMrsValue.getSinrUl();
		sinrUlSum += sinrUl.getSinrUlSum();
		sinrUlCnt += sinrUl.getSinrUlCnt();
		for (int i = 0; i <= 10; i++) {
			sinrUlLt0 += sinrUl.getSinrUl(i);
		}
		Tadv tadv = tdlMrsValue.getTadv();
		tadvSum += tadv.getTadvSum();
		tadvCnt += tadv.getTadvCnt();
		PuschPrbNum puschPrbNum = tdlMrsValue.getPuschPrbNum();
		puschPrbNumSum += puschPrbNum.getPuschPrbNumSum();
		puschPrbNumCnt += puschPrbNum.getPuschPrbNumCnt();
		PdschPrbNum pdschPrbNum = tdlMrsValue.getPdschPrbNum();
		pdschPrbNumSum += pdschPrbNum.getPdschPrbNumSum();
		pdschPrbNumCnt += pdschPrbNum.getPdschPrbNumCnt();
		EnbRxTxTimeDiff enbRxTxTimeDiff = tdlMrsValue.getEnbRxTxTimeDiff();
		enbRxTxTimeDiffSum += enbRxTxTimeDiff.getEnbRxTxTimeDiffSum();
		enbRxTxTimeDiffCnt += enbRxTxTimeDiff.getEnbRxTxTimeDiffCnt();
		totalNum++;
	}
	
	public void sum(TdlMrsAverage tdlMrsAverage) {
		rsrpSum += tdlMrsAverage.getRsrpSum();
		rsrpCnt += tdlMrsAverage.getRsrpCnt();
		rsrqSum += tdlMrsAverage.getRsrqSum();
		rsrqCnt += tdlMrsAverage.getRsrqCnt();
		rxTxTimeDiffSum += tdlMrsAverage.getRxTxTimeDiffSum();
		rxTxTimeDiffCnt += tdlMrsAverage.getRxTxTimeDiffCnt();
		powerHeadRoomSum += tdlMrsAverage.getPowerHeadRoomSum();
		powerHeadRoomCnt += tdlMrsAverage.getPowerHeadRoomCnt();
		receivedIPowerSum += tdlMrsAverage.getReceivedIPowerSum();
		receivedIPowerCnt += tdlMrsAverage.getReceivedIPowerCnt();
		for (int i = 0; i < 9; i++) {
			packetLossRateUlQciSum[i] += tdlMrsAverage.getPacketLossRateUlQciSum(i);
			packetLossRateUlQciCnt[i] += tdlMrsAverage.getPacketLossRateUlQciCnt(i);
			packetLossRateDlQciSum[i] += tdlMrsAverage.getPacketLossRateDlQciSum(i);
			packetLossRateDlQciCnt[i] += tdlMrsAverage.getPacketLossRateDlQciCnt(i);
		}
		aoaSum += tdlMrsAverage.getAoaSum();
		aoaCnt += tdlMrsAverage.getAoaCnt();
		sinrUlSum += tdlMrsAverage.getSinrUlSum();
		sinrUlCnt += tdlMrsAverage.getSinrUlCnt();
		tadvSum += tdlMrsAverage.getTadvSum();
		tadvCnt += tdlMrsAverage.getTadvCnt();
		puschPrbNumSum += tdlMrsAverage.getPuschPrbNumSum();
		puschPrbNumCnt += tdlMrsAverage.getPuschPrbNumCnt();
		pdschPrbNumSum += tdlMrsAverage.getPdschPrbNumSum();
		pdschPrbNumCnt += tdlMrsAverage.getPdschPrbNumCnt();
		enbRxTxTimeDiffSum += tdlMrsAverage.getEnbRxTxTimeDiffSum();
		enbRxTxTimeDiffCnt += tdlMrsAverage.getEnbRxTxTimeDiffCnt();
		rsrpGtF110 += tdlMrsAverage.getRsrpGtF110();
		rsrpLtF110 += tdlMrsAverage.getRsrpLtF110();
		ripGtF105 += tdlMrsAverage.getRipGtF105();
		sinrUlLt0 += tdlMrsAverage.getSinrUlLt0();
		totalNum += tdlMrsAverage.getTotalNum();
		weakCover += tdlMrsAverage.getWeakCover();
		highRip += tdlMrsAverage.getHighRip();
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		line.append(rsrpSum).append(_splitStr).append(rsrpCnt).append(_splitStr).append(div(rsrpSum, rsrpCnt, 0)).append(_splitStr)
			.append(rsrqSum).append(_splitStr).append(rsrqCnt).append(_splitStr).append(div(rsrqSum, rsrqCnt, 0)).append(_splitStr)
			.append(rxTxTimeDiffSum).append(_splitStr).append(rxTxTimeDiffCnt).append(_splitStr).append(div(rxTxTimeDiffSum, rxTxTimeDiffCnt, 0)).append(_splitStr)
			.append(powerHeadRoomSum).append(_splitStr).append(powerHeadRoomCnt).append(_splitStr).append(div(powerHeadRoomSum, powerHeadRoomCnt, 0)).append(_splitStr)
			.append(receivedIPowerSum).append(_splitStr).append(receivedIPowerCnt).append(_splitStr).append(div(receivedIPowerSum, receivedIPowerCnt, 0)).append(_splitStr);
		for (int i = 0; i < 9; i++) {
			line.append(packetLossRateUlQciSum[i]).append(_splitStr).append(packetLossRateUlQciCnt[i]).append(_splitStr).append(div(packetLossRateUlQciSum[i], packetLossRateUlQciCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < 9; i++) {
			line.append(packetLossRateDlQciSum[i]).append(_splitStr).append(packetLossRateDlQciCnt[i]).append(_splitStr).append(div(packetLossRateDlQciSum[i], packetLossRateDlQciCnt[i], 0)).append(_splitStr);
		}
		double rsrpLtF110Rate = div((double) rsrpGtF110, rsrpCnt, 0);
		double ripGtF105Rate = div((double) ripGtF105, receivedIPowerCnt, 0);
		line.append(aoaSum).append(_splitStr).append(aoaCnt).append(_splitStr).append(div(aoaSum, aoaCnt, 0)).append(_splitStr)
			.append(sinrUlSum).append(_splitStr).append(sinrUlCnt).append(_splitStr).append(div(sinrUlSum, sinrUlCnt, 0)).append(_splitStr)
			.append(tadvSum).append(_splitStr).append(tadvCnt).append(_splitStr).append(div(tadvSum, tadvCnt, 0)).append(_splitStr)
			.append(puschPrbNumSum).append(_splitStr).append(puschPrbNumCnt).append(_splitStr).append(div(puschPrbNumSum, puschPrbNumCnt, 0)).append(_splitStr)
			.append(pdschPrbNumSum).append(_splitStr).append(pdschPrbNumCnt).append(_splitStr).append(div(pdschPrbNumSum, pdschPrbNumCnt, 0)).append(_splitStr)
			.append(enbRxTxTimeDiffSum).append(_splitStr).append(enbRxTxTimeDiffCnt).append(_splitStr).append(div(enbRxTxTimeDiffSum, enbRxTxTimeDiffCnt, 0)).append(_splitStr)
			.append(rsrpGtF110).append(_splitStr).append(rsrpLtF110).append(_splitStr).append(div((double) rsrpGtF110, rsrpCnt, 0)).append(_splitStr).append(rsrpLtF110Rate).append(_splitStr)
			.append(ripGtF105).append(_splitStr).append(ripGtF105Rate).append(_splitStr).append(sinrUlLt0).append(_splitStr).append(div(sinrUlLt0, sinrUlCnt, 0)).append(_splitStr)
			.append(totalNum).append(_splitStr).append(weakCover).append(_splitStr).append(highRip);
		return line.toString();
	}
	
	private double getRsrpSum() {
		return rsrpSum;
	}
	
	private int getRsrpCnt() {
		return rsrpCnt;
	}
	
	private double getRsrqSum() {
		return rsrqSum;
	}
	
	private int getRsrqCnt() {
		return rsrqCnt;
	}
	
	private double getRxTxTimeDiffSum() {
		return rxTxTimeDiffSum;
	}
	
	private int getRxTxTimeDiffCnt() {
		return rxTxTimeDiffCnt;
	}
	
	private double getPowerHeadRoomSum() {
		return powerHeadRoomSum;
	}
	
	private int getPowerHeadRoomCnt() {
		return powerHeadRoomCnt;
	}
	
	private double getReceivedIPowerSum() {
		return receivedIPowerSum;
	}
	
	private int getReceivedIPowerCnt() {
		return receivedIPowerCnt;
	}
	
	private double getPacketLossRateUlQciSum(int idx) {
		if (idx < 0 || idx >= 9) {
			return 0;
		}
		return packetLossRateUlQciSum[idx];
	}
	
	private int getPacketLossRateUlQciCnt(int idx) {
		if (idx < 0 || idx >= 9) {
			return 0;
		}
		return packetLossRateUlQciCnt[idx];
	}
	
	private double getPacketLossRateDlQciSum(int idx) {
		if (idx < 0 || idx >= 9) {
			return 0;
		}
		return packetLossRateDlQciSum[idx];
	}
	
	private int getPacketLossRateDlQciCnt(int idx) {
		if (idx < 0 || idx >= 9) {
			return 0;
		}
		return packetLossRateDlQciCnt[idx];
	}
	
	private double getAoaSum() {
		return aoaSum;
	}
	
	private int getAoaCnt() {
		return aoaCnt;
	}
	
	private double getSinrUlSum() {
		return sinrUlSum;
	}
	
	private int getSinrUlCnt() {
		return sinrUlCnt;
	}
	
	private double getTadvSum() {
		return tadvSum;
	}
	
	private int getTadvCnt() {
		return tadvCnt;
	}
	
	private double getPuschPrbNumSum() {
		return puschPrbNumSum;
	}
	
	private int getPuschPrbNumCnt() {
		return puschPrbNumCnt;
	}
	
	private double getPdschPrbNumSum() {
		return pdschPrbNumSum;
	}
	
	private int getPdschPrbNumCnt() {
		return pdschPrbNumCnt;
	}
	
	private double getEnbRxTxTimeDiffSum() {
		return enbRxTxTimeDiffSum;
	}
	
	private int getEnbRxTxTimeDiffCnt() {
		return enbRxTxTimeDiffCnt;
	}
	
	private int getRsrpGtF110() {
		return rsrpGtF110;
	}
	
	private int getRsrpLtF110() {
		return rsrpLtF110;
	}
	
	private int getRipGtF105() {
		return ripGtF105;
	}
	
	private int getSinrUlLt0() {
		return sinrUlLt0;
	}
	
	private int getTotalNum() {
		return totalNum;
	}
	
	private int getWeakCover() {
		return weakCover;
	}
	
	private int getHighRip() {
		return highRip;
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs;

import java.util.HashMap;
import java.util.Map;

import com.boco.wangyou.algorithm.counter.MrsParse;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.Aoa;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.EnbRxTxTimeDiff;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PacketLossRateDlQci;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PacketLossRateUlQci;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PdschPrbNum;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PowerHeadRoom;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.PuschPrbNum;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.ReceivedIPower;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.RipPrb;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.Rsrp;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.Rsrq;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.RxTxTimeDiff;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.SinrUl;
import com.boco.wangyou.ltemr.parse.entity.mrs.onedim.Tadv;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.PdschPrbNumRsrq;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.PlrDlQciRsrp;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.PlrDlQciRsrq;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.PlrUlQciRip;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.PlrUlQciSinrUl;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.PuschPrbNumPhr;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.RipRsrp;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.RipRsrq;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.RsrpRsrq;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.RttdAoa;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.RttdRsrp;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.SinrUlRip;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.TadvAoa;
import com.boco.wangyou.ltemr.parse.entity.mrs.twodim.TadvRsrp;

public class TdlMrsValue {
	private Rsrp rsrp = null;
	private Rsrq rsrq = null;
	private RxTxTimeDiff rxTxTimeDiff = null;
	private PowerHeadRoom powerHeadRoom = null;
	private Map<String, ReceivedIPower> mapReceivedIPower = new HashMap<String, ReceivedIPower>(20);
	private Aoa aoa = null;
	private Map<Integer, PacketLossRateUlQci> mapPacketLossRateUlQci = new HashMap<Integer, PacketLossRateUlQci>(20);
	private Map<Integer, PacketLossRateDlQci> mapPacketLossRateDlQci = new HashMap<Integer, PacketLossRateDlQci>(20);
	private SinrUl sinrUl = null;
	private Tadv tadv = null;
	private Map<String, RipPrb> mapRipPrb = new HashMap<String, RipPrb>(20);
	private PuschPrbNum puschPrbNum = null;
	private PdschPrbNum pdschPrbNum = null;
	private EnbRxTxTimeDiff enbRxTxTimeDiff = null;
	private RttdRsrp rttdRsrp = null;
	private RttdAoa rttdAoa = null;
	private RsrpRsrq rsrpRsrq = null;
	private RipRsrp ripRsrp = null;
	private RipRsrq ripRsrq = null;
	private Map<Integer, PlrUlQciSinrUl> mapPlrUlQciSinrUl = new HashMap<Integer, PlrUlQciSinrUl>(20);
	private Map<Integer, PlrDlQciRsrq> mapPlrDlQciRsrq = new HashMap<Integer, PlrDlQciRsrq>(20);
	private Map<Integer, PlrDlQciRsrp> mapPlrDlQciRsrp = new HashMap<Integer, PlrDlQciRsrp>(20);
	private Map<Integer, PlrUlQciRip> mapPlrUlQciRip = new HashMap<Integer, PlrUlQciRip>(20);
	private SinrUlRip sinrUlRip = null;
	private TadvRsrp tadvRsrp = null;
	private TadvAoa tadvAoa = null;
	private PuschPrbNumPhr puschPrbNumPhr = null;
	private PdschPrbNumRsrq pdschPrbNumRsrq = null;
	private ReceivedIPower receivedIPower = null;
	private String _splitStr = null;
	private MrsParse parse = new MrsParse();
	
	public TdlMrsValue(String splitStr) {
		_splitStr = splitStr;
		
		rsrp = new Rsrp(splitStr);
		rsrq = new Rsrq(splitStr);
		rxTxTimeDiff = new RxTxTimeDiff(splitStr);
		powerHeadRoom = new PowerHeadRoom(splitStr);
		aoa = new Aoa(splitStr);
		sinrUl = new SinrUl(splitStr);
		tadv = new Tadv(splitStr);
		puschPrbNum = new PuschPrbNum(splitStr);
		pdschPrbNum = new PdschPrbNum(splitStr);
		enbRxTxTimeDiff = new EnbRxTxTimeDiff(splitStr);
		rttdRsrp = new RttdRsrp(splitStr);
		rttdAoa = new RttdAoa(splitStr);
		rsrpRsrq = new RsrpRsrq(splitStr);
		ripRsrp = new RipRsrp(splitStr);
		ripRsrq = new RipRsrq(splitStr);
		sinrUlRip = new SinrUlRip(splitStr);
		tadvRsrp = new TadvRsrp(splitStr);
		tadvAoa = new TadvAoa(splitStr);
		puschPrbNumPhr = new PuschPrbNumPhr(splitStr);
		pdschPrbNumRsrq = new PdschPrbNumRsrq(splitStr);
		receivedIPower = new ReceivedIPower(splitStr);
	}
	
	public void sum(TdlMrsValue tdlMrsValue) {
		if (tdlMrsValue.isNotEmptyRsrp()) {
			rsrp.sum(tdlMrsValue.getRsrp());
		}
		
		if (tdlMrsValue.isNotEmptyRsrq()) {
			rsrq.sum(tdlMrsValue.getRsrq());
		}
		
		if (tdlMrsValue.isNotEmptyRxTxTimeDiff()) {
			rxTxTimeDiff.sum(tdlMrsValue.getRxTxTimeDiff());
		}
		
		if (tdlMrsValue.isNotEmptyPowerHeadRoom()) {
			powerHeadRoom.sum(tdlMrsValue.getPowerHeadRoom());
		}
		
		if (tdlMrsValue.isNotEmptyAoa()) {
			aoa.sum(tdlMrsValue.getAoa());
		}
		
		for (Map.Entry<Integer, PacketLossRateUlQci> entry : tdlMrsValue.getPacketLossRateUlQci().entrySet()) {
			int qci = entry.getKey();
			PacketLossRateUlQci packetLossRateUlQci = entry.getValue();
			if (!packetLossRateUlQci.isNotEmpty()) {
				continue;
			}
			PacketLossRateUlQci packetLossRateUlQciSum = null;
			if (mapPacketLossRateUlQci.containsKey(qci)) {
				packetLossRateUlQciSum = mapPacketLossRateUlQci.get(qci);
			} else {
				packetLossRateUlQciSum = new PacketLossRateUlQci(_splitStr);
			}
			packetLossRateUlQciSum.sum(packetLossRateUlQci);
			mapPacketLossRateUlQci.put(qci, packetLossRateUlQciSum);
		}
		
		for (Map.Entry<Integer, PacketLossRateDlQci> entry : tdlMrsValue.getPacketLossRateDlQci().entrySet()) {
			int qci = entry.getKey();
			PacketLossRateDlQci packetLossRateDlQci = entry.getValue();
			if (!packetLossRateDlQci.isNotEmpty()) {
				continue;
			}
			PacketLossRateDlQci packetLossRateDlQciSum = null;
			if (mapPacketLossRateDlQci.containsKey(qci)) {
				packetLossRateDlQciSum = mapPacketLossRateDlQci.get(qci);
			} else {
				packetLossRateDlQciSum = new PacketLossRateDlQci(_splitStr);
			}
			packetLossRateDlQciSum.sum(packetLossRateDlQci);
			mapPacketLossRateDlQci.put(qci, packetLossRateDlQciSum);
		}
		
		if (tdlMrsValue.isNotEmptySinrUl()) {
			sinrUl.sum(tdlMrsValue.getSinrUl());
		}
		
		if (tdlMrsValue.isNotEmptyTadv()) {
			tadv.sum(tdlMrsValue.getTadv());
		}
		
		for (Map.Entry<String, RipPrb> entry : tdlMrsValue.getRipPrb().entrySet()) {
			String subFrame = entry.getKey();
			RipPrb ripPrb = entry.getValue();
			if (!ripPrb.isNotEmpty()) {
				continue;
			}
			RipPrb ripPrbSum = null;
			if (mapRipPrb.containsKey(subFrame)) {
				ripPrbSum = mapRipPrb.get(subFrame);
			} else {
				ripPrbSum = new RipPrb(_splitStr);
			}
			ripPrbSum.sum(ripPrb);
			mapRipPrb.put(subFrame, ripPrbSum);
		}
		
		if (tdlMrsValue.isNotEmptyPuschPrbNum()) {
			puschPrbNum.sum(tdlMrsValue.getPuschPrbNum());
		}
		
		if (tdlMrsValue.isNotEmptyPdschPrbNum()) {
			pdschPrbNum.sum(tdlMrsValue.getPdschPrbNum());
		}
		
		if (tdlMrsValue.isNotEmptyEnbRxTxTimeDiff()) {
			enbRxTxTimeDiff.sum(tdlMrsValue.getEnbRxTxTimeDiff());
		}
		
		if (tdlMrsValue.isNotEmptyRttdRsrp()) {
			rttdRsrp.sum(tdlMrsValue.getRttdRsrp());
		}
		
		if (tdlMrsValue.isNotEmptyRttdAoa()) {
			rttdAoa.sum(tdlMrsValue.getRttdAoa());
		}
		
		if (tdlMrsValue.isNotEmptyRsrpRsrq()) {
			rsrpRsrq.sum(tdlMrsValue.getRsrpRsrq());
		}
		
		if (tdlMrsValue.isNotEmptyRipRsrp()) {
			ripRsrp.sum(tdlMrsValue.getRipRsrp());
		}
		
		if (tdlMrsValue.isNotEmptyRipRsrq()) {
			ripRsrq.sum(tdlMrsValue.getRipRsrq());
		}
		
		for (Map.Entry<Integer, PlrUlQciSinrUl> entry : tdlMrsValue.getPlrUlQciSinrUl().entrySet()) {
			int qci = entry.getKey();
			PlrUlQciSinrUl plrUlQciSinrUl = entry.getValue();
			if (!plrUlQciSinrUl.isNotEmpty()) {
				continue;
			}
			PlrUlQciSinrUl plrUlQciSinrUlSum = null;
			if (mapPlrUlQciSinrUl.containsKey(qci)) {
				plrUlQciSinrUlSum = mapPlrUlQciSinrUl.get(qci);
			} else {
				plrUlQciSinrUlSum = new PlrUlQciSinrUl(_splitStr);
			}
			plrUlQciSinrUlSum.sum(plrUlQciSinrUl);
			mapPlrUlQciSinrUl.put(qci, plrUlQciSinrUlSum);
		}
		
		for (Map.Entry<Integer, PlrDlQciRsrq> entry : tdlMrsValue.getPlrDlQciRsrq().entrySet()) {
			int qci = entry.getKey();
			PlrDlQciRsrq plrDlQciRsrq = entry.getValue();
			if (!plrDlQciRsrq.isNotEmpty()) {
				continue;
			}
			PlrDlQciRsrq plrDlQciRsrqSum = null;
			if (mapPlrDlQciRsrq.containsKey(qci)) {
				plrDlQciRsrqSum = mapPlrDlQciRsrq.get(qci);
			} else {
				plrDlQciRsrqSum = new PlrDlQciRsrq(_splitStr);
			}
			plrDlQciRsrqSum.sum(plrDlQciRsrq);
			mapPlrDlQciRsrq.put(qci, plrDlQciRsrqSum);
		}
		
		for (Map.Entry<Integer, PlrDlQciRsrp> entry : tdlMrsValue.getPlrDlQciRsrp().entrySet()) {
			int qci = entry.getKey();
			PlrDlQciRsrp plrDlQciRsrp = entry.getValue();
			if (!plrDlQciRsrp.isNotEmpty()) {
				continue;
			}
			PlrDlQciRsrp plrDlQciRsrpSum = null;
			if (mapPlrDlQciRsrp.containsKey(qci)) {
				plrDlQciRsrpSum = mapPlrDlQciRsrp.get(qci);
			} else {
				plrDlQciRsrpSum = new PlrDlQciRsrp(_splitStr);
			}
			plrDlQciRsrpSum.sum(plrDlQciRsrp);
			mapPlrDlQciRsrp.put(qci, plrDlQciRsrpSum);
		}
		
		for (Map.Entry<Integer, PlrUlQciRip> entry : tdlMrsValue.getPlrUlQciRip().entrySet()) {
			int qci = entry.getKey();
			PlrUlQciRip plrUlQciRip = entry.getValue();
			if (!plrUlQciRip.isNotEmpty()) {
				continue;
			}
			PlrUlQciRip plrUlQciRipSum = null;
			if (mapPlrUlQciRip.containsKey(qci)) {
				plrUlQciRipSum = mapPlrUlQciRip.get(qci);
			} else {
				plrUlQciRipSum = new PlrUlQciRip(_splitStr);
			}
			plrUlQciRipSum.sum(plrUlQciRip);
			mapPlrUlQciRip.put(qci, plrUlQciRipSum);
		}
		
		if (tdlMrsValue.isNotEmptySinrUlRip()) {
			sinrUlRip.sum(tdlMrsValue.getSinrUlRip());
		}
		
		if (tdlMrsValue.isNotEmptyTadvRsrp()) {
			tadvRsrp.sum(tdlMrsValue.getTadvRsrp());
		}
		
		if (tdlMrsValue.isNotEmptyTadvAoa()) {
			tadvAoa.sum(tdlMrsValue.getTadvAoa());
		}
		
		if (tdlMrsValue.isNotEmptyPuschPrbNumPhr()) {
			puschPrbNumPhr.sum(tdlMrsValue.getPuschPrbNumPhr());
		}
		
		if (tdlMrsValue.isNotEmptyPdschPrbNumRsrq()) {
			pdschPrbNumRsrq.sum(tdlMrsValue.getPdschPrbNumRsrq());
		}
	}
	
	public void makeRsrp(String[] valueItems) {
		rsrp.sum(valueItems, parse);
	}
	
	public void makeRsrq(String[] valueItems) {
		rsrq.sum(valueItems, parse);
	}
	
	public void makeRxTxTimeDiff(String[] valueItems) {
		rxTxTimeDiff.sum(valueItems, parse);
	}
	
	public void makePowerHeadRoom(String[] valueItems) {
		powerHeadRoom.sum(valueItems, parse);
	}
	
	public void makeReceivedIPower(String[] valueItems, String subFrame) {
		ReceivedIPower receivedIPower = null;
		if (mapReceivedIPower.containsKey(subFrame)) {
			receivedIPower = mapReceivedIPower.get(subFrame);
		} else {
			receivedIPower = new ReceivedIPower(_splitStr);
		}
		receivedIPower.sum(valueItems, parse);
		mapReceivedIPower.put(subFrame, receivedIPower);
	}
	
	public void makeAoa(String[] valueItems) {
		aoa.sum(valueItems, parse);
	}
	
	public void makePacketLossRateUlQci(String[] valueItems, int qci) {
		PacketLossRateUlQci packetLossRateUlQci = null;
		if (mapPacketLossRateUlQci.containsKey(qci)) {
			packetLossRateUlQci = mapPacketLossRateUlQci.get(qci);
		} else {
			packetLossRateUlQci = new PacketLossRateUlQci(_splitStr);
		}
		packetLossRateUlQci.sum(valueItems, parse);
		mapPacketLossRateUlQci.put(qci, packetLossRateUlQci);
	}
	
	public void makePacketLossRateDlQci(String[] valueItems, int qci) {
		PacketLossRateDlQci packetLossRateDlQci = null;
		if (mapPacketLossRateDlQci.containsKey(qci)) {
			packetLossRateDlQci = mapPacketLossRateDlQci.get(qci);
		} else {
			packetLossRateDlQci = new PacketLossRateDlQci(_splitStr);
		}
		packetLossRateDlQci.sum(valueItems, parse);
		mapPacketLossRateDlQci.put(qci, packetLossRateDlQci);
	}
	
	public void makeSinrUl(String[] valueItems) {
		sinrUl.sum(valueItems, parse);
	}
	
	public void makeTadv(String[] valueItems) {
		tadv.sum(valueItems, parse);
	}
	
	public void makeRipPrb(String[] valueItems, String subFrame) {
		RipPrb ripPrb = null;
		if (mapRipPrb.containsKey(subFrame)) {
			ripPrb = mapRipPrb.get(subFrame);
		} else {
			ripPrb = new RipPrb(_splitStr);
		}
		ripPrb.sum(valueItems, parse);
		mapRipPrb.put(subFrame, ripPrb);
	}
	
	public void makePuschPrbNum(String[] valueItems) {
		puschPrbNum.sum(valueItems, parse);
	}
	
	public void makePdschPrbNum(String[] valueItems) {
		pdschPrbNum.sum(valueItems, parse);
	}
	
	public void makeEnbRxTxTimeDiff(String[] valueItems) {
		enbRxTxTimeDiff.sum(valueItems, parse);
	}
	
	public void makeRttdRsrp(String[] valueItems) {
		rttdRsrp.sum(valueItems, parse);
	}
	
	public void makeRttdAoa(String[] valueItems) {
		rttdAoa.sum(valueItems, parse);
	}
	
	public void makeRsrpRsrq(String[] valueItems) {
		rsrpRsrq.sum(valueItems, parse);
	}
	
	public void makeRipRsrp(String[] valueItems) {
		ripRsrp.sum(valueItems, parse);
	}
	
	public void makeRipRsrq(String[] valueItems) {
		ripRsrq.sum(valueItems, parse);
	}
	
	public void makePlrUlQciSinrUl(String[] valueItems, int qci) {
		PlrUlQciSinrUl plrUlQciSinrUl = null;
		if (mapPlrUlQciSinrUl.containsKey(qci)) {
			plrUlQciSinrUl = mapPlrUlQciSinrUl.get(qci);
		} else {
			plrUlQciSinrUl = new PlrUlQciSinrUl(_splitStr);
		}
		plrUlQciSinrUl.sum(valueItems, parse);
		mapPlrUlQciSinrUl.put(qci, plrUlQciSinrUl);
	}
	
	public void makePlrDlQciRsrq(String[] valueItems, int qci) {
		PlrDlQciRsrq plrDlQciRsrq = null;
		if (mapPlrDlQciRsrq.containsKey(qci)) {
			plrDlQciRsrq = mapPlrDlQciRsrq.get(qci);
		} else {
			plrDlQciRsrq = new PlrDlQciRsrq(_splitStr);
		}
		plrDlQciRsrq.sum(valueItems, parse);
		mapPlrDlQciRsrq.put(qci, plrDlQciRsrq);
	}
	
	public void makePlrDlQciRsrp(String[] valueItems, int qci) {
		PlrDlQciRsrp plrDlQciRsrp = null;
		if (mapPlrDlQciRsrp.containsKey(qci)) {
			plrDlQciRsrp = mapPlrDlQciRsrp.get(qci);
		} else {
			plrDlQciRsrp = new PlrDlQciRsrp(_splitStr);
		}
		plrDlQciRsrp.sum(valueItems, parse);
		mapPlrDlQciRsrp.put(qci, plrDlQciRsrp);
	}
	
	public void makePlrUlQciRip(String[] valueItems, int qci) {
		PlrUlQciRip plrUlQciRip = null;
		if (mapPlrUlQciRip.containsKey(qci)) {
			plrUlQciRip = mapPlrUlQciRip.get(qci);
		} else {
			plrUlQciRip = new PlrUlQciRip(_splitStr);
		}
		plrUlQciRip.sum(valueItems, parse);
		mapPlrUlQciRip.put(qci, plrUlQciRip);
	}
	
	public void makeSinrUlRip(String[] valueItems) {
		sinrUlRip.sum(valueItems, parse);
	}
	
	public void makeTadvRsrp(String[] valueItems) {
		tadvRsrp.sum(valueItems, parse);
	}
	
	public void makeTadvAoa(String[] valueItems) {
		tadvAoa.sum(valueItems, parse);
	}
	
	public void makePuschPrbNumPhr(String[] valueItems) {
		puschPrbNumPhr.sum(valueItems, parse);
	}
	
	public void makePdschPrbNumRsrq(String[] valueItems) {
		pdschPrbNumRsrq.sum(valueItems, parse);
	}
	
	public void makeReceivedIPowerSum(ReceivedIPower receivedIPowerSum) {
		receivedIPower.sum(receivedIPowerSum);
	}
	
	public Rsrp getRsrp() {
		return rsrp;
	}
	
	public Rsrq getRsrq() {
		return rsrq;
	}
	
	public RxTxTimeDiff getRxTxTimeDiff() {
		return rxTxTimeDiff;
	}
	
	public PowerHeadRoom getPowerHeadRoom() {
		return powerHeadRoom;
	}
	
	public Aoa getAoa() {
		return aoa;
	}
	
	public Map<Integer, PacketLossRateUlQci> getPacketLossRateUlQci() {
		return mapPacketLossRateUlQci;
	}
	
	public Map<Integer, PacketLossRateDlQci> getPacketLossRateDlQci() {
		return mapPacketLossRateDlQci;
	}
	
	public SinrUl getSinrUl() {
		return sinrUl;
	}
	
	public Tadv getTadv() {
		return tadv;
	}
	
	public Map<String, RipPrb> getRipPrb() {
		return mapRipPrb;
	}
	
	public PuschPrbNum getPuschPrbNum() {
		return puschPrbNum;
	}
	
	public PdschPrbNum getPdschPrbNum() {
		return pdschPrbNum;
	}
	
	public EnbRxTxTimeDiff getEnbRxTxTimeDiff() {
		return enbRxTxTimeDiff;
	}
	
	public RttdRsrp getRttdRsrp() {
		return rttdRsrp;
	}
	
	public RttdAoa getRttdAoa() {
		return rttdAoa;
	}
	
	public RsrpRsrq getRsrpRsrq() {
		return rsrpRsrq;
	}
	
	public RipRsrp getRipRsrp() {
		return ripRsrp;
	}
	
	public RipRsrq getRipRsrq() {
		return ripRsrq;
	}
	
	public Map<Integer, PlrUlQciSinrUl> getPlrUlQciSinrUl() {
		return mapPlrUlQciSinrUl;
	}
	
	public Map<Integer, PlrDlQciRsrq> getPlrDlQciRsrq() {
		return mapPlrDlQciRsrq;
	}
	
	public Map<Integer, PlrDlQciRsrp> getPlrDlQciRsrp() {
		return mapPlrDlQciRsrp;
	}
	
	public Map<Integer, PlrUlQciRip> getPlrUlQciRip() {
		return mapPlrUlQciRip;
	}
	
	public SinrUlRip getSinrUlRip() {
		return sinrUlRip;
	}
	
	public TadvRsrp getTadvRsrp() {
		return tadvRsrp;
	}
	
	public TadvAoa getTadvAoa() {
		return tadvAoa;
	}
	
	public PuschPrbNumPhr getPuschPrbNumPhr() {
		return puschPrbNumPhr;
	}
	
	public PdschPrbNumRsrq getPdschPrbNumRsrq() {
		return pdschPrbNumRsrq;
	}
	
	public String getRsrpLine(StringBuffer line) {
		return rsrp.getLine(line);
	}
	
	public String getRsrqLine(StringBuffer line) {
		return rsrq.getLine(line);
	}
	
	public String getRxTxTimeDiffLine(StringBuffer line) {
		return rxTxTimeDiff.getLine(line);
	}
	
	public String getPowerHeadRoomLine(StringBuffer line) {
		return powerHeadRoom.getLine(line);
	}
	
	public Map<String, ReceivedIPower> getReceivedIPower() {
		return mapReceivedIPower;
	}
	
	public String getAoaLine(StringBuffer line) {
		return aoa.getLine(line);
	}
	
	public String getSinrUlLine(StringBuffer line) {
		return sinrUl.getLine(line);
	}
	
	public String getTadvLine(StringBuffer line) {
		return tadv.getLine(line);
	}
	
	public String getPuschPrbNumLine(StringBuffer line) {
		return puschPrbNum.getLine(line);
	}
	
	public String getPdschPrbNumLine(StringBuffer line) {
		return pdschPrbNum.getLine(line);
	}
	
	public String getEnbRxTxTimeDiffLine(StringBuffer line) {
		return enbRxTxTimeDiff.getLine(line);
	}
	
	public String getRttdRsrpLine(StringBuffer line) {
		return rttdRsrp.getLine(line);
	}
	
	public String getRttdAoaLine(StringBuffer line) {
		return rttdAoa.getLine(line);
	}
	
	public String getRsrpRsrqLine(StringBuffer line) {
		return rsrpRsrq.getLine(line);
	}
	
	public String getRipRsrpLine(StringBuffer line) {
		return ripRsrp.getLine(line);
	}
	
	public String getRipRsrqLine(StringBuffer line) {
		return ripRsrq.getLine(line);
	}
	
	public String getSinrUlRipLine(StringBuffer line) {
		return sinrUlRip.getLine(line);
	}
	
	public String getTadvRsrpLine(StringBuffer line) {
		return tadvRsrp.getLine(line);
	}
	
	public String getTadvAoaLine(StringBuffer line) {
		return tadvAoa.getLine(line);
	}
	
	public String getPuschPrbNumPhrLine(StringBuffer line) {
		return puschPrbNumPhr.getLine(line);
	}
	
	public String getPdschPrbNumRsrqLine(StringBuffer line) {
		return pdschPrbNumRsrq.getLine(line);
	}
	
	public String getReceivedIPowerLine(StringBuffer line) {
		return receivedIPower.getLine(line);
	}
	
	public boolean isNotEmptyRsrp() {
		return rsrp.isNotEmpty();
	}
	
	public boolean isNotEmptyRsrq() {
		return rsrq.isNotEmpty();
	}
	
	public boolean isNotEmptyRxTxTimeDiff() {
		return rxTxTimeDiff.isNotEmpty();
	}
	
	public boolean isNotEmptyPowerHeadRoom() {
		return powerHeadRoom.isNotEmpty();
	}
	
	public boolean isNotEmptyAoa() {
		return aoa.isNotEmpty();
	}
	
	public boolean isNotEmptySinrUl() {
		return sinrUl.isNotEmpty();
	}
	
	public boolean isNotEmptyTadv() {
		return tadv.isNotEmpty();
	}
	
	public boolean isNotEmptyPuschPrbNum() {
		return puschPrbNum.isNotEmpty();
	}
	
	public boolean isNotEmptyPdschPrbNum() {
		return pdschPrbNum.isNotEmpty();
	}
	
	public boolean isNotEmptyEnbRxTxTimeDiff() {
		return enbRxTxTimeDiff.isNotEmpty();
	}
	
	public boolean isNotEmptyRttdRsrp() {
		return rttdRsrp.isNotEmpty();
	}
	
	public boolean isNotEmptyRttdAoa() {
		return rttdAoa.isNotEmpty();
	}
	
	public boolean isNotEmptyRsrpRsrq() {
		return rsrpRsrq.isNotEmpty();
	}
	
	public boolean isNotEmptyRipRsrp() {
		return ripRsrp.isNotEmpty();
	}
	
	public boolean isNotEmptyRipRsrq() {
		return ripRsrq.isNotEmpty();
	}
	
	public boolean isNotEmptySinrUlRip() {
		return sinrUlRip.isNotEmpty();
	}
	
	public boolean isNotEmptyTadvRsrp() {
		return tadvRsrp.isNotEmpty();
	}
	
	public boolean isNotEmptyTadvAoa() {
		return tadvAoa.isNotEmpty();
	}
	
	public boolean isNotEmptyPuschPrbNumPhr() {
		return puschPrbNumPhr.isNotEmpty();
	}
	
	public boolean isNotEmptyPdschPrbNumRsrq() {
		return pdschPrbNumRsrq.isNotEmpty();
	}
	
	public boolean isNotEmptyReceivedIPower() {
		return receivedIPower.isNotEmpty();
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class PdschPrbNumRsrq {
	private final int pdschPrbNumLen = 11;
	private final int rsrqLen = 10;
	private int[][] pdschPrbNumRsrqs = new int[pdschPrbNumLen][rsrqLen];
	private double[] pdschPrbNumSum = new double[pdschPrbNumLen];
	private int[] pdschPrbNumCnt = new int[pdschPrbNumLen];
	private double[] rsrqSum = new double[rsrqLen];
	private int[] rsrqCnt = new int[rsrqLen];
	private boolean pdschPrbNumRsrqFlag = false;
	private String _splitStr = "";
	
	public PdschPrbNumRsrq(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < pdschPrbNumLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				pdschPrbNumRsrqs[i][j] = 0;
			}
			pdschPrbNumSum[i] = 0;
			pdschPrbNumCnt[i] = 0;
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			rsrqSum[i] = 0;
			rsrqCnt[i] = 0;
		}
	}
	
	public void sum(PdschPrbNumRsrq pdschPrbNumRsrq) {
		if (!pdschPrbNumRsrq.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < pdschPrbNumLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				pdschPrbNumRsrqs[i][j] += pdschPrbNumRsrq.getPdschPrbNumRsrq(i, j);
			}
			pdschPrbNumSum[i] += pdschPrbNumRsrq.getPdschPrbNumSum(i);
			pdschPrbNumCnt[i] += pdschPrbNumRsrq.getPdschPrbNumCnt(i);
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			rsrqSum[i] += pdschPrbNumRsrq.getRsrqSum(i);
			rsrqCnt[i] += pdschPrbNumRsrq.getRsrqCnt(i);
		}
		pdschPrbNumRsrqFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != pdschPrbNumLen * rsrqLen) {
			return;
		}
		
		for (int i = 0; i < pdschPrbNumLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				int num = Integer.parseInt(valueItems[i * rsrqLen + j]);
				pdschPrbNumRsrqs[i][j] += num;
				pdschPrbNumSum[i] += parse.getPdschPrbNum2DimValue(i) * num;
				pdschPrbNumCnt[i] += num;
				rsrqSum[j] += parse.getRsrq2DimValue(j) * num;
				rsrqCnt[j] += num;
			}
		}
		pdschPrbNumRsrqFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < pdschPrbNumLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				line.append(pdschPrbNumRsrqs[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(rsrqSum[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(rsrqCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < pdschPrbNumLen; i++) {
			line.append(pdschPrbNumSum[i]).append(_splitStr);
		}
		for (int i = 0; i < pdschPrbNumLen; i++) {
			line.append(pdschPrbNumCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(div(rsrqSum[i], rsrqCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < pdschPrbNumLen; i++) {
			line.append(div(pdschPrbNumSum[i], pdschPrbNumCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return pdschPrbNumRsrqFlag;
	}
	
	public int getPdschPrbNumRsrq(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= pdschPrbNumLen || idx2 < 0 || idx2 >= rsrqLen) {
			return 0;
		}
		return pdschPrbNumRsrqs[idx1][idx2];
	}
	
	public double getPdschPrbNumSum(int idx) {
		if (idx < 0 || idx >= pdschPrbNumLen) {
			return 0;
		}
		return pdschPrbNumSum[idx];
	}
	
	public int getPdschPrbNumCnt(int idx) {
		if (idx < 0 || idx >= pdschPrbNumLen) {
			return 0;
		}
		return pdschPrbNumCnt[idx];
	}
	
	public double getRsrqSum(int idx) {
		if (idx < 0 || idx >= rsrqLen) {
			return 0;
		}
		return rsrqSum[idx];
	}
	
	public int getRsrqCnt(int idx) {
		if (idx < 0 || idx >= rsrqLen) {
			return 0;
		}
		return rsrqCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class PlrDlQciRsrp {
	private final int plrDlQciLen = 8;
	private final int rsrpLen = 12;
	private int[][] plrDlQciRsrps = new int[plrDlQciLen][rsrpLen];
	private double[] plrDlQciSum = new double[plrDlQciLen];
	private int[] plrDlQciCnt = new int[plrDlQciLen];
	private double[] rsrpSum = new double[rsrpLen];
	private int[] rsrpCnt = new int[rsrpLen];
	private boolean plrDlQciRsrpFlag = false;
	private String _splitStr = "";
	
	public PlrDlQciRsrp(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < plrDlQciLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				plrDlQciRsrps[i][j] = 0;
			}
			plrDlQciSum[i] = 0;
			plrDlQciCnt[i] = 0;
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrpSum[i] = 0;
			rsrpCnt[i] = 0;
		}
	}
	
	public void sum(PlrDlQciRsrp plrDlQciRsrp) {
		if (!plrDlQciRsrp.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < plrDlQciLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				plrDlQciRsrps[i][j] += plrDlQciRsrp.getPlrDlQciRsrp(i, j);
			}
			plrDlQciSum[i] += plrDlQciRsrp.getPlrDlQciSum(i);
			plrDlQciCnt[i] += plrDlQciRsrp.getPlrDlQciCnt(i);
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrpSum[i] += plrDlQciRsrp.getRsrpSum(i);
			rsrpCnt[i] += plrDlQciRsrp.getRsrpCnt(i);
		}
		plrDlQciRsrpFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != plrDlQciLen * rsrpLen) {
			return;
		}
		
		for (int i = 0; i < plrDlQciLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				int num = Integer.parseInt(valueItems[i * rsrpLen + j]);
				plrDlQciRsrps[i][j] += num;
				plrDlQciSum[i] += parse.getPlrDlQci2DimValue(i) * num;
				plrDlQciCnt[i] += num;
				rsrpSum[j] += parse.getRsrp2DimValue(j) * num;
				rsrpCnt[j] += num;
			}
		}
		plrDlQciRsrpFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < plrDlQciLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				line.append(plrDlQciRsrps[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrpSum[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrpCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < plrDlQciLen; i++) {
			line.append(plrDlQciSum[i]).append(_splitStr);
		}
		for (int i = 0; i < plrDlQciLen; i++) {
			line.append(plrDlQciCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(div(rsrpSum[i], rsrpCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < plrDlQciLen; i++) {
			line.append(div(plrDlQciSum[i], plrDlQciCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return plrDlQciRsrpFlag;
	}
	
	public int getPlrDlQciRsrp(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= plrDlQciLen || idx2 < 0 || idx2 >= rsrpLen) {
			return 0;
		}
		return plrDlQciRsrps[idx1][idx2];
	}
	
	public double getPlrDlQciSum(int idx) {
		if (idx < 0 || idx >= plrDlQciLen) {
			return 0;
		}
		return plrDlQciSum[idx];
	}
	
	public int getPlrDlQciCnt(int idx) {
		if (idx < 0 || idx >= plrDlQciLen) {
			return 0;
		}
		return plrDlQciCnt[idx];
	}
	
	public double getRsrpSum(int idx) {
		if (idx < 0 || idx >= rsrpLen) {
			return 0;
		}
		return rsrpSum[idx];
	}
	
	public int getRsrpCnt(int idx) {
		if (idx < 0 || idx >= rsrpLen) {
			return 0;
		}
		return rsrpCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class PlrDlQciRsrq {
	private final int plrDlQciLen = 8;
	private final int rsrqLen = 10;
	private int[][] plrDlQciRsrqs = new int[plrDlQciLen][rsrqLen];
	private double[] plrDlQciSum = new double[plrDlQciLen];
	private int[] plrDlQciCnt = new int[plrDlQciLen];
	private double[] rsrqSum = new double[rsrqLen];
	private int[] rsrqCnt = new int[rsrqLen];
	private boolean plrDlQciRsrqFlag = false;
	private String _splitStr = "";
	
	public PlrDlQciRsrq(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < plrDlQciLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				plrDlQciRsrqs[i][j] = 0;
			}
			plrDlQciSum[i] = 0;
			plrDlQciCnt[i] = 0;
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			rsrqSum[i] = 0;
			rsrqCnt[i] = 0;
		}
	}
	
	public void sum(PlrDlQciRsrq plrDlQciRsrq) {
		if (!plrDlQciRsrq.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < plrDlQciLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				plrDlQciRsrqs[i][j] += plrDlQciRsrq.getPlrDlQciRsrq(i, j);
			}
			plrDlQciSum[i] += plrDlQciRsrq.getPlrDlQciSum(i);
			plrDlQciCnt[i] += plrDlQciRsrq.getPlrDlQciCnt(i);
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			rsrqSum[i] += plrDlQciRsrq.getRsrqSum(i);
			rsrqCnt[i] += plrDlQciRsrq.getRsrqCnt(i);
		}
		plrDlQciRsrqFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != plrDlQciLen * rsrqLen) {
			return;
		}
		
		for (int i = 0; i < plrDlQciLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				int num = Integer.parseInt(valueItems[i * rsrqLen + j]);
				plrDlQciRsrqs[i][j] += num;
				plrDlQciSum[i] += parse.getPlrDlQci2DimValue(i) * num;
				plrDlQciCnt[i] += num;
				rsrqSum[j] += parse.getRsrq2DimValue(j) * num;
				rsrqCnt[j] += num;
			}
		}
		plrDlQciRsrqFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < plrDlQciLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				line.append(plrDlQciRsrqs[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(rsrqSum[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(rsrqCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < plrDlQciLen; i++) {
			line.append(plrDlQciSum[i]).append(_splitStr);
		}
		for (int i = 0; i < plrDlQciLen; i++) {
			line.append(plrDlQciCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(div(rsrqSum[i], rsrqCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < plrDlQciLen; i++) {
			line.append(div(plrDlQciSum[i], plrDlQciCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return plrDlQciRsrqFlag;
	}
	
	public int getPlrDlQciRsrq(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= plrDlQciLen || idx2 < 0 || idx2 >= rsrqLen) {
			return 0;
		}
		return plrDlQciRsrqs[idx1][idx2];
	}
	
	public double getPlrDlQciSum(int idx) {
		if (idx < 0 || idx >= plrDlQciLen) {
			return 0;
		}
		return plrDlQciSum[idx];
	}
	
	public int getPlrDlQciCnt(int idx) {
		if (idx < 0 || idx >= plrDlQciLen) {
			return 0;
		}
		return plrDlQciCnt[idx];
	}
	
	public double getRsrqSum(int idx) {
		if (idx < 0 || idx >= rsrqLen) {
			return 0;
		}
		return rsrqSum[idx];
	}
	
	public int getRsrqCnt(int idx) {
		if (idx < 0 || idx >= rsrqLen) {
			return 0;
		}
		return rsrqCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class PlrUlQciRip {
	private final int plrUlQciLen = 8;
	private final int ripLen = 9;
	private int[][] plrUlQciRips = new int[plrUlQciLen][ripLen];
	private double[] plrUlQciSum = new double[plrUlQciLen];
	private int[] plrUlQciCnt = new int[plrUlQciLen];
	private double[] ripSum = new double[ripLen];
	private int[] ripCnt = new int[ripLen];
	private boolean plrUlQciRipFlag = false;
	private String _splitStr = "";
	
	public PlrUlQciRip(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < plrUlQciLen; i++) {
			for (int j = 0; j < ripLen; j++) {
				plrUlQciRips[i][j] = 0;
			}
			plrUlQciSum[i] = 0;
			plrUlQciCnt[i] = 0;
		}
		
		for (int i = 0; i < ripLen; i++) {
			ripSum[i] = 0;
			ripCnt[i] = 0;
		}
	}
	
	public void sum(PlrUlQciRip plrUlQciRip) {
		if (!plrUlQciRip.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < plrUlQciLen; i++) {
			for (int j = 0; j < ripLen; j++) {
				plrUlQciRips[i][j] += plrUlQciRip.getPlrUlQciRip(i, j);
			}
			plrUlQciSum[i] += plrUlQciRip.getPlrUlQciSum(i);
			plrUlQciCnt[i] += plrUlQciRip.getPlrUlQciCnt(i);
		}
		
		for (int i = 0; i < ripLen; i++) {
			ripSum[i] += plrUlQciRip.getRipSum(i);
			ripCnt[i] += plrUlQciRip.getRipCnt(i);
		}
		plrUlQciRipFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != plrUlQciLen * ripLen) {
			return;
		}
		
		for (int i = 0; i < plrUlQciLen; i++) {
			for (int j = 0; j < ripLen; j++) {
				int num = Integer.parseInt(valueItems[i * ripLen + j]);
				plrUlQciRips[i][j] += num;
				plrUlQciSum[i] += parse.getPlrUlQci2DimValue(i) * num;
				plrUlQciCnt[i] += num;
				ripSum[j] += parse.getRip2DimValue(j) * num;
				ripCnt[j] += num;
			}
		}
		plrUlQciRipFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < plrUlQciLen; i++) {
			for (int j = 0; j < ripLen; j++) {
				line.append(plrUlQciRips[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(ripSum[i]).append(_splitStr);
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(ripCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < plrUlQciLen; i++) {
			line.append(plrUlQciSum[i]).append(_splitStr);
		}
		for (int i = 0; i < plrUlQciLen; i++) {
			line.append(plrUlQciCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(div(ripSum[i], ripCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < plrUlQciLen; i++) {
			line.append(div(plrUlQciSum[i], plrUlQciCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return plrUlQciRipFlag;
	}
	
	public int getPlrUlQciRip(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= plrUlQciLen || idx2 < 0 || idx2 >= ripLen) {
			return 0;
		}
		return plrUlQciRips[idx1][idx2];
	}
	
	public double getPlrUlQciSum(int idx) {
		if (idx < 0 || idx >= plrUlQciLen) {
			return 0;
		}
		return plrUlQciSum[idx];
	}
	
	public int getPlrUlQciCnt(int idx) {
		if (idx < 0 || idx >= plrUlQciLen) {
			return 0;
		}
		return plrUlQciCnt[idx];
	}
	
	public double getRipSum(int idx) {
		if (idx < 0 || idx >= ripLen) {
			return 0;
		}
		return ripSum[idx];
	}
	
	public int getRipCnt(int idx) {
		if (idx < 0 || idx >= ripLen) {
			return 0;
		}
		return ripCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class PlrUlQciSinrUl {
	private final int plrUlQciLen = 8;
	private final int sinrUlLen = 11;
	private int[][] plrUlQciSinrUls = new int[plrUlQciLen][sinrUlLen];
	private double[] plrUlQciSum = new double[plrUlQciLen];
	private int[] plrUlQciCnt = new int[plrUlQciLen];
	private double[] sinrUlSum = new double[sinrUlLen];
	private int[] sinrUlCnt = new int[sinrUlLen];
	private boolean plrUlQciSinrUlFlag = false;
	private String _splitStr = "";
	
	public PlrUlQciSinrUl(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < plrUlQciLen; i++) {
			for (int j = 0; j < sinrUlLen; j++) {
				plrUlQciSinrUls[i][j] = 0;
			}
			plrUlQciSum[i] = 0;
			plrUlQciCnt[i] = 0;
		}
		
		for (int i = 0; i < sinrUlLen; i++) {
			sinrUlSum[i] = 0;
			sinrUlCnt[i] = 0;
		}
	}
	
	public void sum(PlrUlQciSinrUl plrUlQciSinrUl) {
		if (!plrUlQciSinrUl.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < plrUlQciLen; i++) {
			for (int j = 0; j < sinrUlLen; j++) {
				plrUlQciSinrUls[i][j] += plrUlQciSinrUl.getPlrUlQciSinrUl(i, j);
			}
			plrUlQciSum[i] += plrUlQciSinrUl.getPlrUlQciSum(i);
			plrUlQciCnt[i] += plrUlQciSinrUl.getPlrUlQciCnt(i);
		}
		
		for (int i = 0; i < sinrUlLen; i++) {
			sinrUlSum[i] += plrUlQciSinrUl.getSinrUlSum(i);
			sinrUlCnt[i] += plrUlQciSinrUl.getSinrUlCnt(i);
		}
		plrUlQciSinrUlFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != plrUlQciLen * sinrUlLen) {
			return;
		}
		
		for (int i = 0; i < plrUlQciLen; i++) {
			for (int j = 0; j < sinrUlLen; j++) {
				int num = Integer.parseInt(valueItems[i * sinrUlLen + j]);
				plrUlQciSinrUls[i][j] += num;
				plrUlQciSum[i] += parse.getPlrUlQci2DimValue(i) * num;
				plrUlQciCnt[i] += num;
				sinrUlSum[j] += parse.getSinrUl2DimValue(j) * num;
				sinrUlCnt[j] += num;
			}
		}
		plrUlQciSinrUlFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < plrUlQciLen; i++) {
			for (int j = 0; j < sinrUlLen; j++) {
				line.append(plrUlQciSinrUls[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < sinrUlLen; i++) {
			line.append(sinrUlSum[i]).append(_splitStr);
		}
		for (int i = 0; i < sinrUlLen; i++) {
			line.append(sinrUlCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < plrUlQciLen; i++) {
			line.append(plrUlQciSum[i]).append(_splitStr);
		}
		for (int i = 0; i < plrUlQciLen; i++) {
			line.append(plrUlQciCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < sinrUlLen; i++) {
			line.append(div(sinrUlSum[i], sinrUlCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < plrUlQciLen; i++) {
			line.append(div(plrUlQciSum[i], plrUlQciCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return plrUlQciSinrUlFlag;
	}
	
	public int getPlrUlQciSinrUl(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= plrUlQciLen || idx2 < 0 || idx2 >= sinrUlLen) {
			return 0;
		}
		return plrUlQciSinrUls[idx1][idx2];
	}
	
	public double getPlrUlQciSum(int idx) {
		if (idx < 0 || idx >= plrUlQciLen) {
			return 0;
		}
		return plrUlQciSum[idx];
	}
	
	public int getPlrUlQciCnt(int idx) {
		if (idx < 0 || idx >= plrUlQciLen) {
			return 0;
		}
		return plrUlQciCnt[idx];
	}
	
	public double getSinrUlSum(int idx) {
		if (idx < 0 || idx >= sinrUlLen) {
			return 0;
		}
		return sinrUlSum[idx];
	}
	
	public int getSinrUlCnt(int idx) {
		if (idx < 0 || idx >= sinrUlLen) {
			return 0;
		}
		return sinrUlCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class PuschPrbNumPhr {
	private final int puschPrbNumLen = 11;
	private final int phrLen = 16;
	private int[][] puschPrbNumPhrs = new int[puschPrbNumLen][phrLen];
	private double[] puschPrbNumSum = new double[puschPrbNumLen];
	private int[] puschPrbNumCnt = new int[puschPrbNumLen];
	private double[] phrSum = new double[phrLen];
	private int[] phrCnt = new int[phrLen];
	private boolean puschPrbNumPhrFlag = false;
	private String _splitStr = "";
	
	public PuschPrbNumPhr(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < puschPrbNumLen; i++) {
			for (int j = 0; j < phrLen; j++) {
				puschPrbNumPhrs[i][j] = 0;
			}
			puschPrbNumSum[i] = 0;
			puschPrbNumCnt[i] = 0;
		}
		
		for (int i = 0; i < phrLen; i++) {
			phrSum[i] = 0;
			phrCnt[i] = 0;
		}
	}
	
	public void sum(PuschPrbNumPhr puschPrbNumPhr) {
		if (!puschPrbNumPhr.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < puschPrbNumLen; i++) {
			for (int j = 0; j < phrLen; j++) {
				puschPrbNumPhrs[i][j] += puschPrbNumPhr.getPuschPrbNumPhr(i, j);
			}
			puschPrbNumSum[i] += puschPrbNumPhr.getPuschPrbNumSum(i);
			puschPrbNumCnt[i] += puschPrbNumPhr.getPuschPrbNumCnt(i);
		}
		
		for (int i = 0; i < phrLen; i++) {
			phrSum[i] += puschPrbNumPhr.getPhrSum(i);
			phrCnt[i] += puschPrbNumPhr.getPhrCnt(i);
		}
		puschPrbNumPhrFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != puschPrbNumLen * phrLen) {
			return;
		}
		
		for (int i = 0; i < puschPrbNumLen; i++) {
			for (int j = 0; j < phrLen; j++) {
				int num = Integer.parseInt(valueItems[i * phrLen + j]);
				puschPrbNumPhrs[i][j] += num;
				puschPrbNumSum[i] += parse.getPuschPrbNum2DimValue(i) * num;
				puschPrbNumCnt[i] += num;
				phrSum[j] += parse.getPhr2DimValue(j) * num;
				phrCnt[j] += num;
			}
		}
		puschPrbNumPhrFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < puschPrbNumLen; i++) {
			for (int j = 0; j < phrLen; j++) {
				line.append(puschPrbNumPhrs[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < phrLen; i++) {
			line.append(phrSum[i]).append(_splitStr);
		}
		for (int i = 0; i < phrLen; i++) {
			line.append(phrCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < puschPrbNumLen; i++) {
			line.append(puschPrbNumSum[i]).append(_splitStr);
		}
		for (int i = 0; i < puschPrbNumLen; i++) {
			line.append(puschPrbNumCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < phrLen; i++) {
			line.append(div(phrSum[i], phrCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < puschPrbNumLen; i++) {
			line.append(div(puschPrbNumSum[i], puschPrbNumCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return puschPrbNumPhrFlag;
	}
	
	public int getPuschPrbNumPhr(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= puschPrbNumLen || idx2 < 0 || idx2 >= phrLen) {
			return 0;
		}
		return puschPrbNumPhrs[idx1][idx2];
	}
	
	public double getPuschPrbNumSum(int idx) {
		if (idx < 0 || idx >= puschPrbNumLen) {
			return 0;
		}
		return puschPrbNumSum[idx];
	}
	
	public int getPuschPrbNumCnt(int idx) {
		if (idx < 0 || idx >= puschPrbNumLen) {
			return 0;
		}
		return puschPrbNumCnt[idx];
	}
	
	public double getPhrSum(int idx) {
		if (idx < 0 || idx >= phrLen) {
			return 0;
		}
		return phrSum[idx];
	}
	
	public int getPhrCnt(int idx) {
		if (idx < 0 || idx >= phrLen) {
			return 0;
		}
		return phrCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class RipRsrp {
	private final int ripLen = 9;
	private final int rsrpLen = 12;
	private int[][] ripRsrps = new int[ripLen][rsrpLen];
	private double[] ripSum = new double[ripLen];
	private int[] ripCnt = new int[ripLen];
	private double[] rsrpSum = new double[rsrpLen];
	private int[] rsrpCnt = new int[rsrpLen];
	private boolean ripRsrpFlag = false;
	private String _splitStr = "";
	
	public RipRsrp(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < ripLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				ripRsrps[i][j] = 0;
			}
			ripSum[i] = 0;
			ripCnt[i] = 0;
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrpSum[i] = 0;
			rsrpCnt[i] = 0;
		}
	}
	
	public void sum(RipRsrp ripRsrp) {
		if (!ripRsrp.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < ripLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				ripRsrps[i][j] += ripRsrp.getRipRsrp(i, j);
			}
			ripSum[i] += ripRsrp.getRipSum(i);
			ripCnt[i] += ripRsrp.getRipCnt(i);
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrpSum[i] += ripRsrp.getRsrpSum(i);
			rsrpCnt[i] += ripRsrp.getRsrpCnt(i);
		}
		ripRsrpFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != ripLen * rsrpLen) {
			return;
		}
		
		for (int i = 0; i < ripLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				int num = Integer.parseInt(valueItems[i * rsrpLen + j]);
				ripRsrps[i][j] += num;
				ripSum[i] += parse.getRip2DimValue(i) * num;
				ripCnt[i] += num;
				rsrpSum[j] += parse.getRsrp2DimValue(j) * num;
				rsrpCnt[j] += num;
			}
		}
		ripRsrpFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < ripLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				line.append(ripRsrps[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrpSum[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrpCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(ripSum[i]).append(_splitStr);
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(ripCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(div(rsrpSum[i], rsrpCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(div(ripSum[i], ripCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return ripRsrpFlag;
	}
	
	public int getRipRsrp(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= ripLen || idx2 < 0 || idx2 >= rsrpLen) {
			return 0;
		}
		return ripRsrps[idx1][idx2];
	}
	
	public double getRipSum(int idx) {
		if (idx < 0 || idx >= ripLen) {
			return 0;
		}
		return ripSum[idx];
	}
	
	public int getRipCnt(int idx) {
		if (idx < 0 || idx >= ripLen) {
			return 0;
		}
		return ripCnt[idx];
	}
	
	public double getRsrpSum(int idx) {
		if (idx < 0 || idx >= rsrpLen) {
			return 0;
		}
		return rsrpSum[idx];
	}
	
	public int getRsrpCnt(int idx) {
		if (idx < 0 || idx >= rsrpLen) {
			return 0;
		}
		return rsrpCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class RipRsrq {
	private final int ripLen = 9;
	private final int rsrqLen = 10;
	private int[][] ripRsrqs = new int[ripLen][rsrqLen];
	private double[] ripSum = new double[ripLen];
	private int[] ripCnt = new int[ripLen];
	private double[] rsrqSum = new double[rsrqLen];
	private int[] rsrqCnt = new int[rsrqLen];
	private boolean ripRsrqFlag = false;
	private String _splitStr = "";
	
	public RipRsrq(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < ripLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				ripRsrqs[i][j] = 0;
			}
			ripSum[i] = 0;
			ripCnt[i] = 0;
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			rsrqSum[i] = 0;
			rsrqCnt[i] = 0;
		}
	}
	
	public void sum(RipRsrq ripRsrq) {
		if (!ripRsrq.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < ripLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				ripRsrqs[i][j] += ripRsrq.getRipRsrq(i, j);
			}
			ripSum[i] += ripRsrq.getRipSum(i);
			ripCnt[i] += ripRsrq.getRipCnt(i);
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			rsrqSum[i] += ripRsrq.getRsrqSum(i);
			rsrqCnt[i] += ripRsrq.getRsrqCnt(i);
		}
		ripRsrqFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != ripLen * rsrqLen) {
			return;
		}
		
		for (int i = 0; i < ripLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				int num = Integer.parseInt(valueItems[i * rsrqLen + j]);
				ripRsrqs[i][j] += num;
				ripSum[i] += parse.getRip2DimValue(i) * num;
				ripCnt[i] += num;
				rsrqSum[j] += parse.getRsrq2DimValue(j) * num;
				rsrqCnt[j] += num;
			}
		}
		ripRsrqFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < ripLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				line.append(ripRsrqs[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(rsrqSum[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(rsrqCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(ripSum[i]).append(_splitStr);
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(ripCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(div(rsrqSum[i], rsrqCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(div(ripSum[i], ripCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return ripRsrqFlag;
	}
	
	public int getRipRsrq(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= ripLen || idx2 < 0 || idx2 >= rsrqLen) {
			return 0;
		}
		return ripRsrqs[idx1][idx2];
	}
	
	public double getRipSum(int idx) {
		if (idx < 0 || idx >= ripLen) {
			return 0;
		}
		return ripSum[idx];
	}
	
	public int getRipCnt(int idx) {
		if (idx < 0 || idx >= ripLen) {
			return 0;
		}
		return ripCnt[idx];
	}
	
	public double getRsrqSum(int idx) {
		if (idx < 0 || idx >= rsrqLen) {
			return 0;
		}
		return rsrqSum[idx];
	}
	
	public int getRsrqCnt(int idx) {
		if (idx < 0 || idx >= rsrqLen) {
			return 0;
		}
		return rsrqCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class RsrpRsrq {
	private final int rsrpLen = 12;
	private final int rsrqLen = 10;
	private int[][] rsrpRsrqs = new int[rsrpLen][rsrqLen];
	private double[] rsrpSum = new double[rsrpLen];
	private int[] rsrpCnt = new int[rsrpLen];
	private double[] rsrqSum = new double[rsrqLen];
	private int[] rsrqCnt = new int[rsrqLen];
	private boolean rsrpRsrqFlag = false;
	private String _splitStr = "";
	
	public RsrpRsrq(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < rsrpLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				rsrpRsrqs[i][j] = 0;
			}
			rsrpSum[i] = 0;
			rsrpCnt[i] = 0;
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			rsrqSum[i] = 0;
			rsrqCnt[i] = 0;
		}
	}
	
	public void sum(RsrpRsrq rsrpRsrq) {
		if (!rsrpRsrq.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				rsrpRsrqs[i][j] += rsrpRsrq.getRsrpRsrq(i, j);
			}
			rsrpSum[i] += rsrpRsrq.getRsrpSum(i);
			rsrpCnt[i] += rsrpRsrq.getRsrpCnt(i);
		}
		
		for (int i = 0; i < rsrqLen; i++) {
			rsrqSum[i] += rsrpRsrq.getRsrqSum(i);
			rsrqCnt[i] += rsrpRsrq.getRsrqCnt(i);
		}
		rsrpRsrqFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != rsrpLen * rsrqLen) {
			return;
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				int num = Integer.parseInt(valueItems[i * rsrqLen + j]);
				rsrpRsrqs[i][j] += num;
				rsrpSum[i] += parse.getRsrp2DimValue(i) * num;
				rsrpCnt[i] += num;
				rsrqSum[j] += parse.getRsrq2DimValue(j) * num;
				rsrqCnt[j] += num;
			}
		}
		rsrpRsrqFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rsrpLen; i++) {
			for (int j = 0; j < rsrqLen; j++) {
				line.append(rsrpRsrqs[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(rsrqSum[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(rsrqCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrpSum[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrpCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrqLen; i++) {
			line.append(div(rsrqSum[i], rsrqCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(div(rsrpSum[i], rsrpCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return rsrpRsrqFlag;
	}
	
	public int getRsrpRsrq(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= rsrpLen || idx2 < 0 || idx2 >= rsrqLen) {
			return 0;
		}
		return rsrpRsrqs[idx1][idx2];
	}
	
	public double getRsrpSum(int idx) {
		if (idx < 0 || idx >= rsrpLen) {
			return 0;
		}
		return rsrpSum[idx];
	}
	
	public int getRsrpCnt(int idx) {
		if (idx < 0 || idx >= rsrpLen) {
			return 0;
		}
		return rsrpCnt[idx];
	}
	
	public double getRsrqSum(int idx) {
		if (idx < 0 || idx >= rsrqLen) {
			return 0;
		}
		return rsrqSum[idx];
	}
	
	public int getRsrqCnt(int idx) {
		if (idx < 0 || idx >= rsrqLen) {
			return 0;
		}
		return rsrqCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class RttdAoa {
	private final int rttdLen = 12;
	private final int aoaLen = 12;
	private int[][] rttdAoas = new int[rttdLen][aoaLen];
	private double[] rttdSum = new double[rttdLen];
	private int[] rttdCnt = new int[rttdLen];
	private double[] aoaSum = new double[aoaLen];
	private int[] aoaCnt = new int[aoaLen];
	private boolean rttdAoaFlag = false;
	private String _splitStr = "";
	
	public RttdAoa(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < rttdLen; i++) {
			for (int j = 0; j < aoaLen; j++) {
				rttdAoas[i][j] = 0;
			}
			rttdSum[i] = 0;
			rttdCnt[i] = 0;
		}
		
		for (int i = 0; i < aoaLen; i++) {
			aoaSum[i] = 0;
			aoaCnt[i] = 0;
		}
	}
	
	public void sum(RttdAoa rttdAoa) {
		if (!rttdAoa.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < rttdLen; i++) {
			for (int j = 0; j < aoaLen; j++) {
				rttdAoas[i][j] += rttdAoa.getRttdAoa(i, j);
			}
			rttdSum[i] += rttdAoa.getRttdSum(i);
			rttdCnt[i] += rttdAoa.getRttdCnt(i);
		}
		
		for (int i = 0; i < aoaLen; i++) {
			aoaSum[i] += rttdAoa.getAoaSum(i);
			aoaCnt[i] += rttdAoa.getAoaCnt(i);
		}
		rttdAoaFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != rttdLen * aoaLen) {
			return;
		}
		
		for (int i = 0; i < rttdLen; i++) {
			for (int j = 0; j < aoaLen; j++) {
				int num = Integer.parseInt(valueItems[i * aoaLen + j]);
				rttdAoas[i][j] += num;
				rttdSum[i] += parse.getRttd2DimValue(i) * num;
				rttdCnt[i] += num;
				aoaSum[j] += parse.getAoa2DimValue(j) * num;
				aoaCnt[j] += num;
			}
		}
		rttdAoaFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rttdLen; i++) {
			for (int j = 0; j < aoaLen; j++) {
				line.append(rttdAoas[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < aoaLen; i++) {
			line.append(aoaSum[i]).append(_splitStr);
		}
		for (int i = 0; i < aoaLen; i++) {
			line.append(aoaCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < rttdLen; i++) {
			line.append(rttdSum[i]).append(_splitStr);
		}
		for (int i = 0; i < rttdLen; i++) {
			line.append(rttdCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < aoaLen; i++) {
			line.append(div(aoaSum[i], aoaCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < rttdLen; i++) {
			line.append(div(rttdSum[i], rttdCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return rttdAoaFlag;
	}
	
	public int getRttdAoa(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= rttdLen || idx2 < 0 || idx2 >= aoaLen) {
			return 0;
		}
		return rttdAoas[idx1][idx2];
	}
	
	public double getRttdSum(int idx) {
		if (idx < 0 || idx >= rttdLen) {
			return 0;
		}
		return rttdSum[idx];
	}
	
	public int getRttdCnt(int idx) {
		if (idx < 0 || idx >= rttdLen) {
			return 0;
		}
		return rttdCnt[idx];
	}
	
	public double getAoaSum(int idx) {
		if (idx < 0 || idx >= aoaLen) {
			return 0;
		}
		return aoaSum[idx];
	}
	
	public int getAoaCnt(int idx) {
		if (idx < 0 || idx >= aoaLen) {
			return 0;
		}
		return aoaCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class RttdRsrp {
	private final int rttdLen = 12;
	private final int rsrpLen = 12;
	private int[][] rttdRsrps = new int[rttdLen][rsrpLen];
	private double[] rttdSum = new double[rttdLen];
	private int[] rttdCnt = new int[rttdLen];
	private double[] rsrpSum = new double[rsrpLen];
	private int[] rsrpCnt = new int[rsrpLen];
	private boolean rttdRsrpFlag = false;
	private String _splitStr = "";
	
	public RttdRsrp(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < rttdLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				rttdRsrps[i][j] = 0;
			}
			rttdSum[i] = 0;
			rttdCnt[i] = 0;
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrpSum[i] = 0;
			rsrpCnt[i] = 0;
		}
	}
	
	public void sum(RttdRsrp rttdRsrp) {
		if (!rttdRsrp.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < rttdLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				rttdRsrps[i][j] += rttdRsrp.getRttdRsrp(i, j);
			}
			rttdSum[i] += rttdRsrp.getRttdSum(i);
			rttdCnt[i] += rttdRsrp.getRttdCnt(i);
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrpSum[i] += rttdRsrp.getRsrpSum(i);
			rsrpCnt[i] += rttdRsrp.getRsrpCnt(i);
		}
		rttdRsrpFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != rttdLen * rsrpLen) {
			return;
		}
		
		for (int i = 0; i < rttdLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				int num = Integer.parseInt(valueItems[i * rsrpLen + j]);
				rttdRsrps[i][j] += num;
				rttdSum[i] += parse.getRttd2DimValue(i) * num;
				rttdCnt[i] += num;
				rsrpSum[j] += parse.getRsrp2DimValue(j) * num;
				rsrpCnt[j] += num;
			}
		}
		rttdRsrpFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < rttdLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				line.append(rttdRsrps[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrpSum[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrpCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < rttdLen; i++) {
			line.append(rttdSum[i]).append(_splitStr);
		}
		for (int i = 0; i < rttdLen; i++) {
			line.append(rttdCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(div(rsrpSum[i], rsrpCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < rttdLen; i++) {
			line.append(div(rttdSum[i], rttdCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return rttdRsrpFlag;
	}
	
	public int getRttdRsrp(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= rttdLen || idx2 < 0 || idx2 >= rsrpLen) {
			return 0;
		}
		return rttdRsrps[idx1][idx2];
	}
	
	public double getRttdSum(int idx) {
		if (idx < 0 || idx >= rttdLen) {
			return 0;
		}
		return rttdSum[idx];
	}
	
	public int getRttdCnt(int idx) {
		if (idx < 0 || idx >= rttdLen) {
			return 0;
		}
		return rttdCnt[idx];
	}
	
	public double getRsrpSum(int idx) {
		if (idx < 0 || idx >= rsrpLen) {
			return 0;
		}
		return rsrpSum[idx];
	}
	
	public int getRsrpCnt(int idx) {
		if (idx < 0 || idx >= rsrpLen) {
			return 0;
		}
		return rsrpCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class SinrUlRip {
	private final int sinrUlLen = 11;
	private final int ripLen = 9;
	private int[][] sinrUlRips = new int[sinrUlLen][ripLen];
	private double[] sinrUlSum = new double[sinrUlLen];
	private int[] sinrUlCnt = new int[sinrUlLen];
	private double[] ripSum = new double[ripLen];
	private int[] ripCnt = new int[ripLen];
	private boolean sinrUlRipFlag = false;
	private String _splitStr = "";
	
	public SinrUlRip(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < sinrUlLen; i++) {
			for (int j = 0; j < ripLen; j++) {
				sinrUlRips[i][j] = 0;
			}
			sinrUlSum[i] = 0;
			sinrUlCnt[i] = 0;
		}
		
		for (int i = 0; i < ripLen; i++) {
			ripSum[i] = 0;
			ripCnt[i] = 0;
		}
	}
	
	public void sum(SinrUlRip sinrUlRip) {
		if (!sinrUlRip.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < sinrUlLen; i++) {
			for (int j = 0; j < ripLen; j++) {
				sinrUlRips[i][j] += sinrUlRip.getSinrUlRip(i, j);
			}
			sinrUlSum[i] += sinrUlRip.getSinrUlSum(i);
			sinrUlCnt[i] += sinrUlRip.getSinrUlCnt(i);
		}
		
		for (int i = 0; i < ripLen; i++) {
			ripSum[i] += sinrUlRip.getRipSum(i);
			ripCnt[i] += sinrUlRip.getRipCnt(i);
		}
		sinrUlRipFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != sinrUlLen * ripLen) {
			return;
		}
		
		for (int i = 0; i < sinrUlLen; i++) {
			for (int j = 0; j < ripLen; j++) {
				int num = Integer.parseInt(valueItems[i * ripLen + j]);
				sinrUlRips[i][j] += num;
				sinrUlSum[i] += parse.getSinrUl2DimValue(i) * num;
				sinrUlCnt[i] += num;
				ripSum[j] += parse.getRip2DimValue(j) * num;
				ripCnt[j] += num;
			}
		}
		sinrUlRipFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < sinrUlLen; i++) {
			for (int j = 0; j < ripLen; j++) {
				line.append(sinrUlRips[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(ripSum[i]).append(_splitStr);
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(ripCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < sinrUlLen; i++) {
			line.append(sinrUlSum[i]).append(_splitStr);
		}
		for (int i = 0; i < sinrUlLen; i++) {
			line.append(sinrUlCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < ripLen; i++) {
			line.append(div(ripSum[i], ripCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < sinrUlLen; i++) {
			line.append(div(sinrUlSum[i], sinrUlCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return sinrUlRipFlag;
	}
	
	public int getSinrUlRip(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= sinrUlLen || idx2 < 0 || idx2 >= ripLen) {
			return 0;
		}
		return sinrUlRips[idx1][idx2];
	}
	
	public double getSinrUlSum(int idx) {
		if (idx < 0 || idx >= sinrUlLen) {
			return 0;
		}
		return sinrUlSum[idx];
	}
	
	public int getSinrUlCnt(int idx) {
		if (idx < 0 || idx >= sinrUlLen) {
			return 0;
		}
		return sinrUlCnt[idx];
	}
	
	public double getRipSum(int idx) {
		if (idx < 0 || idx >= ripLen) {
			return 0;
		}
		return ripSum[idx];
	}
	
	public int getRipCnt(int idx) {
		if (idx < 0 || idx >= ripLen) {
			return 0;
		}
		return ripCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class TadvAoa {
	private final int tadvLen = 11;
	private final int aoaLen = 12;
	private int[][] tadvAoas = new int[tadvLen][aoaLen];
	private double[] tadvSum = new double[tadvLen];
	private int[] tadvCnt = new int[tadvLen];
	private double[] aoaSum = new double[aoaLen];
	private int[] aoaCnt = new int[aoaLen];
	private boolean tadvAoaFlag = false;
	private String _splitStr = "";
	
	public TadvAoa(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < tadvLen; i++) {
			for (int j = 0; j < aoaLen; j++) {
				tadvAoas[i][j] = 0;
			}
			tadvSum[i] = 0;
			tadvCnt[i] = 0;
		}
		
		for (int i = 0; i < aoaLen; i++) {
			aoaSum[i] = 0;
			aoaCnt[i] = 0;
		}
	}
	
	public void sum(TadvAoa tadvAoa) {
		if (!tadvAoa.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < tadvLen; i++) {
			for (int j = 0; j < aoaLen; j++) {
				tadvAoas[i][j] += tadvAoa.getTadvAoa(i, j);
			}
			tadvSum[i] += tadvAoa.getTadvSum(i);
			tadvCnt[i] += tadvAoa.getTadvCnt(i);
		}
		
		for (int i = 0; i < aoaLen; i++) {
			aoaSum[i] += tadvAoa.getAoaSum(i);
			aoaCnt[i] += tadvAoa.getAoaCnt(i);
		}
		tadvAoaFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != tadvLen * aoaLen) {
			return;
		}
		
		for (int i = 0; i < tadvLen; i++) {
			for (int j = 0; j < aoaLen; j++) {
				int num = Integer.parseInt(valueItems[i * aoaLen + j]);
				tadvAoas[i][j] += num;
				tadvSum[i] += parse.getTadv2DimValue(i) * num;
				tadvCnt[i] += num;
				aoaSum[j] += parse.getAoa2DimValue(j) * num;
				aoaCnt[j] += num;
			}
		}
		tadvAoaFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < tadvLen; i++) {
			for (int j = 0; j < aoaLen; j++) {
				line.append(tadvAoas[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < aoaLen; i++) {
			line.append(aoaSum[i]).append(_splitStr);
		}
		for (int i = 0; i < aoaLen; i++) {
			line.append(aoaCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < tadvLen; i++) {
			line.append(tadvSum[i]).append(_splitStr);
		}
		for (int i = 0; i < tadvLen; i++) {
			line.append(tadvCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < aoaLen; i++) {
			line.append(div(aoaSum[i], aoaCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < tadvLen; i++) {
			line.append(div(tadvSum[i], tadvCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return tadvAoaFlag;
	}
	
	public int getTadvAoa(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= tadvLen || idx2 < 0 || idx2 >= aoaLen) {
			return 0;
		}
		return tadvAoas[idx1][idx2];
	}
	
	public double getTadvSum(int idx) {
		if (idx < 0 || idx >= tadvLen) {
			return 0;
		}
		return tadvSum[idx];
	}
	
	public int getTadvCnt(int idx) {
		if (idx < 0 || idx >= tadvLen) {
			return 0;
		}
		return tadvCnt[idx];
	}
	
	public double getAoaSum(int idx) {
		if (idx < 0 || idx >= aoaLen) {
			return 0;
		}
		return aoaSum[idx];
	}
	
	public int getAoaCnt(int idx) {
		if (idx < 0 || idx >= aoaLen) {
			return 0;
		}
		return aoaCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity.mrs.twodim;

import com.boco.wangyou.algorithm.counter.MrsParse;

public class TadvRsrp {
	private final int tadvLen = 11;
	private final int rsrpLen = 12;
	private int[][] tadvRsrps = new int[tadvLen][rsrpLen];
	private double[] tadvSum = new double[tadvLen];
	private int[] tadvCnt = new int[tadvLen];
	private double[] rsrpSum = new double[rsrpLen];
	private int[] rsrpCnt = new int[rsrpLen];
	private boolean tadvRsrpFlag = false;
	private String _splitStr = "";
	
	public TadvRsrp(String splitStr) {
		_splitStr = splitStr;
		
		for (int i = 0; i < tadvLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				tadvRsrps[i][j] = 0;
			}
			tadvSum[i] = 0;
			tadvCnt[i] = 0;
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrpSum[i] = 0;
			rsrpCnt[i] = 0;
		}
	}
	
	public void sum(TadvRsrp tadvRsrp) {
		if (!tadvRsrp.isNotEmpty()) {
			return;
		}
		
		for (int i = 0; i < tadvLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				tadvRsrps[i][j] += tadvRsrp.getTadvRsrp(i, j);
			}
			tadvSum[i] += tadvRsrp.getTadvSum(i);
			tadvCnt[i] += tadvRsrp.getTadvCnt(i);
		}
		
		for (int i = 0; i < rsrpLen; i++) {
			rsrpSum[i] += tadvRsrp.getRsrpSum(i);
			rsrpCnt[i] += tadvRsrp.getRsrpCnt(i);
		}
		tadvRsrpFlag = true;
	}
	
	public void sum(String[] valueItems, MrsParse parse) {
		if (valueItems.length != tadvLen * rsrpLen) {
			return;
		}
		
		for (int i = 0; i < tadvLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				int num = Integer.parseInt(valueItems[i * rsrpLen + j]);
				tadvRsrps[i][j] += num;
				tadvSum[i] += parse.getTadv2DimValue(i) * num;
				tadvCnt[i] += num;
				rsrpSum[j] += parse.getRsrp2DimValue(j) * num;
				rsrpCnt[j] += num;
			}
		}
		tadvRsrpFlag = true;
	}
	
	public String getLine(StringBuffer line) {
		line.setLength(0);
		for (int i = 0; i < tadvLen; i++) {
			for (int j = 0; j < rsrpLen; j++) {
				line.append(tadvRsrps[i][j]).append(_splitStr);
			}
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrpSum[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(rsrpCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < tadvLen; i++) {
			line.append(tadvSum[i]).append(_splitStr);
		}
		for (int i = 0; i < tadvLen; i++) {
			line.append(tadvCnt[i]).append(_splitStr);
		}
		for (int i = 0; i < rsrpLen; i++) {
			line.append(div(rsrpSum[i], rsrpCnt[i], 0)).append(_splitStr);
		}
		for (int i = 0; i < tadvLen; i++) {
			line.append(div(tadvSum[i], tadvCnt[i], 0)).append(_splitStr);
		}
		line.deleteCharAt(line.length() - 1);
		return line.toString();
	}
	
	public boolean isNotEmpty() {
		return tadvRsrpFlag;
	}
	
	public int getTadvRsrp(int idx1, int idx2) {
		if (idx1 < 0 || idx1 >= tadvLen || idx2 < 0 || idx2 >= rsrpLen) {
			return 0;
		}
		return tadvRsrps[idx1][idx2];
	}
	
	public double getTadvSum(int idx) {
		if (idx < 0 || idx >= tadvLen) {
			return 0;
		}
		return tadvSum[idx];
	}
	
	public int getTadvCnt(int idx) {
		if (idx < 0 || idx >= tadvLen) {
			return 0;
		}
		return tadvCnt[idx];
	}
	
	public double getRsrpSum(int idx) {
		if (idx < 0 || idx >= rsrpLen) {
			return 0;
		}
		return rsrpSum[idx];
	}
	
	public int getRsrpCnt(int idx) {
		if (idx < 0 || idx >= rsrpLen) {
			return 0;
		}
		return rsrpCnt[idx];
	}
	
	private double div(double numerator, int denominator, double defaultValue) {
		if (denominator == 0) {
			return defaultValue;
		}
		return numerator / denominator;
	}
}
package com.boco.wangyou.ltemr.parse.entity;

public class SmrValue {
	public String getValue(String col, String[] valueItems, MrIdxInfo idxInfo, int len) {
		int idx = idxInfo.getIdx(col);
		if (idx != -1 && idx < len) {
			if ("nil".equals(valueItems[idx])) {
				return "-1";
			}
			return valueItems[idx];
		}
		return "-1";
	}
}
package com.boco.wangyou.ltemr.parse.entity;

import com.boco.wangyou.utility.TimeUtils;

public class XmlCommonInfo {
	private String _splitStr = "";
	private String _reportTime = "";
	private String _startTime = "";
	private String _endTime = "";
	private String _enbId = "";
	private String _userLabel = "";
	private int _startTimeHour = -1;
	private String _startTimeStr = "";
	private TimeUtils timeUtils = new TimeUtils();
	
	public XmlCommonInfo(String splitStr) {
		_splitStr = splitStr;
	}
	
	public void setHeader(String reportTime, String startTime) {
		_reportTime = reportTime;
		_startTime = startTime.substring(0, 13) + ":00:00";
		_endTime = timeUtils.getNextHour(_startTime);
		_startTimeHour = Integer.parseInt(startTime.substring(11, 13));
		_startTimeStr = startTime.replaceAll("[- :]", "").substring(0, 10);
	}
	
	public void setEnb(String enbId, String userLabel) {
		_enbId = enbId;
		_userLabel = userLabel;
	}
	
	public String getLine() {
		return _reportTime + _splitStr + _startTime + _splitStr + _endTime;
	}
	
	
	public String getEnodeb() {
		return _enbId;
	}
	
	public String getStartTime() {
		return _startTime;
	}
	
	public String getEndTime() {
		return _endTime;
	}
	
	public String getUserLabel() {
		return _userLabel;
	}
	
	public int getStartTimeHour() {
		return _startTimeHour;
	}
	
	public String getStartTimeStr() {
		return _startTimeStr;
	}
	
	public String getAllLine() {
		return _reportTime + _splitStr + _startTime + _splitStr + _endTime + _splitStr + _enbId + _splitStr + _userLabel;
	}
	
}
package com.boco.wangyou.ltemr.parse.invoker.hadoop;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

import com.boco.wangyou.utility.LogUtil;
import com.boco.wangyou.utility.cfg.DriverConfigUtils;
import com.boco.wangyou.utility.stream.NullInputFormat;

public class LteMrParseDriver extends Configured implements Tool {
	public static void main(String[] args) throws Exception {
		
//		String[] args = {"cache/wy/ltemro/1501840005364","wangyou/ltemro/xml/0000062-170727154341833-oozie-oozi-W","oozie_wy/ini","oozie_wy/config/lte","2017-08-02_01","oozie_wy/xmlout_temp"};
//		String[] args = {"cache/wy/ltemro/1505201805133","wangyou/ltemro/xml/0000001-170911165007368-oozie-oozi-W","oozie_wy/ini","oozie_wy/config/lte","2017-08-06","oozie_wy/xmlout_temp"};
		if (args.length < 6) {
			System.out.println("Arguments list:\n$source_dir $dest_dir $ini_dir $cfg_dir $date_time $map output");
			System.exit(0);
		}
		
		int ret = ToolRunner.run(new LteMrParseDriver(), args);
		System.exit(ret);
	}
	
	@Override
	public int run(String[] args) throws Exception {
		Configuration basicConf = LogUtil.getConfig();
		DriverConfigUtils dConfigs = new DriverConfigUtils(); 
		String driverCfg = args[3]+"/parse_driver.properties";
		Configuration conf = dConfigs.initConfig(basicConf,driverCfg);
		
		conf.set("DEST_PATH", args[1]);
		conf.set("INIT_PATH", args[2]);
		conf.set("CONFIG_PATH", args[3]);
		conf.set("START_TIME", args[4]);
		
		FileSystem fs = FileSystem.get(conf);
//		Path outPath = new Path(args[5]);
		Path outPath = new Path(args[1]);//TODO mos输出方式
		if (fs.exists(outPath)) {
			fs.delete(outPath, true);
		}
			
		Job job = Job.getInstance(conf);
		job.setJarByClass(LteMrParseDriver.class);
		job.setJobName(getClass().getName());
		FileInputFormat.setInputPaths(job, new Path(args[0]));
		FileOutputFormat.setOutputPath(job, outPath);
		job.setInputFormatClass(NullInputFormat.class);
		job.setMapperClass(LteMrParseMapper.class);
		job.setNumReduceTasks(0);
		job.setMapOutputKeyClass(Text.class);
		job.setMapOutputValueClass(Text.class);
		FileOutputFormat.setCompressOutput(job, false); 
		
		boolean success = job.waitForCompletion(true);
		return success ? 0 : 1;
	}
}
package com.boco.wangyou.ltemr.parse.invoker.hadoop;

import java.io.IOException;

import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.lib.input.FileSplit;
import org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;

import com.boco.wangyou.ltemr.parse.domainmodel.LteMrXmlParse;
import com.boco.wangyou.ltemr.parse.domainmodel.XmlParseStream;
//import com.boco.wangyou.ltemr.parse.domainmodel.mre.LteMreXmlParse;
import com.boco.wangyou.ltemr.parse.domainmodel.mro.LteMroXmlParse;
//import com.boco.wangyou.ltemr.parse.domainmodel.mrs.LteMrsXmlParse;
import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.utility.cfg.ConfigConstants;
import com.boco.wangyou.utility.stream.NullInputFormat;
import com.boco.wangyou.utility.write.WriteData;
import com.boco.wangyou.utility.write.WriteDataMos;

public class LteMrParseMapper extends Mapper<Object, NullInputFormat, Text, Text> {
	private XmlParseStream _stream = null;
	private CommonInfo _commonInfo = null;
	private WriteData _writeData = null;
	private ConfigConstants _cfgInfo = null;
	private Path _file = null;
	private String _fileName = "";
	
	private static MultipleOutputs<NullWritable, Text> mos;
	Text tv = new Text();
	
	@SuppressWarnings({ "unchecked", "rawtypes" })
	@Override
	public void setup(Context context) throws IOException, InterruptedException {
		FileSplit fileSplit = (FileSplit)context.getInputSplit();
		_file = fileSplit.getPath();
		_fileName = _file.getName();
		System.out.println("parse file:"+_file+"/"+_fileName);
		String cfgDir = context.getConfiguration().get("CONFIG_PATH");
		_cfgInfo = new ConfigConstants(cfgDir + "/ltemr_data.properties", 1);
		
		String startTime = context.getConfiguration().get("START_TIME");
		_commonInfo = new CommonInfo(_cfgInfo.getValue("SPLIT_STRING", "|"));
		_commonInfo.setTime(startTime);
		_commonInfo.setId(_fileName);
		
		String destDir = context.getConfiguration().get("DEST_PATH");
		String threadId = _fileName.substring(_fileName.lastIndexOf("_") + 1, _fileName.indexOf("."));
		String encode = _cfgInfo.getValue("CHARACTER_SET", "UTF-8");
//		_writeData = new WriteDataHdfs(destDir, _commonInfo.getOmcId(), threadId, encode);
		//TODO mos输出方式
		mos = new MultipleOutputs(context);
		_writeData = new WriteDataMos(destDir, _commonInfo.getOmcId(),tv,mos);
		_stream = new XmlParseStream();
	}
	
	@Override
	public void map(Object key, NullInputFormat value, Context context) throws IOException, InterruptedException {
		String iniDir = context.getConfiguration().get("INIT_PATH");
		
		_stream.makeStream(_file, 1);
		LteMrXmlParse parse = new LteMroXmlParse(_stream, _commonInfo, _writeData, iniDir, _cfgInfo, 1);
		/*if (_fileName.contains("MRO")) {
			_stream.makeStream(_file, 1);
			parse = new LteMroXmlParse(_stream, _commonInfo, _writeData, iniDir, _cfgInfo, 1);
		} else if (_fileName.contains("MRS")) {
			_stream.makeStream(_file, 0);
			parse = new LteMrsXmlParse(_stream, _commonInfo, _writeData, iniDir, _cfgInfo, 1);
		} else if (_fileName.contains("MRE")) {
			_stream.makeStream(_file, 0);
			parse = new LteMreXmlParse(_stream, _commonInfo, _writeData, iniDir, _cfgInfo, 1);
		} else {
			return;
		}*/
		try {
			parse.read();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	@Override
	public void cleanup(Context context) throws IOException, InterruptedException {
//		_stream.close();
//		_writeData.close();
		//TODO mos输出方式
		mos.close();
	}
}
package com.boco.wangyou.ltemr.parse.invoker.local;

import java.io.File;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import com.boco.wangyou.utility.cfg.ConfigConstants;

public class Invoker {
	public static void main(String[] args) {
		if (args.length < 5) {
			System.out.println("Arguments list:\n$source_dir $dest_dir $ini_dir $cfg_dir $date_time");
			System.exit(0);
		}
		
		String sourceDir = args[0];
		String destDir = args[1];
		String iniDir = args[2];
		String cfgDir = args[3];
		String startTime = args[4];
		
		ConfigConstants cfgInfo = new ConfigConstants(cfgDir + "/ltemr_data.properties", 0);
		int threadNum = Integer.parseInt(cfgInfo.getValue("PARSE_THREAD_NUM", "4"));
		
		File dir = new File(sourceDir);
		File[] files = dir.listFiles();
		if (files == null) {
			return;
		}
		ExecutorService executor = Executors.newFixedThreadPool(threadNum);
		for (File file : files) {
			LteMrParse parse = new LteMrParse(file, destDir, iniDir, cfgInfo, startTime);
			executor.execute(parse);
		}
		executor.shutdown();
		try {
			if (!executor.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS)) {
				executor.shutdownNow();
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
package com.boco.wangyou.ltemr.parse.invoker.local;

import java.io.File;
import java.io.IOException;

import com.boco.wangyou.ltemr.parse.domainmodel.LteMrXmlParse;
import com.boco.wangyou.ltemr.parse.domainmodel.XmlParseStream;
//import com.boco.wangyou.ltemr.parse.domainmodel.mre.LteMreXmlParse;
import com.boco.wangyou.ltemr.parse.domainmodel.mro.LteMroXmlParse;
//import com.boco.wangyou.ltemr.parse.domainmodel.mrs.LteMrsXmlParse;
import com.boco.wangyou.ltemr.parse.entity.CommonInfo;
import com.boco.wangyou.utility.cfg.ConfigConstants;
import com.boco.wangyou.utility.write.WriteData;
import com.boco.wangyou.utility.write.WriteDataLocal;

public class LteMrParse implements Runnable {
	private File _sourceFile = null;
	private String _destDir = null;
	private String _iniDir = null;
	private ConfigConstants _cfgInfo = null;
	private CommonInfo _commonInfo = null;
	
	public LteMrParse(File sourceFile, String destDir, String iniDir, ConfigConstants cfgInfo, String startTime) {
		_sourceFile = sourceFile;
		_destDir = destDir;
		_iniDir = iniDir;
		_cfgInfo = cfgInfo;
		_commonInfo = new CommonInfo(_cfgInfo.getValue("SPLIT_STRING", "|"));
		_commonInfo.setTime(startTime);
		_commonInfo.setId(_sourceFile.getName());
	}
	
	public void run() {
		String fileName = _sourceFile.getName();
		String threadId = fileName.substring(fileName.lastIndexOf("_") + 1, fileName.indexOf("."));
		String encode = _cfgInfo.getValue("CHARACTER_SET", "UTF-8");
		WriteData writeData = new WriteDataLocal(_destDir, _commonInfo.getOmcId(), threadId, encode);
		
		XmlParseStream stream = new XmlParseStream();
		
		stream.makeStream(_sourceFile, 1);
		LteMrXmlParse parse = new LteMroXmlParse(stream, _commonInfo, writeData, _iniDir, _cfgInfo, 0);
		/*if (fileName.contains("MRO")) {
			stream.makeStream(_sourceFile, 1);
			parse = new LteMroXmlParse(stream, _commonInfo, writeData, _iniDir, _cfgInfo, 0);
		} else if (fileName.contains("MRS")) {
			stream.makeStream(_sourceFile, 0);
			parse = new LteMrsXmlParse(stream, _commonInfo, writeData, _iniDir, _cfgInfo, 0);
		} else if (fileName.contains("MRE")) {
			stream.makeStream(_sourceFile, 0);
			parse = new LteMreXmlParse(stream, _commonInfo, writeData, _iniDir, _cfgInfo, 0);
		} else {
			stream.close();
			writeData.close();
			return;
		}*/
		try {
			parse.read();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		stream.close();
		writeData.close();
	}
}
